/*	SCCS Id: @(#)u_init.c	3.4	2002/10/22	*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* NetHack may be freely redistributed.  See license for details. */

#include "hack.h"

struct trobj {
	short trotyp;
	schar trspe;
	char trclass;
	int trquan;
	Bitfield(trbless,2);
};

STATIC_DCL void ini_inv(struct trobj *);
STATIC_DCL void knows_object(int);
STATIC_DCL void knows_class(CHAR_P);
STATIC_DCL boolean restricted_spell_discipline(int);

#define UNDEF_TYP	0
#define UNDEF_SPE	'\177'
#define UNDEF_BLESS	2

/*
 *	Initial inventory for the various roles.
 */

static struct trobj Archeologist[] = {
#define A_BOOK          4
	/* if adventure has a name...  idea from tan@uvm-gen */
	{ BULLWHIP, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_JACKET, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FEDORA, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 3, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ PICK_AXE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ TINNING_KIT, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ TOUCHSTONE, 0, GEM_CLASS, 1, 0 },
	{ SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Anachronist[] = {  
	{ PISTOL, 0, WEAPON_CLASS, 1, 0 },  
	{ FORCE_PIKE,  0, WEAPON_CLASS, 1, 0 },  
	{ RIFLE, 0, WEAPON_CLASS, 1, 0 },  
	{ PLASTEEL_ARMOR, 0, ARMOR_CLASS, 1, 0 },  
	{ T_SHIRT, 0, ARMOR_CLASS, 1, 0 },  
	{ PLASTEEL_HELM, 0, ARMOR_CLASS, 1, 0 },  
	{ PLASTEEL_GLOVES, 0, ARMOR_CLASS, 1, 0 },  
	{ PLASTEEL_BOOTS, 0, ARMOR_CLASS, 1, 0 },  
	{ CLOAK_OF_MAGIC_RESISTANCE, 0, ARMOR_CLASS, 1, 0 },  
	{ PILL, 0, FOOD_CLASS, 20, 0 },  
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ RADAWAY, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj Feminist[] = {
	{ HIGH_HEELED_SANDAL, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHURIKEN, UNDEF_SPE, WEAPON_CLASS, 20, UNDEF_BLESS },
	{ LANCE, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ KILLER_HEELS, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_LEASH, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ STETHOSCOPE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 5, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj FormChanger[] = {
	{ WAN_POLYMORPH, 15, WAND_CLASS, 1, 1 },

	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj Tracer[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 3, UNDEF_BLESS },
	{ TAIL_SPIKES, 0, VENOM_CLASS, 1, 0 },
	{ LUCKSTONE, UNDEF_SPE, GEM_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj NuclearPhysicist[] = {
	{ SPEAR, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ JUMPSUIT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_HEALING, 0, POTION_CLASS, 2, UNDEF_BLESS },
	{ WAN_PROBING, 30, WAND_CLASS, 1, UNDEF_BLESS },
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ RADAWAY, 0, TOOL_CLASS, 1, 0 },
	{ RADAWAY, 0, TOOL_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj GangScholar[] = {
#define GSC_WEAPON          0
#define GSC_ARMOR          1
#define GSC_RING          2
#define GSC_POTION          3
#define GSC_SCROLL          4
#define GSC_WAND          5
#define GSC_BOOK          6
	{ DAGGER, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ RIN_ADORNMENT, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ POT_HEALING, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ SCR_PHASE_DOOR, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_MAGIC_MISSILE, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ SPE_PROTECTION, 2, SPBOOK_CLASS, 1, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }  
};  

static struct trobj Artist[] = {
	{ SPOON, 2, TOOL_CLASS, 1, UNDEF_BLESS },
	{ TOUCHSTONE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ FEDORA, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ MALLET, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ GAUNTLETS_OF_DEXTERITY, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LAB_COAT, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 2, UNDEF_BLESS },
	{ POT_OIL, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ POT_WATER, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ MAGIC_MARKER, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ FELT_TIP_MARKER, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Gamer[] = {
	{ T_SHIRT, 1, ARMOR_CLASS, 1, 1 },
	{ SPOON, UNDEF_SPE, WEAPON_CLASS, 13, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ CRAM_RATION, 0, FOOD_CLASS, 4, 1 },
	{ K_RATION, 0, FOOD_CLASS, 2, 1 },
	{ CANDY_BAR, 0, FOOD_CLASS, 7, 1 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Librarian[] = {
	{ ROBE, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LENSES, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ MAGIC_MARKER, 0, TOOL_CLASS, 1, UNDEF_BLESS }, /* empty on purpose */
	{ FELT_TIP_MARKER, 100, TOOL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ SPE_BLANK_PAPER, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 1 },        
	{ SCR_BLANK_PAPER, UNDEF_SPE, SCROLL_CLASS, 5, 1 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Shapeshifter[] = {
	{ WAN_POLYMORPH, UNDEF_SPE, WAND_CLASS, 1, 1 },
	{ WAN_POLYMORPH, UNDEF_SPE, WAND_CLASS, 1, 1 },
	{ POT_POLYMORPH, 0, POTION_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Midget[] = {
	{ DWARVISH_MATTOCK, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ DWARVISH_IRON_HELM, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ DWARVISH_MITHRIL_COAT, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Golddigger[] = {
	{ PICK_AXE, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ GNOMISH_SUIT, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ GNOMISH_HELM, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ GNOMISH_BOOTS, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Ringseeker[] = {
	{ SLING, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Supermarket[] = {
	{ KNIFE, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_JACKET, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LOW_BOOTS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	{ TIN_OPENER, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ POT_FRUIT_JUICE, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ POT_BOOZE, 0, POTION_CLASS, 2, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Scribe[] = {
	{ MAGIC_MARKER, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 3, UNDEF_BLESS },        
	{ SCR_BLANK_PAPER, UNDEF_SPE, SCROLL_CLASS, 5, UNDEF_BLESS },
	{ DAGGER, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ CLOAK_OF_DISPLACEMENT, 0, ARMOR_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Augurer[] = {
#define AUG_BOOK          2
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ BLINDFOLD, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Barbarian[] = {
#define B_MAJOR	0	/* two-handed sword or battle-axe  */
#define B_MINOR	1	/* matched with axe or short sword */
	{ TWO_HANDED_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ AXE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ RING_MAIL, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj NoobModeBarb[] = {
#define N_MAJOR	0	/* two-handed sword or battle-axe  */
#define N_MINOR	1	/* matched with axe or short sword */
	{ TWO_HANDED_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ AXE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ RING_MAIL, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Binder[] = {
	{ VOULGE, 0, WEAPON_CLASS, 1, 0 },
	{ KNIFE, 0, WEAPON_CLASS, 1, 0 },
	{ ROCK, 0, GEM_CLASS, 5, 0 }, 
	{ FLINT, 0, GEM_CLASS, 1, 0 },
	{ LEATHER_CLOAK, 0, ARMOR_CLASS, 1, 0 },
	{ CRAM_RATION, 0, FOOD_CLASS, 1, 0 },
	{ APPLE, 0, FOOD_CLASS, 2, 0 },
	{ TRIPE_RATION, 0, FOOD_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Politician[] = {
	{ T_SHIRT, 2, ARMOR_CLASS, 1, 0 },
	{ LEATHER_JACKET, 0, ARMOR_CLASS, 1, 0 },
	{ LOW_BOOTS, 0, ARMOR_CLASS, 1, 0 },
	{ BAG_OF_HOLDING, 0, TOOL_CLASS, 1, 0 },
	{ BELL, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj DQSlime[] = {
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Alltecher[] = {
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Spellmaster[] = {
	{ SPE_BLANK_PAPER, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_BLANK_PAPER, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Cook[] = {
	{ ROBE, 2, ARMOR_CLASS, 1, 0 },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, 0, FOOD_CLASS, 2, 0 },
	{ KNIFE, 2, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Erdrick[] = {
	{ BATTLE_STAFF, 0, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ ANTI_CASTER_CLOAK, -5, ARMOR_CLASS, 1, 0 },
	{ SADO_MASO_GLOVES, -5, ARMOR_CLASS, 1, 0 },
	{ STAIRWELL_STOMPING_BOOTS, -5, ARMOR_CLASS, 1, 0 },
	{ STANDARD_HELMET, 1, ARMOR_CLASS, 1, 1 },
	{ TORCH, 0, TOOL_CLASS, 1, 0 },
	{ EUCALYPTUS_LEAF, 0, FOOD_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Bleeder[] = {
	{ KNIFE, 0, WEAPON_CLASS, 1, 0 },
	{ POT_VAMPIRE_BLOOD, 0, POTION_CLASS, 2, 0 },
	{ LAB_COAT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ RIN_TIMELY_BACKUP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ AMULET_OF_DATA_STORAGE, 0, AMULET_CLASS, 1, UNDEF_BLESS },
	{ ICE_BOX, 0, TOOL_CLASS, 1, 0 },
	{ MIRROR, 0, TOOL_CLASS, 1, 0 },
	{ CAN_OF_GREASE, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ SCR_ROOT_PASSWORD_DETECTION, 0, SCROLL_CLASS, 1, 1 },
	{ SPE_PROTECTION, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_RESIST_POISON, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_BOTOX_RESIST, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ FAERIE_FLOSS_RHING, 0, VENOM_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Bard[] = {
#define BARD_INSTR 0
#define BARD_BOOZE 4
#define BARD_WHISTLE 5
	{ WOODEN_HARP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_CLOAK, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 3, 0 },
	{ ORANGE, 0, FOOD_CLASS, 3, 0 },
	{ POT_BOOZE, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ TIN_WHISTLE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Cave_man[] = {
#define C_AMMO	2
	{ CLUB, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SLING, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ FLINT, 0, GEM_CLASS, 15, UNDEF_BLESS },	/* quan is variable */
	{ ROCK, 0, GEM_CLASS, 3, 0 },			/* yields 18..33 */
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Electric_Mage[] = {
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },        /* for dealing with ghosts */
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_LIGHTNING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_SHOCKING_SPHERE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_LIGHTNING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Poison_Mage[] = {
	{ SILVER_KHAKKHARA, 2, WEAPON_CLASS, 1, 1 },
	{ POISONOUS_CLOAK, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_POISON, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ WAN_VENOM_SCATTERING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_CONFUSE_MONSTER, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_PROTECTION, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_CURE_BLINDNESS, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_POISON_BLAST, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj OccultMaster[] = {
#define O_BOOK1         0
#define O_BOOK2         1
#define O_BOOK3         2
#define O_BOOK4         3
#define O_WAND         4
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },       
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },       
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 1 },       
	{ COLLUSION_KNIFE, 3, WEAPON_CLASS, 1, 1 },
	{ BLACK_DRESS, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ K_RATION, 0, FOOD_CLASS, 5, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_STINKING_CLOUD, 0, SCROLL_CLASS, 1, 1 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Elementalist[] = {
#define E_BOOK1         0
#define E_BOOK2         1
#define E_BOOK3         2
#define E_BOOK4         3
#define E_WAND         4
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 1 },        
	{ FIRE_STICK, 2, WEAPON_CLASS, 1, 1 },
	{ ROBE_OF_PERMANENCE, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj ChaosSorceror[] = {
#define C_BOOK1         0
#define C_BOOK2         1
#define C_BOOK3         2
#define C_BOOK4         3
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },        
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },       
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },       
	{ UNDEF_TYP, 0, WEAPON_CLASS, 1, 0 },
	{ ROBE_OF_RANDOMNESS, 3, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ SCR_RUMOR, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_MESSAGE, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 2, UNDEF_BLESS },
	{ HACKER_S_FOOD, 0, FOOD_CLASS, 1, 0 },
	{ SILVER_SLINGSTONE, 0, GEM_CLASS, 10, UNDEF_BLESS },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj WildTalent[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RANDOM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RANDOM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RANDOM_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Abuser[] = {
	{ BULLWHIP, 8, WEAPON_CLASS, 1, 1 },
	{ KNOUT, 2, WEAPON_CLASS, 1, 1 },
	{ IRON_CHAIN, 8, CHAIN_CLASS, 1, 1 },
	{ VICTORIAN_UNDERWEAR, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_JACKET, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ KICKING_BOOTS, 3, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ AMULET_OF_POWER, 0, AMULET_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_LEASH, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ CAN_OF_GREASE, 50, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SCR_PUNISHMENT, 0, SCROLL_CLASS, 1, 0 },
	{ SPE_GODMODE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ WAN_PUNISHMENT, 6, WAND_CLASS, 1, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Jester[] = {

	{ HAWAIIAN_SHIRT, 3, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ DUNCE_CAP, 3, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 27, UNDEF_BLESS },
	{ DAGGER, 1, WEAPON_CLASS, 2, UNDEF_BLESS },
	{ CREAM_PIE, 0, FOOD_CLASS, 10, UNDEF_BLESS },
	{ CORPSE, 0, FOOD_CLASS, 1, UNDEF_BLESS },
	{ RUBBER_HOSE, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ TOWEL, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 2, UNDEF_BLESS },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Ladiesman[] = {
	{ KNIFE, UNDEF_SPE, WEAPON_CLASS, 2, UNDEF_BLESS },
	{ DIAMOND, UNDEF_SPE, GEM_CLASS, 3, UNDEF_BLESS },
	{ RIN_ADORNMENT, UNDEF_SPE, RING_CLASS, 2, UNDEF_BLESS },
	{ RUFFLED_SHIRT, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FEDORA, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ SACK, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ LENSES, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Fighter[] = {

	{ SHORT_SWORD, 2, WEAPON_CLASS, 1, 1 },
	{ SAILOR_BLOUSE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ WAN_POLYMORPH, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 3, UNDEF_BLESS },
	{ PANCAKE, 0, FOOD_CLASS, 3, 0 },
	{ CANDY_BAR, 0, FOOD_CLASS, 3, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Fencer[] = {

	{ SHORT_SWORD, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DAGGER, 0, WEAPON_CLASS, 5, UNDEF_BLESS },
	{ LEATHER_ARMOR, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ RIN_INCREASE_ACCURACY,2, RING_CLASS, 1, UNDEF_BLESS },
	{ ORANGE, 0, FOOD_CLASS, 5, 0 },
	{ PEAR, 0, FOOD_CLASS, 5, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Medium[] = {
#define MED_BOW         1
#define MED_TWO_ARROWS  2
#define MED_ZERO_ARROWS 3

	{ SILVER_DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ YUMI, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ YA, 2, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ YA, 0, WEAPON_CLASS, 30, UNDEF_BLESS },
	{ ROBE, 1, ARMOR_CLASS,	1, UNDEF_BLESS },
	{ POT_WATER, 0, POTION_CLASS,	4, 1 },	/* holy water */
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ BOTA_MOCHI, 0, FOOD_CLASS, 4, 0 },
	{ BEAN, 0, FOOD_CLASS, 20, 0 },
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ ORANGE, 0, FOOD_CLASS, 10, 0 },
	{ WAN_PSYBEAM, 3, WAND_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj JusticeKeeper[] = {

	{ MACE, 3, WEAPON_CLASS, 1, 1 },
	{ SPLINT_MAIL, 3, ARMOR_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj StandUser[] = {

	{ TOOLED_HORN, 0, TOOL_CLASS, 1, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Sexymate[] = {

	{ FEMININE_PUMPS, 7, ARMOR_CLASS, 1, 0 },
	{ CONDOME, 0, TOOL_CLASS, 1, 0 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Bloodseeker[] = {

	{ SHORT_SWORD, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ COMBAT_STILETTOS, 2, ARMOR_CLASS, 1, 0 },
	{ WAN_FIRE, 2, WAND_CLASS, 1, 0 },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Mystic[] = {

	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, IMPLANT_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ROCK_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, BALL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, CHAIN_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, VENOM_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RANDOM_CLASS, 1, 0 },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj SlaveMaster[] = {
	{ TRIPE_RATION, 0, FOOD_CLASS, 3, 0 },
	{ FOOD_RATION, 0, FOOD_CLASS, 5, 0 },
	{ APPLE, 0, FOOD_CLASS, 3, 0 },
	{ ORANGE, 0, FOOD_CLASS, 1, 0 },
	{ TIN, 1, FOOD_CLASS, 2, 0 },
	{ LEATHER_LEASH, 2, TOOL_CLASS, 1, 0 },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, 0 },
	{ MAGIC_WHISTLE, 0, TOOL_CLASS, 1, 0 },

  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Acid_Mage[] = {
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },        /* for dealing with ghosts */
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_ACID, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_ACID_SPHERE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_ACID_STREAM, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};

static struct trobj Flame_Mage[] = {
#define F_BOOK          9
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },        /* for dealing with ghosts */
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_FIRE, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_FLAME_SPHERE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_FIREBALL, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
  	{ 0, 0, 0, 0, 0 }
};
static struct trobj Convict[] = {
	{ ROCK, 0, GEM_CLASS, 1, 0 },
	{ STRIPED_SHIRT, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Murderer[] = {
#define M_ITEM_ONE          6
#define M_ITEM_TWO          7
#define M_ITEM_THREE        8
#define M_ITEM_FOUR         9
	{ SNIPER_RIFLE, -9, WEAPON_CLASS, 1, 0 },
	{ SHOTGUN_SHELL, 10, WEAPON_CLASS, 5, 0 },
	{ ROCK, -6, GEM_CLASS, 1, 0 },
	{ KNIFE, -4, WEAPON_CLASS, 20, 1 },
	{ STRIPED_SHIRT, -5, ARMOR_CLASS, 1, 0 },
	{ CYAN_DRAGON_SCALE_MAIL, -10, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, -20, GEM_CLASS, 1, 0 },
	{ UNDEF_TYP, 1, TOOL_CLASS, 1, 0 },
	{ CLOAK_OF_LUCK_NEGATION, 0, ARMOR_CLASS, 1, 0 },
	{ BOOTS_OF_WEAKNESS, 5, ARMOR_CLASS, 1, 0 },
	{ HEALTHSTONE, -10, GEM_CLASS, 1, 0 },
	{ AMULET_OF_POISON_WARNING, 0, AMULET_CLASS, 1, 0 },
	{ RIN_SUSTAIN_ABILITY, 0, RING_CLASS, 1, 0 },
	{ RIN_GAIN_INTELLIGENCE, UNDEF_SPE, RING_CLASS, 1, 0 },
	{ SPE_DARKNESS, 20, SPBOOK_CLASS, 1, 0 },
	{ SPE_AGGRAVATE_MONSTER, 20, SPBOOK_CLASS, 1, 0 },
	{ SPE_STUN_SELF, 20, SPBOOK_CLASS, 1, 0 },
	{ WAN_REMOVE_RESISTANCE, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ WAN_AMNESIA, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ WAN_STARVATION, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ SCR_FLOOD, 0, SCROLL_CLASS, 1, 0 },
	{ SCR_LAVA, 0, SCROLL_CLASS, 1, 0 },
	{ SCR_GROWTH, 0, SCROLL_CLASS, 1, 0 },
	{ SCR_BARRHING, 0, SCROLL_CLASS, 1, 0 },
	{ SCR_LOCKOUT, 0, SCROLL_CLASS, 1, 0 },
	{ POT_URINE, 0, POTION_CLASS, 3, 0 },
	{ FORTUNE_COOKIE, 0, FOOD_CLASS, 5, 0 },
	{ CORPSE, 0, FOOD_CLASS, 5, 0 },
	{ TIN_WHISTLE, 0, TOOL_CLASS, 1, 0 },
	{ MIRROR, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Courier[] = {
	{ PISTOL, 0, WEAPON_CLASS, 1, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 20, 0 },
	{ KNIFE, 0, WEAPON_CLASS, 1, 0 },
	{ POT_JOLT_COLA, 0, POTION_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Spacewars_Fighter[] = {
	{ DAGGER, 0, WEAPON_CLASS, 1, 0 },
	{ SACK, 0, TOOL_CLASS, 1, 0 }, /* since there is no "small pack" in NetHack --Amy */
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Camperstriker[] = {
	{ DAGGER, -1, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, -2, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj CellarChild[] = {
	{ QUARTERSTAFF, 3, WEAPON_CLASS, 1, 0 },
	{ MAGE_PLATE_MAIL, -3, WEAPON_CLASS, 1, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 3, 0 },
	{ SPE_FROST, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_WATER_FLAME, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_JUMPING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 2, 0 },
	{ RIN_COLD_RESISTANCE, 0, RING_CLASS, 1, 0 },
	{ FROST_HORN, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ CHARGER, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ WAN_IDENTIFY, 5, WAND_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Demagogue[] = {
	{ MALLET, 0, WEAPON_CLASS, 1, 0 },
	{ PLATE_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ TIN_WHISTLE, 0, TOOL_CLASS, 1, 0 },
	{ BUGLE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Walscholar[] = {
	{ DIAMOND, UNDEF_SPE, GEM_CLASS, 10, 0 },
	{ DAGGER, 0, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SocialJusticeWarrior[] = {
	{ FLY_SWATTER, 0, WEAPON_CLASS, 1, 0 },
	{ FEDORA, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Singslave[] = {
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Grenadonin[] = {
	{ ORCISH_SHORT_SWORD, 2, WEAPON_CLASS, 1, 0 },
	{ SHURIKEN, 3, WEAPON_CLASS, 40, 0 },
	{ FRAG_GRENADE, 0, WEAPON_CLASS, 20, 0 },
	{ ORCISH_RING_MAIL, 6, ARMOR_CLASS, 1, 0 },
	{ LEATHER_CLOAK, -4, ARMOR_CLASS, 1, 0 },
	{ FEDORA, -1, ARMOR_CLASS, 1, 0 },
	{ DRAGON_EYEPATCH, 0, TOOL_CLASS, 1, 0 },
	{ REGULAR_GLOVES, -6, ARMOR_CLASS, 1, 0 },
	{ AMULET_OF_QUICK_ATTACK, 0, AMULET_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Rocker[] = {
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ ROCK, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ FLINT, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ SLING, 2, WEAPON_CLASS, 1, 1 },
	{ WOODEN_HARP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ PICK_AXE, 1, TOOL_CLASS, 1, 1 },
	{ SPE_MAGIC_BOLT, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Zyborg[] = {
	{ PLATE_MAIL, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ GREEN_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DIODE, UNDEF_SPE, TOOL_CLASS, 20, UNDEF_BLESS },
	{ WAN_SOLAR_BEAM, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Lunatic[] = {
	{ HELM_OF_STEEL, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ GAUNTLETS_OF_STEEL, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STEEL_SHIELD, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ KICKING_BOOTS, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STEEL_WHIP, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ TRIPE_RATION, 0, FOOD_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Drunk[] = {
	{ RUBBER_HOSE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },    /* quan is variable */
	{ POT_BOOZE, UNDEF_SPE, POTION_CLASS, 5, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 5, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 5, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 5, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Officer[] = {
	{ PISTOL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ CLUB, 0, WEAPON_SYM, 1, UNDEF_BLESS },
	{ LEATHER_ARMOR, 0, ARMOR_SYM, 1, UNDEF_BLESS },
	{ WAN_MAGIC_MISSILE, UNDEF_SPE, WAND_SYM, 1, UNDEF_BLESS },
	{ WAN_STRIKING, UNDEF_SPE, WAND_SYM, 1, UNDEF_BLESS },
	{ HACKER_S_FOOD, 0, FOOD_SYM, 6, 0 },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Musician[] = {
	{ FEDORA, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ HAWAIIAN_SHIRT, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ MAGIC_FLUTE, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ MAGIC_HARP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ DRUM_OF_EARTHQUAKE, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ FROST_HORN, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ FIRE_HORN, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Undertaker[] = {
	{ SCALPEL, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHOVEL, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ VICTORIAN_UNDERWEAR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ WAN_UNDEAD_TURNING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ WAN_UNDEAD_TURNING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ TINNING_KIT, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Climacterial[] = {
	{ SCR_CURE, 0, SCROLL_CLASS, 5, 0 },
	{ TOILET_ROLL, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Womanizer[] = {
#define WOMGEM          4
	{ ROSE_WHIP, 0, WEAPON_CLASS, 1, 0 },
	{ KYRT_SHIRT, -3, ARMOR_CLASS, 1, 0 },
	{ ELVIS_SHOES, 3, ARMOR_CLASS, 1, 0 },
	{ RIN_ADORNMENT, 5, RING_CLASS, 1, 0 },
	{ YVONNE_S_JEWEL, UNDEF_SPE, GEM_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Zookeeper[] = {
	{ BULLWHIP, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ TRIPE_RATION, 0, TOOL_CLASS, 5, UNDEF_BLESS },
	{ SCR_TAMING, UNDEF_SPE, SCROLL_CLASS, 3, 1 },
	{ LEATHER_LEASH, 0, TOOL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj Firefighter[] = {
	{ AXE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ FIRE_BRIGADE_HEELS, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_WATER, 0, POTION_CLASS, 5, 0 },
	{ SCR_FIRE, UNDEF_SPE, SCROLL_CLASS, 4, UNDEF_BLESS },
	{ WAN_FIRE, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Locksmith[] = {
	{ WAN_OPENING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ WAN_LOCKING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ SKELETON_KEY, 0, TOOL_CLASS, 1, 0 },
	{ LOCK_PICK, 9, TOOL_CLASS, 1, 0 },
	{ SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Ninja[] = {
	{ SHORT_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS },      /* the wakizashi */
	{ SHURIKEN, 0, WEAPON_CLASS, 9, UNDEF_BLESS },        /* quan is variable */
	{ POT_SICKNESS, 0, POTION_CLASS, 1, 0 },
	{ POT_INVISIBILITY, UNDEF_SPE, POTION_CLASS, 1, 1 },
	{ LOCK_PICK, 9, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj Gangster[] = {
	{ SUBMACHINE_GUN, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SMG_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ SMG_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ LEATHER_JACKET, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Gunner[] = {
	{ ASSAULT_RIFLE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SNIPER_RIFLE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SNIPER_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ ASSAULT_RIFLE_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ ASSAULT_RIFLE_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ LEATHER_JACKET, 0, ARMOR_CLASS, 1, 0 },
	{ MEDICAL_KIT, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj DoomMarine[] = {
	{ PISTOL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, 0 },
	{ IRON_SHOES, 0, ARMOR_CLASS, 1, 0 },
	{ COMMANDER_SUIT, 0, ARMOR_CLASS, 1, 0 },
	{ HELM_OF_UNDERWATER_ACTION, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Death_Eater[] = {
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },
	{ SHOTGUN, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHOTGUN_SHELL, 0, WEAPON_CLASS, 10, 0 },
	{ CLOAK_OF_REFLECTION, 1, ARMOR_CLASS, 1, 0 },
	{ SPE_FINGER_OF_DEATH, UNDEF_SPE, SPBOOK_CLASS, 1, 1},
	{ SPE_CHARM_MONSTER, UNDEF_SPE, SPBOOK_CLASS, 1, 1},
	{ SPE_ACID_STREAM, UNDEF_SPE, SPBOOK_CLASS, 1, 1},
	{ WAN_DEATH, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ AMULET_OF_LIFE_SAVING, UNDEF_SPE, AMULET_CLASS, 1, 0 },
	{ TIN, UNDEF_SPE, FOOD_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Pokemon[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 5, 0 },
	{ WAN_ENLIGHTENMENT, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};


static struct trobj Geek[] = {
	{ ELECTRIC_SWORD, 1, WEAPON_CLASS, 1, 1},
#define G_IC 1
	{ IC, 0, TOOL_CLASS, 7, UNDEF_BLESS },	/* quan is var. */
	{ GAUNTLETS_OF_TYPING, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_JOLT_COLA, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ HACKER_S_FOOD, 0, FOOD_CLASS, 2, UNDEF_BLESS },
	{ PACK_OF_FLOPPIES, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Graduate[] = {
	{ SPOON, 3, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ CANDY_BAR, 0, FOOD_CLASS, 5, 0 },
	{ EXPENSIVE_CAMERA, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Scientist[] = {
	{ SCALPEL, 1, WEAPON_CLASS, 1, 1},
	{ GAUNTLETS_OF_FUMBLING, 5, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LAB_COAT, 5, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_RADIUM, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ POT_CYANIDE, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ POT_PARALYSIS, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ POT_ACID, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ POT_SICKNESS, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ BOTTLE, 0, TOOL_CLASS, 3, 0 },
	{ HACKER_S_FOOD, 0, FOOD_CLASS, 2, UNDEF_BLESS },
	{ SPE_CHEMISTRY, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ CHEMISTRY_SET, 40, TOOL_CLASS, 1, 0 },
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Cartomancer[] = {
	{ HAWAIIAN_SHIRT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHURIKEN, 0, GEM_CLASS, 15, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 4, UNDEF_BLESS },
	{ SCR_CREATE_MONSTER, 0, SCROLL_CLASS, 3, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Dragonmaster[] = {
	{ BROADSWORD, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SCALE_MAIL, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ TRIPE_RATION, 0, FOOD_CLASS, 2, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Combatant[] = {
	{ RING_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, RING_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, SCROLL_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, POTION_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Fjorde[] = {
	{ FISHING_POLE, 2, TOOL_CLASS, 1, 0 },
	{ GRAPPLING_HOOK, 2, TOOL_CLASS, 1, 0 },
	{ CONDOME, 0, TOOL_CLASS, 1, 0 },
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, 0 },
	{ POT_WATER, 0, POTION_CLASS, 2, 0 },
	{ UNDEF_TYP, 0, POTION_CLASS, 2, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Practicant[] = {
	{ STEEL_CAPPED_SANDAL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ BLACK_DRESS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ MAID_DRESS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LADY_BOOTS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, 0, POTION_CLASS, 5, 0 },
	{ BOTTLE, 0, TOOL_CLASS, 3, 0 },
	{ CHEMISTRY_SET, 5, TOOL_CLASS, 1, 0 },
	{ SPE_CHEMISTRY, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	/* should start with rn1(50,50) zorkmids */

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Emera[] = {
#define EMERA_FLINT		1 /* 50 + d50 ammo */
	{ SLING, 5, WEAPON_CLASS, 1, 0 },
	{ FLINT, 0, WEAPON_CLASS, 50, 0 },
	{ RAZOR_WHIP, 0, WEAPON_CLASS, 1, 0 },
	{ FUTON_SWATTER, 0, WEAPON_CLASS, 1, 0 },
	{ BUNNY_UNIFORM, 0, ARMOR_CLASS, 1, 0 },
	{ RIN_INCREASE_DAMAGE, 1, RING_CLASS, 1, 0 },
	{ LEATHER_LEASH, 0, TOOL_CLASS, 1, 0 },
	{ SPE_LINE_LOSS, 2, SPBOOK_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Tosser[] = {
	{ JAVELIN, 5, WEAPON_CLASS, 1, 1 },
	{ JAVELIN, 0, WEAPON_CLASS, 20, 0 },
	{ STACK_JAVELIN, 0, WEAPON_CLASS, 5, 0 },
	{ ASBESTOS_JAVELIN, 0, WEAPON_CLASS, 3, 0 },
	{ SPIRIT_THROWER, 1, WEAPON_CLASS, 1, 0 },
	{ COURSE_JAVELIN, 1, WEAPON_CLASS, 1, 0 },
	{ WAR_HAMMER, 0, WEAPON_CLASS, 1, 0 },
	{ KNIFE, 0, WEAPON_CLASS, 1, 0 },
	{ CLUB, 0, WEAPON_CLASS, 1, 0 },
	{ RING_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ LOW_BOOTS, 0, ARMOR_CLASS, 1, 0 },
	{ PAPER_SHIELD, -1, ARMOR_CLASS, 1, 0 },
	{ LEATHER_CLOAK, 0, ARMOR_CLASS, 1, 0 },
	{ WAN_STUN_MONSTER, UNDEF_SPE, WAND_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Aklyst[] = {
	{ AKLYS, 5, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 4, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 3, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 2, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 1, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 0, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 0, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 0, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 0, WEAPON_CLASS, 1, 1 },
	{ AKLYS, 0, WEAPON_CLASS, 1, 1 },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, 1 },
	{ ELVEN_HELM, 0, ARMOR_CLASS, 1, 1 },
	{ LEATHER_SHOES, 0, ARMOR_CLASS, 1, 1 },
	{ WAX_CANDLE, 0, TOOL_CLASS, 2, 1 },
	{ TALLOW_CANDLE, 0, TOOL_CLASS, 2, 1 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj MillSwallower[] = {
#define MS_BOLTS		3 /* 20 + d40 ammo */
	{ AXE, 1, WEAPON_CLASS, 1, 0 },
	{ WAR_HAMMER, 0, WEAPON_CLASS, 1, 0 },
	{ CROSSBOW, 0, WEAPON_CLASS, 1, 0 },
	{ CROSSBOW_BOLT, 0, WEAPON_CLASS, 20, 0 },
	{ CHAIN_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ DWARVISH_IRON_HELM, 0, ARMOR_CLASS, 1, 0 },
	{ ROCKET_GAUNTLETS, 0, ARMOR_CLASS, 1, 0 },
	{ BINNING_KIT, UNDEF_SPE, TOOL_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Symbiant[] = {
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SYMBIOTE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ MACE, 0, WEAPON_CLASS, 1, 0 },
	{ LIZARD_SCALES, 0, ARMOR_CLASS, 1, 0 },
	{ DRAGON_HORNED_HEADPIECE, 0, ARMOR_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 2, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Genderstarist[] = {
	{ AMULET_OF_CHANGE, 0, AMULET_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj ButtLover[] = {
	{ MACE, 0, WEAPON_CLASS, 1, 0 },
	{ T_SHIRT, 0, ARMOR_CLASS, 1, 0 },
	{ HAWAIIAN_SHORTS, 0, ARMOR_CLASS, 1, 0 },
	{ SNEAKERS, 0, ARMOR_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Dancer[] = {
	{ SCIMITAR, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ MELON, 0, FOOD_CLASS, 1, 0 },
	{ LEMON, 0, FOOD_CLASS, 1, 0 },
	{ APPLE, 0, FOOD_CLASS, 1, 0 },
	{ ORANGE, 0, FOOD_CLASS, 1, 0 },
	{ PEAR, 0, FOOD_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Diablist[] = {
	{ QATAR, 1, WEAPON_CLASS, 1, 0 },
	{ EAGLE_BALL, 1, WEAPON_CLASS, 1, 0 },
	{ GRINDER, 1, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ SCR_IDENTIFY, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 3, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Preversioner[] = {
	{ DAGGER, 0, WEAPON_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj SecretAdviceMember[] = {
	{ HUGGING_BOOT, 0, WEAPON_CLASS, 1, 0 },
	{ WAN_BANISHMENT, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ SOFT_SNEAKERS, 0, ARMOR_CLASS, 1, 0 },
	{ T_SHIRT, 0, ARMOR_CLASS, 1, 0 },
	{ HAWAIIAN_SHORTS, 0, ARMOR_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj ShoeFetishist[] = {
	{ HIGH_BOOTS, 0, ARMOR_CLASS, 1, 0 },
	{ T_SHIRT, 0, ARMOR_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Healer[] = {
	{ SCALPEL, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STETHOSCOPE, 0, TOOL_CLASS, 1, 0 },
	{ MEDICAL_KIT, 0, TOOL_CLASS, 1, 0 },        
	{ POT_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ POT_EXTRA_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ WAN_SLEEP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	/* [Tom] they might as well have a wand of healing, too */        
	{ WAN_HEALING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	/* always blessed, so it's guaranteed readable */
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_STONE_TO_FLESH, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Ice_Mage[] = {
#define I_BOOK          9
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },        /* for dealing with ghosts */
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ WAN_COLD, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_FREEZE_SPHERE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_CONE_OF_COLD, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Jedi[] = {
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj ShadowJedi[] = {
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ BLACK_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj GreenSaber[] = {
	{ GREEN_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj BlueSaber[] = {
	{ BLUE_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj MysterySaber[] = {
	{ MYSTERY_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj RedSaber[] = {
	{ RED_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj WhiteSaber[] = {
	{ WHITE_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj YellowSaber[] = {
	{ YELLOW_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj VioletSaber[] = {
	{ VIOLET_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj RedDoubleSaber[] = {
	{ RED_DOUBLE_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj WhiteDoubleSaber[] = {
	{ WHITE_DOUBLE_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};
static struct trobj BorgItems[] = {
	{ RED_LIGHTSABER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0, }
};

static struct trobj PeacemakerItems[] = {
	{ VICTORIAN_UNDERWEAR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FLY_SWATTER, 1, WEAPON_CLASS, 1, 1 },
	{ SPE_CHARM_MONSTER, UNDEF_SPE, SPBOOK_CLASS, 1, 1},
	{ EXPENSIVE_CAMERA, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Knight[] = {
	{ LONG_SWORD, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LANCE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PLATE_MAIL, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STANDARD_HELMET, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LARGE_SHIELD, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ CARROT, 0, FOOD_CLASS, 10, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Wandkeeper[] = {
	{ KNIFE, 1, WEAPON_CLASS, 1, 0 },
	{ LAB_COAT, 1, ARMOR_CLASS, 1, 1 },
	{ SCR_CHARGING, 0, SCROLL_CLASS, 1, 1 },
	{ SPE_POLYMORPH, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ WAN_MAGIC_MISSILE, 16, WAND_CLASS, 2, 1 },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 5, 1 },
	{ SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Paladin[] = {
	{ LONG_SWORD, 3, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LARGE_SHIELD, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STANDARD_HELMET, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ STUDDED_LEATHER_ARMOR, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LOW_BOOTS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 4, UNDEF_BLESS },
	{ RIN_WARNING, 0, RING_CLASS, 1, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj FoxhoundAgent[] = {
	{ FEDORA, 0, ARMOR_CLASS, 1, 1 },
	{ KICKING_BOOTS, 0, ARMOR_CLASS, 1, 0 },
	{ ELVEN_CLOAK, 2, ARMOR_CLASS, 1, 1 },
	{ REGULAR_GLOVES, 1, ARMOR_CLASS, 1, 0 },
	{ LEMBAS_WAFER, 0, FOOD_CLASS, 2, UNDEF_BLESS },
	{ K_RATION, 0, FOOD_CLASS, 3, UNDEF_BLESS },
	{ ASIAN_PEAR, 0, FOOD_CLASS, 10, 0 },
	{ KNIFE, 2, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj StuntMaster[] = {
	{ FLAIL, 1, WEAPON_CLASS, 1, 0 },
	{ ORCISH_HELM, 0, ARMOR_CLASS, 1, 0 },
	{ LEATHER_JACKET, 2, ARMOR_CLASS, 1, 0 },
	{ CANDY_BAR, 0, FOOD_CLASS, 5, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 2, 0 },
	{ EXPENSIVE_CAMERA, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Warrior[] = {
	{ MACE, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ CROSSBOW, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ CROSSBOW_BOLT, 0, WEAPON_CLASS, 50, 1 },
	{ LARGE_SHIELD, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 15, 0 },
	{ CARROT, 0, FOOD_CLASS, 15, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj MahouShoujo[] = {

	{ UNDEF_TYP, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, 0, ARMOR_CLASS, 1, 0 },
	{ WAN_STRIKING, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 3, 0 },
	{ TIN, UNDEF_SPE, FOOD_CLASS, 3, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj DollMistress[] = {
	{ WORM_TOOTH, 1, WEAPON_CLASS, 1, 0 },
	{ DWARVISH_CLOAK, 2, ARMOR_CLASS, 1, 0 },
	{ VICTORIAN_UNDERWEAR, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 12, 0 },
	{ CRAM_RATION, 0, FOOD_CLASS, 2, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 2, 0 },
	{ UNDEF_TYP, 0, POTION_CLASS, 1, 0 },
	{ WAX_CANDLE, 0, TOOL_CLASS, 7, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Monk[] = {
#define M_BOOK		2
	{ REGULAR_GLOVES, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ POT_HEALING, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 3, 0 },
	{ APPLE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	{ ORANGE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	/* Yes, we know fortune cookies aren't really from China.  They were
	 * invented by George Jung in Los Angeles, California, USA in 1916.
	 */
	{ FORTUNE_COOKIE, 0, FOOD_CLASS, 3, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HalfBaked[] = {
#define HBA_BOOK		1
	{ REGULAR_GLOVES, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ POT_HEALING, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 3, 0 },
	{ APPLE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	{ ORANGE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	/* Yes, we know fortune cookies aren't really from China.  They were
	 * invented by George Jung in Los Angeles, California, USA in 1916.
	 */
	{ FORTUNE_COOKIE, 0, FOOD_CLASS, 3, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Saiyan[] = {
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Psion[] = {
#define PS_BOOK		2
	{ REGULAR_GLOVES, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ ROBE, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ POT_MONSTER_DETECTION, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 3, 0 },
	{ APPLE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	{ ORANGE, 0, FOOD_CLASS, 5, UNDEF_BLESS },
	/* Yes, we know fortune cookies aren't really from China.  They were
	 * invented by George Jung in Los Angeles, California, USA in 1916.
	 */
	{ FORTUNE_COOKIE, 0, FOOD_CLASS, 3, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Noble[] = {
#define NOB_SHIRT	1
	{ RAPIER, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ RUFFLED_SHIRT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_CLOAK, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ FOOD_RATION, 0, FOOD_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Pirate[] = {
#define PIR_KNIVES	1
#define PIR_SNACK 8
#define PIR_JEWELRY 10
#define PIR_TOOL 11
	{ SCIMITAR, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ KNIFE, 1, WEAPON_CLASS, 2, 0 },
	{ PARRY_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ LEATHER_JACKET, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ HIGH_BOOTS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 2, UNDEF_BLESS },
	{ BANANA, 0, FOOD_CLASS, 3, 0 },
	{ POT_BOOZE, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ OILSKIN_SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Korsair[] = {
	{ SCIMITAR, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DAGGER, 1, WEAPON_CLASS, 7, 0 },
	{ PARRY_DAGGER, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ AMULET_OF_MAGICAL_BREATHING, 0, AMULET_CLASS, 1, 0 },
	{ OILSKIN_SACK, 0, TOOL_CLASS, 1, 0 },
	{ POT_BOOZE, 0, POTION_CLASS, 2, UNDEF_BLESS },
	{ TIN, 0, FOOD_CLASS, 1, 0 },
	{ CRAM_RATION, 0, FOOD_CLASS, 1, 1 },
	{ FIGURINE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Gladiator[] = {
	{ SILVER_SPEAR, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHIELD_OF_REFLECTION, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Altmer[] = {
	{ QUARTERSTAFF, 2, WEAPON_CLASS, 1, 1 },
	{ ROBE, 2, ARMOR_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 2, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Bosmer[] = {
	{ ELVEN_DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ELVEN_BOW, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ELVEN_ARROW, 4, WEAPON_CLASS, 50, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Dunmer[] = {
	{ DARK_ELVEN_DAGGER, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_BOW, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_ARROW, 0, WEAPON_CLASS, 50, 0 },
	{ DARK_ELVEN_ARROW, 0, WEAPON_CLASS, 50, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Ordinator[] = {
	{ TSURUGI, 3, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ RUNESWORD, 3, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ MALLET, 4, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DROVEN_CROSSBOW, 3, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DROVEN_BOLT, 8, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ RIN_INCREASE_ACCURACY, 5, RING_CLASS, 1, UNDEF_BLESS },
	{ SPE_ENCHANT_WEAPON, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Thalmor[] = {
	{ ELVEN_BROADSWORD, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ELVEN_MITHRIL_COAT, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_BOW, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_ARROW, UNDEF_SPE, WEAPON_CLASS, 50, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Amazon[] = {
	{ JAVELIN, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ BOW, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ARROW, 0, WEAPON_CLASS, 50, 1 },
	{ ARROW, 0, WEAPON_CLASS, 50, 1 },
	{ SHIELD_OF_MOBILITY, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_ARMOR, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 2, 1 },
	{ POT_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Druid[] = {
	{ CLUB, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ BOW, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ARROW, UNDEF_SPE, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ SPE_CREATE_FAMILIAR, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ SPE_CHARM_MONSTER, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Goff[] = {
	{ PISTOL, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ HIPPIE_HEELS, 5, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ VICTORIAN_UNDERWEAR, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ BLACK_DRAGON_SCALE_MAIL, -9, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_ACID, 0, POTION_CLASS, 3, UNDEF_BLESS },
	{ POT_VAMPIRE_BLOOD, 0, POTION_CLASS, 5, UNDEF_BLESS },
	{ POT_BLOOD, 0, POTION_CLASS, 5, UNDEF_BLESS },
	{ AMULET_OF_COVETOUS_WARNING, 0, AMULET_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Diver[] = {
	{ KNIFE, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SPEAR, 0, WEAPON_CLASS, 3, UNDEF_BLESS },
	{ TRIDENT, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ OILSKIN_CLOAK, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CAN_OF_GREASE, UNDEF_SPE, TOOL_CLASS, 1, 1 },
	{ TALLOW_CANDLE, 0, TOOL_CLASS, 3, 1 },
	{ AMULET_OF_MAGICAL_BREATHING, 0, AMULET_CLASS, 1, 0 },
	{ TOWEL, 0, TOOL_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Necromancer[] = {
#define N_BOOK          8
/* pretty much like Wizard, except with pick-axe instead of magic resist. */
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },        /* for dealing with ghosts */
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 3, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 3, UNDEF_BLESS },
	{ SPE_SUMMON_UNDEAD, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_COMMAND_UNDEAD, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_DRAIN_LIFE, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
		/* WAC -- gave him drain life rather than turn undead */
	{ WAN_DRAINING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
		/* KMH -- ...and the matching wand for the inexperienced */
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ PICK_AXE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Chevalier[] = {
	{ TRIDENT, 0, WEAPON_CLASS, 1, 1 },
	{ ROBE, 0, ARMOR_CLASS, 1, 1 },
	{ SMALL_SHIELD, 2, ARMOR_CLASS, 1, 1 },
	{ POT_WATER, 0, POTION_CLASS, 2, 1 },	/* holy water */
	{ CLOVE_OF_GARLIC, 0, FOOD_CLASS, 1, 1 },
	{ SPRIG_OF_WOLFSBANE, 0, FOOD_CLASS, 1, 1 },
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 1 },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Priest[] = {
#define P_BOOK          7
	{ MACE, 0, WEAPON_CLASS, 1, 1 },
	{ ROBE, 0, ARMOR_CLASS, 1, 1 },
	{ SMALL_SHIELD, 2, ARMOR_CLASS, 1, 1 },
	{ POT_WATER, 0, POTION_CLASS, 4, 1 },	/* holy water */
	{ CLOVE_OF_GARLIC, 0, FOOD_CLASS, 1, 1 },
	{ SPRIG_OF_WOLFSBANE, 0, FOOD_CLASS, 1, 1 },
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Ranger[] = {
#define RAN_BOW			1
#define RAN_TWO_ARROWS	2
#define RAN_ZERO_ARROWS	3
	{ DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ BOW, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ARROW, 2, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ ARROW, 0, WEAPON_CLASS, 30, UNDEF_BLESS },
	{ CLOAK_OF_DISPLACEMENT, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 4, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Elph[] = {
#define ELP_BOW			1
#define ELP_TWO_ARROWS	2
#define ELP_ZERO_ARROWS	3
	{ DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ELVEN_BOW, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ ELVEN_ARROW, 2, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ ELVEN_ARROW, 0, WEAPON_CLASS, 30, UNDEF_BLESS },
	{ CLOAK_OF_DISPLACEMENT, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 4, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Twelph[] = {
#define TWELP_BOW			1
#define TWELP_TWO_ARROWS	2
#define TWELP_ZERO_ARROWS	3
	{ DARK_ELVEN_DAGGER, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_BOW, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DARK_ELVEN_ARROW, 2, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ DARK_ELVEN_ARROW, 0, WEAPON_CLASS, 30, UNDEF_BLESS },
	{ CLOAK_OF_DISPLACEMENT, 2, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CRAM_RATION, 0, FOOD_CLASS, 4, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Assassin[] = {

	{ BOW, 1, WEAPON_CLASS, 1, 0 },
	{ ARROW, 2, WEAPON_CLASS, 50, 0 },
	{ DAGGER, 1, WEAPON_CLASS, 2, 0 },
	{ LEATHER_ARMOR, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_CLOAK, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 4, 0 },
	{ POT_PARALYSIS, 0, POTION_CLASS, 1, 0 },
	{ POT_SLEEPING, 0, POTION_CLASS, 1, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Bully[] = {

	{ CLUB, 0, WEAPON_CLASS, 1, 0 },
	{ KNIFE, 0, WEAPON_CLASS, 1, 0 },
	{ DUNCE_CAP, 3, ARMOR_CLASS, 1, 0 },
	{ T_SHIRT, 3, ARMOR_CLASS, 1, 0 },
	{ CANDY_BAR, 0, FOOD_CLASS, 10, 0 },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Pickpocket[] = {

	{ DAGGER, 0, WEAPON_CLASS, 10, 0 },
	{ KNIFE, 0, WEAPON_CLASS, 2, 0 },
	{ LOCK_PICK, 0, TOOL_CLASS, 1, 0 },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CLOAK_OF_DISPLACEMENT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },

	{ 0, 0, 0, 0, 0 }
};

static struct trobj Rogue[] = {
#define R_DAGGERS	1
#define R_DARTS         2
	{ SHORT_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DAGGER, 0, WEAPON_CLASS, 10, 0 },	/* quan is variable */
	{ DART, 0, WEAPON_CLASS, 25, UNDEF_BLESS },
	{ LEATHER_ARMOR, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ POT_SICKNESS, 0, POTION_CLASS, 1, 0 },
	{ SCR_GOLD_DETECTION, 0, SCROLL_CLASS, 4, 1 },
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 4, 1 },
	{ LOCK_PICK, 9, TOOL_CLASS, 1, 0 },
	{ OILSKIN_SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Samurai[] = {
#define S_ARROWS	3
	{ KATANA, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SHORT_SWORD, 0, WEAPON_CLASS, 1, UNDEF_BLESS }, /* wakizashi */
	{ YUMI, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ YA, 0, WEAPON_CLASS, 25, UNDEF_BLESS }, /* variable quan */
	{ SPLINT_MAIL, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Transvestite[] = {
	{ WEDGED_LITTLE_GIRL_SANDAL, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ WEDGE_SANDALS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Prostitute[] = {
	{ INKA_SHACKLE, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ KNIFE, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PISTOL_BULLET, UNDEF_SPE, WEAPON_CLASS, 50, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Kurwa[] = {
	{ COLLUSION_KNIFE, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ EVIL_DRAGON_SCALE_MAIL, -25, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ EERIE_CLOAK, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ MOMHAT, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ SCALER_MITTENS, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ EVIL_DRAGON_SCALE_SHIELD, -11, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ RED_SPELL_HEELS, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ SCR_DESTROY_ARMOR, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_TAMING, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_TRAP_DETECTION, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_BOSS_COMPANION, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_RELOCATION, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SCR_REPAIR_ITEM, 0, SCROLL_CLASS, 5, UNDEF_BLESS },
	{ FLEECE_STONE, 10, GEM_CLASS, 1, 0 },
	{ SPEEDBUG_STONE, 10, GEM_CLASS, 1, 0 },
	{ COVETOUS_STONE, 10, GEM_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Transsylvanian[] = {
	{ BLOCK_HEELED_COMBAT_BOOT, 5, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ HIPPIE_HEELS, 10, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SoftwareEngineer[] = {
	{ FLINTLOCK, 0, WEAPON_CLASS, 1, 0 },
	{ HEALER_UNIFORM, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ POT_COFFEE, 0, POTION_CLASS, 1, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ HAIRCLIP, 0, TOOL_CLASS, 1, 0 },
	{ CHARGER, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Cracker[] = {
	{ FLINTLOCK, 0, WEAPON_CLASS, 1, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ HEALER_UNIFORM, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ POT_COFFEE, 0, POTION_CLASS, 1, 0 },
	{ HAIRCLIP, 0, TOOL_CLASS, 1, 0 },
	{ CHARGER, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Janitor[] = {
	{ MOP, 1, WEAPON_CLASS, 1, 0 },
	{ BUNNY_UNIFORM, 0, ARMOR_CLASS, 1, 0 },
	{ IRON_SHOES, 0, ARMOR_CLASS, 1, 0 },
	{ POT_OIL, 0, POTION_CLASS, 1, 0 },
	{ PICK_AXE, 0, TOOL_CLASS, 1, 0 },
	{ SKELETON_KEY, 0, TOOL_CLASS, 1, 0 },
	{ HAIRCLIP, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SpaceMarine[] = {
	{ PISTOL, 0, WEAPON_CLASS, 1, 0 },
	{ HAND_BLASTER, 0, WEAPON_CLASS, 1, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ TORCH, 0, TOOL_CLASS, 5, 0 },
	{ POT_MONSTER_DETECTION, 0, POTION_CLASS, 1, 1 },
	{ JUMPSUIT, 1, ARMOR_CLASS, 1, 0 },
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Stormboy[] = {
	{ SNIPER_RIFLE, 0, WEAPON_CLASS, 1, 0 },
	{ SNIPER_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ FRAG_GRENADE, 0, WEAPON_CLASS, 20, 0 },
	{ JUMPSUIT, 0, ARMOR_CLASS, 1, 0 },
	{ HELM_OF_WARNING, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Jockey[] = {
	{ BULLWHIP, 2, WEAPON_CLASS, 1, 0 },
	{ LEATHER_JACKET, 2, ARMOR_CLASS, 1, 0 },
	{ FEDORA, 0, ARMOR_CLASS, 1, 0 },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, 0 },
	{ POT_BOOZE, 0, POTION_CLASS, 1, 0 },
	{ APPLE, 0, FOOD_CLASS, 15, 0 },
	{ CARROT, 0, FOOD_CLASS, 15, 0 },
	{ SHEAF_OF_STRAW, 0, FOOD_CLASS, 5, 0 },
	{ COTTON, 0, FOOD_CLASS, 10, 0 },
	{ TORTILLA, 0, FOOD_CLASS, 3, 0 },
	{ FOOD_RATION, 0, FOOD_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Yautja[] = {
	{ ARM_BLASTER, 0, WEAPON_CLASS, 1, 0 },
	{ HEAVY_BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ HEAVY_BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ SPEAR, 0, WEAPON_CLASS, 5, 0 },
	{ BOOMERANG, 0, WEAPON_CLASS, 1, 0 },
	{ SCIMITAR, 1, WEAPON_CLASS, 1, 0 },
	{ RAZOR_WHIP, 0, WEAPON_CLASS, 1, 0 },
	{ NATURAL_STICK, 0, WEAPON_CLASS, 1, 0 },
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 1, 0 },
	{ PLATE_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ LEATHER_CLOAK, 0, ARMOR_CLASS, 1, 0 },
	{ ANTENNA, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Quarterback[] = {
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, 0 },
	{ STANDARD_HELMET, 0, ARMOR_CLASS, 1, 0 },
	{ BASEBALL_BAT, 2, WEAPON_CLASS, 1, 1 },
	{ PISTOL_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ POT_BOOZE, 0, POTION_CLASS, 6, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Psyker[] = {
	{ SPE_PSYBEAM, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_CURE_BLINDNESS, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_EXTRA_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_JUMPING, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ HAND_BLASTER, 1, WEAPON_CLASS, 1, 0 },
	{ BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ HEALER_UNIFORM, 1, ARMOR_CLASS, 1, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 1, 0 },
	{ POT_CURE_INSANITY, 0, POTION_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Empath[] = {
	{ SPE_RADAR, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_HASTE_SELF, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_DIRECTIVE, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ ELVEN_DAGGER, 2, WEAPON_CLASS, 1, 0 },
	{ ELVEN_TOGA, 0, ARMOR_CLASS, 1, 0 },
	{ POT_JOLT_COLA, 0, POTION_CLASS, 2, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 2, 0 },
	{ POT_CURE_INSANITY, 0, POTION_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Mastermind[] = {
	{ SPE_HORRIFY, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_AULE_SMITHING, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_ESP, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ STETHOSCOPE, 0, TOOL_CLASS, 1, 0 },
	{ SILK_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ WAN_MANA, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ RAYGUN, 1, WEAPON_CLASS, 1, 0 },
	{ RAYGUN_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ RAYGUN_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ RAYGUN_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ POT_FULL_HEALING, 0, POTION_CLASS, 1, 0 },
	{ POT_CURE_INSANITY, 0, POTION_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Weirdboy[] = {
	{ SPE_INDUCE_VOMITING, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_ENCHANT_WEAPON, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_ENCHANT_ARMOR, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_INERTIA_CONTROL, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ SPE_SPELLBINDER, UNDEF_SPE, SPBOOK_CLASS, 1, 0 },
	{ HELM_OF_WARNING, 0, ARMOR_CLASS, 1, 0 },
	{ BRONZE_MORNING_STAR, 1, WEAPON_CLASS, 1, 0 },
	{ HEALER_UNIFORM, 0, ARMOR_CLASS, 1, 0 },
	{ POT_JOLT_COLA, 0, POTION_CLASS, 2, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 1, 0 },
	{ POT_CURE_INSANITY, 0, POTION_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Astronaut[] = {
	{ JUMPSUIT, 0, ARMOR_CLASS, 1, 0 },
	{ HELM_OF_DECONTAMINATION, 0, ARMOR_CLASS, 1, 0 },
	{ FLYING_BOOTS, 0, ARMOR_CLASS, 1, 0 },
	{ EVENCORE_CLOAK, -3, ARMOR_CLASS, 1, 0 },
	{ SCR_ANTIMATTER, 0, SCROLL_CLASS, 1, 0 },
	{ POT_HEALING, 0, POTION_CLASS, 1, 0 },
	{ POT_WATER, 0, POTION_CLASS, 1, 0 },
	{ MAGIC_CANDLE, 0, TOOL_CLASS, 1, 0 },
	{ RAD_X, 0, TOOL_CLASS, 1, 0 },
	{ RADAWAY, 0, TOOL_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Cyberninja[] = {
	{ KATANA, 1, WEAPON_CLASS, 0, 0 },
	{ FRAG_GRENADE, 0, WEAPON_CLASS, 4, 0 },
	{ SPECIAL_CAMOUFLAGED_CLOTHES, 1, ARMOR_CLASS, 1, 0 },
	{ LOCK_PICK, 0, TOOL_CLASS, 1, 0 },
	{ BOSS_VISOR, 0, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, IMPLANT_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Dissident[] = {
	{ GREEN_DRAGON_SCALES, 0, ARMOR_CLASS, 1, 0 },
	{ CLOAK_OF_STABILITY, 0, ARMOR_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ SPIKED_CLUB, 1, WEAPON_CLASS, 1, 0 },
	{ GAS_GRENADE, 0, WEAPON_CLASS, 3, 0 },
	{ HAND_BLASTER, 0, WEAPON_CLASS, 1, 0 },
	{ BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ BLASTER_BOLT, 0, WEAPON_CLASS, 50, 0 },
	{ 0, 0, 0, 0, 0 }
};

/* according to PRIME, XelNaga has: No starting mutations. No knowledge at all. No equipment either. */
static struct trobj XelNaga[] = {
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Acu[] = {
#define ACUWEAPON	0
	{ SHORT_SWORD, 1, WEAPON_CLASS, 1, 0 },
	{ LEATHER_ARMOR, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Mason[] = {
	{ WAR_HAMMER, 4, WEAPON_CLASS, 1, 0 },
	{ PICK_AXE, 3, TOOL_CLASS, 1, 0 },
	{ CHAIN_MAIL, 0, ARMOR_CLASS, 1, 0 },
	{ STANDARD_HELMET, 0, ARMOR_CLASS, 1, 0 },
	{ SCR_LOCKOUT, 0, SCROLL_CLASS, 3, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Hussy[] = {
	{ SOFT_GIRL_SNEAKER, 0, WEAPON_CLASS, 1, 0 },
	{ SOFT_SNEAKERS, 0, ARMOR_CLASS, 1, 0 },
	{ SCR_STINKING_CLOUD, 0, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Unbeliever[] = {
	{ BLACK_AESTIVALIS, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ CHAIN_MAIL, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 1, 0 },
	{ SCR_RETURN, 0, SCROLL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Topmodel[] = {
	{ KNIFE, 1, WEAPON_CLASS, 1, 1 },
	{ RIFLE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ RIFLE_BULLET, 0, WEAPON_CLASS, 50, 0 },
	{ LEATHER_PEEP_TOES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_SADDLE, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Failed_Existence[] = {
	{ KNIFE, -6, WEAPON_CLASS, 1, 0 },
	{ RIFLE_BULLET, -4, WEAPON_CLASS, 7, 0 },
	{ SENTIENT_HIGH_HEELED_SHOES, 12, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Activistor[] = {
#define ACT_SHIRT	0
	{ RUFFLED_SHIRT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FLY_SWATTER, 1, WEAPON_CLASS, 1, 1 },
	{ SPE_CHARM_MONSTER, UNDEF_SPE, SPBOOK_CLASS, 1, 1},
	{ EXPENSIVE_CAMERA, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Otaku[] = {
	{ KATANA, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ T_SHIRT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 9, 0 },
	{ UNDEF_TYP, 0, POTION_CLASS, 2, UNDEF_BLESS },
	{ POT_WATER, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, 0, SCROLL_CLASS, 3, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};


static struct trobj Tourist[] = {
#define T_DARTS		0
	{ DART, 2, WEAPON_CLASS, 25, UNDEF_BLESS },	/* quan is variable */
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 12, 0 },
	{ POT_EXTRA_HEALING, 0, POTION_CLASS, 2, UNDEF_BLESS },
	{ SCR_MAGIC_MAPPING, 0, SCROLL_CLASS, 6, UNDEF_BLESS },
	{ HAWAIIAN_SHIRT, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ EXPENSIVE_CAMERA, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ CREDIT_CARD, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj UndeadSlayer[] = {
#define U_MINOR 1       /* silver spear or whip [Castlevania] 25/25% */
                        /* crossbow 50% [Buffy] */
#define U_RANGE 2       /* silver daggers or crossbow bolts */
#define U_MISC  3       /* +1 boots [Buffy can kick] or helmet */
#define U_ARMOR 4       /* Tshirt/leather +1 or chain mail */
	{ WOODEN_STAKE, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SILVER_SPEAR, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SILVER_DAGGER, 0, WEAPON_CLASS, 5, UNDEF_BLESS },
	{ STANDARD_HELMET, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CHAIN_MAIL, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ CLOVE_OF_GARLIC, 0, FOOD_CLASS, 5, 1 },
	{ SPRIG_OF_WOLFSBANE, 0, FOOD_CLASS, 5, 1 },
	{ HOLY_WAFER, 0, FOOD_CLASS, 4, 0 },
	{ POT_WATER, 0, POTION_CLASS, 4, 1 },        /* holy water */
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Valkyrie[] = {
/*        { LONG_SWORD, 1, WEAPON_CLASS, 1, UNDEF_BLESS }, */
	{ SPEAR, 1, WEAPON_CLASS, 1, UNDEF_BLESS }, /* Traditional Weapon - WAC*/
	{ DAGGER, 0, WEAPON_CLASS, 5, UNDEF_BLESS },
	{ SMALL_SHIELD, 3, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj VanillaValk[] = {
	{ LONG_SWORD, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ DAGGER, 0, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ SMALL_SHIELD, 3, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ FOOD_RATION, 0, FOOD_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Wizard[] = {
#define W_MULTSTART	2
#define W_MULTEND	6
#define W_BOOK1         6
#define W_BOOK2         7
#define W_BOOK3         8
#define W_BOOK4         9
	{ QUARTERSTAFF, 1, WEAPON_CLASS, 1, 1 },
	{ CLOAK_OF_MAGIC_RESISTANCE, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 2, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 3, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 3, UNDEF_BLESS },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Sage[] = {

	{ MACE, 1, WEAPON_CLASS, 1, 1 },
	{ ROBE, 2, ARMOR_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 2, UNDEF_BLESS },
	{ SPE_MAGIC_BOLT, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 2, 1 },
	{ POT_HEALING, UNDEF_SPE, POTION_CLASS, 2, 1 },
	{ 0, 0, 0, 0, 0 }
};


static struct trobj Yeoman[] = {
	{ SHORT_SWORD, 2, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ PARTISAN, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ LEATHER_ARMOR, 1, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ HIGH_BOOTS, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ REGULAR_GLOVES, 0, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ CARROT, 0, FOOD_CLASS, 10, 0 },
	{ POT_WATER, 0, POTION_CLASS, 3, 0 },
	{ FISHING_POLE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

/*
 *	Optional extra inventory items.
 */
static struct trobj ErdrickKey[] = {
	{ SKELETON_KEY, 0, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItem[] = {
	{ SCALPEL, 1, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemB[] = {
	{ STETHOSCOPE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemC[] = {
	{ MEDICAL_KIT, 0, TOOL_CLASS, 1, 0 },        
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemD[] = {
	{ POT_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemE[] = {
	{ POT_EXTRA_HEALING, 0, POTION_CLASS, 4, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemF[] = {
	{ WAN_SLEEP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemG[] = {
	{ WAN_HEALING, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemH[] = {
	{ SPE_HEALING, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemI[] = {
	{ SPE_STONE_TO_FLESH, UNDEF_SPE, SPBOOK_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj HerbalistItemJ[] = {
	{ APPLE, 0, FOOD_CLASS, 10, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj CupidItem[] = {
	{ RIN_LEVITATION, 0, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KoronstItem[] = {
	{ CATAPULT, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj GoauldItem[] = {
	{ SYMBIOTE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItem[] = {
	{ SCALPEL, 1, WEAPON_CLASS, 1, 1},
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemB[] = {
	{ GAUNTLETS_OF_FUMBLING, 5, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemC[] = {
	{ LAB_COAT, 5, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemD[] = {
	{ POT_RADIUM, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemE[] = {
	{ POT_CYANIDE, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemF[] = {
	{ POT_PARALYSIS, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemG[] = {
	{ POT_ACID, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemH[] = {
	{ POT_SICKNESS, 0, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemI[] = {
	{ BOTTLE, 0, TOOL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemJ[] = {
	{ SPE_CHEMISTRY, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlchemistItemK[] = {
	{ CHEMISTRY_SET, 40, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RaceXItem[] = {
	{ SPE_LIGHTNING, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SnailItem[] = {
	{ SHOVEL, -5, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UnmagicFishItem[] = {
	{ SPE_MAGIC_MISSILE, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RaceXItemB[] = {
	{ FRAG_GRENADE, UNDEF_SPE, WEAPON_CLASS, 5, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RodneyItem[] = {
	{ UNDEF_TYP, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RodneyItemB[] = {
	{ UNDEF_TYP, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RodneyItemC[] = {
	{ UNDEF_TYP, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RodneyItemD[] = {
	{ UNDEF_TYP, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj RodneyItemE[] = {
	{ UNDEF_TYP, 5, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlienItem[] = {
	{ LOADSTONE, 0, GEM_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KopItemA[] = {
	{ RUBBER_HOSE, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KopItemB[] = {
	{ CREAM_PIE, 0, FOOD_CLASS, 64, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj NaviItem[] = {
	{ WEDGE_SANDALS, 0, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj InsectoidItem[] = {
	{ LUMP_OF_ROYAL_JELLY, 0, FOOD_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TrapperItem[] = {
	{ WAN_TRAP_CREATION, 0, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BloodseekerA[] = {
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SlaveMasterA[] = {
	{ OIL_LAMP, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SlaveMasterB[] = {
	{ SCR_TAMING, 0, SCROLL_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SlaveMasterC[] = {
	{ RIN_CONFLICT, 0, RING_CLASS, 1, 1 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SupermarketA[] = {
	{ OILSKIN_SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SupermarketB[] = {
	{ OIL_LAMP, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LevitatorItem[] = {
	{ BULLWHIP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LevitatorItemB[] = {
	{ BULLWHIP, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LevitatorItemC[] = {
	{ FISHING_POLE, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LevitatorItemD[] = {
	{ GRAPPLING_HOOK, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LevitatorItemE[] = {
	{ UNICORN_HORN, -5, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SwikniItem[] = {
	{ SURVIVAL_KNIFE, 1, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KoboltItem[] = {
	{ DART, 0, WEAPON_CLASS, 15, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KoboltItemB[] = {
	{ ORCISH_DAGGER, 0, WEAPON_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KoboltItemC[] = {
	{ ORCISH_SPEAR, 0, WEAPON_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj GhastFood[] = {
	{ CORPSE, 0, FOOD_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UngMoldWand[] = {
	{ WAN_DEATH, 10, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj MaiaWand[] = {
	{ WAN_TELEPORTATION, 12, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj MaiaScroll[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AutomatonItem[] = {
	{ POT_OIL, 0, POTION_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj StickerItem[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj DeveloperItem[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ AMULET_OF_LIFE_SAVING, UNDEF_SPE, AMULET_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TrollItemA[] = {
	{ RANSEUR, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TrollItemB[] = {
	{ PARTISAN, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TrollItemC[] = {
	{ GLAIVE, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TrollItemD[] = {
	{ SPETUM, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LostSoulItem[] = {
	{ FOOD_RATION, 0, FOOD_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LostSoulItemX[] = {
	{ SCR_IDENTIFY, 0, SCROLL_CLASS, 15, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LostSoulItemY[] = {
	{ TORCH, 0, TOOL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItem[] = {
	{ SCR_HEALING, 0, SCROLL_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj InvisibilityRing[] = {
	{ RIN_INVISIBILITY, 0, RING_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItemB[] = {
	{ SCR_STANDARD_ID, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItemC[] = {
	{ SCR_MANA, 0, SCROLL_CLASS, 4, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItemD[] = {
	{ SCR_CURE, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItemE[] = {
	{ SCR_PHASE_DOOR, 0, SCROLL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AlwaysStartItemF[] = {
	{ SCR_HEAL_OTHER, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AngbandItem[] = {
	{ SCR_IDENTIFY, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AngbandItemB[] = {
	{ SCR_TELEPORTATION, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj AngbandItemC[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj DeathmoldItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj DunadanItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj ThunderlordItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SatreItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj TonberryItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 3, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KlackonItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj KutarItem[] = {
	{ SCR_RETURN, 0, SCROLL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemA[] = {
	{ TALLOW_CANDLE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemB[] = {
	{ POT_FRUIT_JUICE, 0, POTION_CLASS, 5, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BullyA[] = {
	{ POT_FRUIT_JUICE, 0, POTION_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BullyB[] = {
	{ POT_BOOZE, 0, POTION_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BullyD[] = {
	{ SACK, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BullyE[] = {
	{ TIN_WHISTLE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemN[] = {
	{ UNDEF_TYP, UNDEF_SPE, ROCK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemO[] = {
	{ UNDEF_TYP, UNDEF_SPE, BALL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemP[] = {
	{ UNDEF_TYP, UNDEF_SPE, CHAIN_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemQ[] = {
	{ UNDEF_TYP, UNDEF_SPE, VENOM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemR[] = {
	{ UNDEF_TYP, UNDEF_SPE, RANDOM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC1[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD1[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE1[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF1[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG1[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH1[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI1[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ1[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK1[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL1[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM1[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC2[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD2[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE2[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF2[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG2[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH2[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI2[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ2[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK2[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL2[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM2[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC3[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD3[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE3[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF3[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG3[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH3[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI3[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ3[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK3[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL3[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM3[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC4[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD4[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE4[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF4[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG4[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH4[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI4[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ4[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK4[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL4[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM4[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC5[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD5[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE5[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF5[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG5[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH5[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI5[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ5[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK5[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL5[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM5[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC6[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD6[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE6[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF6[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG6[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH6[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI6[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ6[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK6[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL6[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM6[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC7[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD7[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE7[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF7[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG7[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH7[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI7[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ7[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK7[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL7[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM7[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC8[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD8[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE8[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF8[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG8[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH8[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI8[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ8[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK8[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL8[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM8[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC9[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD9[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE9[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF9[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG9[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH9[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI9[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ9[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK9[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL9[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM9[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemC10[] = {
	{ UNDEF_TYP, UNDEF_SPE, POTION_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemD10[] = {
	{ UNDEF_TYP, UNDEF_SPE, SCROLL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemE10[] = {
	{ UNDEF_TYP, UNDEF_SPE, WAND_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemF10[] = {
	{ UNDEF_TYP, UNDEF_SPE, ARMOR_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemG10[] = {
	{ UNDEF_TYP, UNDEF_SPE, WEAPON_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemH10[] = {
	{ UNDEF_TYP, UNDEF_SPE, RING_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemI10[] = {
	{ UNDEF_TYP, UNDEF_SPE, AMULET_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemJ10[] = {
	{ UNDEF_TYP, UNDEF_SPE, TOOL_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemK10[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemL10[] = {
	{ UNDEF_TYP, UNDEF_SPE, SPBOOK_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj UberLostSoulItemM10[] = {
	{ UNDEF_TYP, UNDEF_SPE, GEM_CLASS, 1, UNDEF_BLESS },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj GigantItem[] = {
	{ BOULDER, 0, ROCK_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj OgroItem[] = {
	{ CLUB, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj NemesisItem[] = {
	{ TRIDENT, 7, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj BatmanItem[] = {
	{ BOOMERANG, 0, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj Tinopener[] = {
	{ TIN_OPENER, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj SylphStuff[] = {
    {POT_GAIN_ENERGY, 0, POTION_CLASS, 1, UNDEF_BLESS},
    {POT_HEALING, 0, POTION_CLASS, 1, UNDEF_BLESS},
    {0, 0, 0, 0, 0}
};

static struct trobj EntStuff[] = {
	{ ORANGE, 0, FOOD_CLASS, 3, 0 },
	{ APPLE, 0, FOOD_CLASS, 3, 0 },
	{ CARROT, 0, FOOD_CLASS, 3, 0 },
	{ PEAR, 0, FOOD_CLASS, 3, 0 },
	{ ASIAN_PEAR, 0, FOOD_CLASS, 3, 0 },
	{ LEMON, 0, FOOD_CLASS, 3, 0 },
	{ BANANA, 0, FOOD_CLASS, 3, 0 },
	{ MELON, 0, FOOD_CLASS, 3, 0 },
	{ SLIME_MOLD, 0, FOOD_CLASS, 20, 0 },
};

static struct trobj XtraRing[] = {
	{ UNDEF_TYP, 0, RING_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Magicmarker[] = {
	{ MAGIC_MARKER, UNDEF_SPE, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Touchstone[] = {
	{ TOUCHSTONE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Candle[] = {
	{ TALLOW_CANDLE, 3, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Lamp[] = {
	{ OIL_LAMP, 1, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Torch[] = {
	{ TORCH, 0, TOOL_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Blindfold[] = {
	{ BLINDFOLD, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Condome[] = {
	{ CONDOME, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Inka_spellbook[] = {
	{ SPE_NATURE_BEAM, 0, SPBOOK_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Instrument[] = {
	{ WOODEN_FLUTE, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Xtra_food[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Xtra_fopod[] = {
	{ UNDEF_TYP, UNDEF_SPE, FOOD_CLASS, 2, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Leash[] = {
	{ LEATHER_LEASH, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Towel[] = {
	{ TOWEL, 0, TOOL_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj Wishing[] = {
	{ WAN_WISHING, 3, WAND_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
#ifdef GOLDOBJ
static struct trobj Money[] = {
	{ GOLD_PIECE, 0 , COIN_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

#endif

static struct trobj LichOne[] = {
	{ SPE_SUMMON_UNDEAD, 3, SPBOOK_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj LichTwo[] = {
	{ ATHAME, UNDEF_SPE, WEAPON_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj WraithItem[] = {
	{ SPE_PASSWALL, 10, SPBOOK_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};

static struct trobj WarXtrA[] = {
	{ PLATE_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrB[] = {
	{ PLASTEEL_ARMOR, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrC[] = {
	{ CRYSTAL_PLATE_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrD[] = {
	{ BRONZE_PLATE_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrE[] = {
	{ SPLINT_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrF[] = {
	{ BANDED_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrG[] = {
	{ CHAIN_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrH[] = {
	{ SCALE_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrI[] = {
	{ RING_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrJ[] = {
	{ YELLOW_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrK[] = {
	{ GREEN_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrL[] = {
	{ BLUE_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrM[] = {
	{ BLACK_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrN[] = {
	{ ORANGE_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrO[] = {
	{ WHITE_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrP[] = {
	{ RED_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrQ[] = {
	{ DEEP_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrR[] = {
	{ SHIMMERING_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrS[] = {
	{ SILVER_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrT[] = {
	{ GRAY_DRAGON_SCALES, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};
static struct trobj WarXtrU[] = {
	{ COPPER_PLATE_MAIL, 1, ARMOR_CLASS, 1, 0 },
	{ 0, 0, 0, 0, 0 }
};


/* race-based substitutions for initial inventory;
   the weaker cloak for elven rangers is intentional--they shoot better */
static struct inv_sub { int race_pm, item_otyp, subs_otyp; } inv_subs[] = {
    { PM_ELF,	DAGGER,			ELVEN_DAGGER	      },
    { PM_ELF,	SPEAR,			ELVEN_SPEAR	      },
    { PM_ELF,	SHORT_SWORD,		ELVEN_SHORT_SWORD     },
    { PM_ELF,	BOW,			ELVEN_BOW	      },
    { PM_ELF,	ARROW,			ELVEN_ARROW	      },
    { PM_ELF,	STANDARD_HELMET,			ELVEN_LEATHER_HELM    },
 { PM_ELF,	SMALL_SHIELD,		ELVEN_SHIELD	      },
    { PM_ELF,	CLOAK_OF_DISPLACEMENT,	ELVEN_CLOAK	      },
    { PM_ELF,	CRAM_RATION,		LEMBAS_WAFER	      },
    { PM_ORC,	DAGGER,			ORCISH_DAGGER	      },
    { PM_ORC,	SPEAR,			ORCISH_SPEAR	      },
    { PM_ORC,	SHORT_SWORD,		ORCISH_SHORT_SWORD    },
    { PM_ORC,	SCIMITAR,		ORCISH_SCIMITAR    },
    { PM_ORC,	LONG_SWORD,		ORCISH_LONG_SWORD    },
    { PM_ORC,	MORNING_STAR,		ORCISH_MORNING_STAR    },
    { PM_ORC,	BOW,			ORCISH_BOW	      },
    { PM_ORC,	ARROW,			ORCISH_ARROW	      },
    { PM_ORC,	STANDARD_HELMET,			ORCISH_HELM	      },
    { PM_ORC,	SMALL_SHIELD,		ORCISH_SHIELD	      },
    { PM_ORC,	RING_MAIL,		ORCISH_RING_MAIL      },
    { PM_ORC,	CHAIN_MAIL,		ORCISH_CHAIN_MAIL     },
    { PM_DWARF, SPEAR,			DWARVISH_SPEAR	      },
    { PM_DWARF, SHORT_SWORD,		DWARVISH_SHORT_SWORD  },
    { PM_DWARF, STANDARD_HELMET,			DWARVISH_IRON_HELM    },
 { PM_DWARF, SMALL_SHIELD,		DWARVISH_ROUNDSHIELD  },
 { PM_DWARF, PICK_AXE,		DWARVISH_MATTOCK      },
 { PM_DWARF, BATTLE_AXE,		DWARVISH_BATTLE_AXE      },
    { PM_GNOME, BOW,			CROSSBOW	      },
    { PM_GNOME, ARROW,			CROSSBOW_BOLT	      },
    { PM_HUMAN_WEREWOLF,FOOD_RATION,		TRIPE_RATION	      },
    { PM_HUMAN_WEREWOLF,SILVER_SPEAR,		SPEAR		      },
    { PM_HUMAN_WEREWOLF,SILVER_DAGGER,		DAGGER		      },
    { PM_HUMAN_WEREWOLF,SILVER_PISTOL_BULLET,		PISTOL_BULLET		      },
    { PM_DROW,		DAGGER,			DARK_ELVEN_DAGGER     },
    { PM_DROW,		SHORT_SWORD,		DARK_ELVEN_SHORT_SWORD},
    { PM_DROW,		BOW,			DARK_ELVEN_BOW	      },
    { PM_DROW,		ARROW,			DARK_ELVEN_ARROW      },
    { PM_DROW,		CROSSBOW,			DROVEN_CROSSBOW      },
    { PM_DROW,		CROSSBOW_BOLT,			DROVEN_BOLT      },
	 { PM_GNOME, STANDARD_HELMET,	GNOMISH_HELM },
	 { PM_GNOME, LOW_BOOTS, GNOMISH_BOOTS },
	 { PM_GNOME, HIGH_BOOTS, GNOMISH_BOOTS },
	 { PM_GNOME, LEATHER_ARMOR, GNOMISH_SUIT },
    { PM_VAMPIRE,	POT_FRUIT_JUICE,	POT_BLOOD	      },
    { PM_VAMPIRE,	FOOD_RATION,		POT_VAMPIRE_BLOOD     },
    { PM_SUCKING_FIEND,	POT_FRUIT_JUICE,	POT_BLOOD	      },
    { PM_SUCKING_FIEND,	FOOD_RATION,		POT_VAMPIRE_BLOOD     },
    { PM_VAMGOYLE,	POT_FRUIT_JUICE,	POT_BLOOD	      },
    { PM_VAMGOYLE,	FOOD_RATION,		POT_VAMPIRE_BLOOD     },
    { PM_GASTLY,	FOOD_RATION,		CORPSE     },
    { PM_PHANTOM_GHOST,	FOOD_RATION,		CORPSE     },
    { PM_INKA,	SHORT_SWORD,	INKA_BLADE},
    { PM_INKA,	SCIMITAR,	INKUTLASS},
    { PM_INKA,	CLUB,	NATURAL_STICK},
    { PM_INKA,	FLY_SWATTER,	VERMIN_SWATTER},
    { PM_INKA,	SPEAR,	INKA_SPEAR},
    { PM_INKA,	SLING,	INKA_SLING},
    { PM_INKA,	DART,	INKA_STINGER},
    { PM_INKA,	BULLWHIP,	INKA_SHACKLE},
    { PM_INKA,	T_SHIRT,	BEAUTIFUL_SHIRT},
    { PM_INKA,	HAWAIIAN_SHIRT,	BEAUTIFUL_SHIRT},
    { PM_INKA,	ELVEN_MITHRIL_COAT,	INKA_MITHRIL_COAT},
    { PM_INKA,	DWARVISH_MITHRIL_COAT,	INKA_MITHRIL_COAT},
    { PM_INKA,	DROVEN_MITHRIL_COAT,	INKA_MITHRIL_COAT},
    { PM_INKA,	DARK_ELVEN_MITHRIL_COAT,	INKA_MITHRIL_COAT},
    { PM_INKA,	BLINDFOLD,	EYECLOSER},
    { PM_INKA,	LEATHER_SADDLE,	INKA_SADDLE},
    { PM_INKA,	LEATHER_LEASH,	INKA_LEASH},
    { PM_AZTPOK,	SLING,	ATLATL},
    { PM_AZTPOK,	T_SHIRT,	ICHCAHUIPILLI},
    { PM_MAYMES,	SLING,	ATLATL},
    { PM_MAYMES,	T_SHIRT,	ICHCAHUIPILLI},

    /* for weight reasons, don't give scurriers heavy items */  
    {PM_SCURRIER, FOOD_RATION, SLIME_MOLD},  
    {PM_SCURRIER, CRAM_RATION, SLIME_MOLD},  
    {PM_SCURRIER, PICK_AXE, LENSES},  
    {PM_SCURRIER, DAGGER, DART},  
    {PM_SCURRIER, BOW, DART},  
    {PM_SCURRIER, ARROW, DART},  
	/* and yes, this is slashem extended, where they're all much lighter. Consider it a way of nerfing the race. --Amy */

    { NON_PM,	STRANGE_OBJECT,		STRANGE_OBJECT	      }
};

/* align-based substitutions for initial inventory */
struct inv_asub { aligntyp align; short item_otyp, subs_otyp; };
static struct inv_asub inv_asubs[] = {
    { A_CHAOTIC,	HOLY_WAFER,		LEMBAS_WAFER	      },
    { A_NONE,		STRANGE_OBJECT,		STRANGE_OBJECT	      }
};

/* KMH -- Expectations for skills.
 *	1.	Starting equipment will start as basic, and should have a maximum
 *		of at least skilled.  If you enter the dungeon with it, you should
 *		know how to use it.  See weapon.c, skill_init().
 *	2.	First and second artifact gifts should have a maximum of at least
 *		skilled.  See artifact.c, init_artifacts().
 *	3.	Quest artifacts should have a maximum of expert.  See artifact.c,
 *		init_artifacts().
 *	4.	Races that construct weapons (elf, dwarf, orc) should have
 *		a maximum of expert in those weapons.
 *	5.	Spellcasters should get a maximum of at least basic in all spell
 *		categories.
 */

static const struct def_skill Skill_A[] = { /* archeologist */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE,  P_EXPERT, 1 },
    { P_PICK_AXE, P_GRAND_MASTER, 0 },		{ P_SHORT_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 2 },              { P_PADDLE, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },
    { P_FIREARM, P_MASTER, 0 },
    { P_SLING, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 1 },
    { P_BOOMERANG, P_GRAND_MASTER, 0 },		{ P_WHIP, P_MASTER, 0 },
    { P_UNICORN_HORN, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },	{ P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_PROTECTION_SPELL, P_EXPERT, 1 },    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 1 },
    { P_STILETTO_HEELS, P_EXPERT, 1 },

    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    /*WAC- 'A' knows of all spells from studying,  but only really good
    at divination class*/
    { P_RIDING, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ana[] = {  
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 2 },  
    { P_SHORT_SWORD, P_EXPERT, 0 },{ P_LANCE,  P_EXPERT, 0 },  
    { P_SABER, P_EXPERT, 0 },		{ P_LONG_SWORD,  P_EXPERT, 1 },  
    { P_CLUB, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },  
    { P_FIREARM, P_GRAND_MASTER, 0 },  
    { P_DART, P_EXPERT, 0 },		{ P_CROSSBOW, P_EXPERT, 2 },  
    { P_WHIP, P_EXPERT, 2 },  
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_HEALING_SPELL, P_EXPERT, 2 },  
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_MATTER_SPELL, P_EXPERT, 2 },  
    { P_RIDING, P_EXPERT, 1 },  
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 1 },
    { P_IMPLANTS, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_GRINDER, P_EXPERT, 1 },

    { P_CHAOS_SPELL, P_EXPERT, 1 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_MASTER, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_MASTER, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },  
    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },  
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },  
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }  
};  

static const struct def_skill Skill_Art[] = {

	{ P_KNIFE, P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },    { P_HAMMER, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },    { P_BOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 2 },    { P_DAGGER, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 1 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2},
    { P_CLAW, P_EXPERT, 1},
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

	{ P_FIREARM, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 2},
    { P_CHAOS_SPELL, P_MASTER, 0 },
    { P_DJEM_SO, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gam[] = {

    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_SHORT_SWORD,  P_EXPERT, 0 },

    { P_FLAIL, P_MASTER, 0 },		{ P_CLUB,  P_EXPERT, 2},

    { P_KNIFE, P_EXPERT, 2},		{ P_DAGGER,  P_EXPERT, 0 },

	{ P_SHURIKEN, P_EXPERT, 0 },
	{ P_FIREARM, P_MASTER, 0 },
	{ P_BOW, P_MASTER, 0 },
	{ P_RIDING, P_MASTER, 0 },
	{ P_TWO_WEAPON_COMBAT, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },    { P_BODY_SPELL, P_EXPERT, 0 },
	{ P_MATTER_SPELL, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },  
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },

    { P_CHAOS_SPELL, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_But[] = { /* butt lover */

    { P_CLUB, P_MASTER, 0 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_GRAND_MASTER, 0 },		{ P_MORNING_STAR, P_GRAND_MASTER, 0 },
    { P_FLAIL, P_GRAND_MASTER, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_DART, P_EXPERT, 2 },		{ P_LANCE, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },		{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 0 },		{ P_DIVINATION_SPELL, P_EXPERT, 2 },
    { P_SHIELD, P_EXPERT, 2 },		{ P_TWO_WEAPON_COMBAT, P_GRAND_MASTER, 0 },
    { P_QUARTERSTAFF, P_MASTER, 0 },		{ P_RIDING, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 2 },		{ P_CLAW, P_EXPERT, 2 },
    { P_WHIP, P_GRAND_MASTER, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },		{ P_TECHNIQUES, P_EXPERT, 1 },
    { P_MEMORIZATION, P_EXPERT, 2 },		{ P_ATARU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dan[] = {

    { P_AXE, P_EXPERT, 1 },	    { P_SHORT_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_MASTER, 0 },	    { P_DAGGER, P_EXPERT, 2 },
    { P_KNIFE, P_EXPERT, 0 },	    { P_FLAIL, P_EXPERT, 2 },
    { P_POLEARMS, P_EXPERT, 2 },	    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },	    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },	    { P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },	    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_PADDLE, P_MASTER, 0 },		{ P_FIREARM, P_EXPERT, 1 },
    { P_LIGHTSABER, P_MASTER, 0 },		{ P_CHAOS_SPELL, P_MASTER, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 1 },		{ P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },		{ P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },		{ P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },		{ P_MEMORIZATION, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },		{ P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },		{ P_SHII_CHO, P_EXPERT, 2 },
    { P_SORESU, P_MASTER, 0 },		{ P_RIDING, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },    { P_CONE_HEELS, P_GRAND_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },    { P_WEDGE_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dia[] = {

    { P_ORB, P_GRAND_MASTER, 0 },		{ P_CLAW, P_GRAND_MASTER, 0 },
    { P_GRINDER, P_GRAND_MASTER, 0 },		{ P_DAGGER, P_MASTER, 0 },
    { P_KNIFE, P_EXPERT, 2 },		{ P_AXE, P_MASTER, 0 },
    { P_SHORT_SWORD, P_MASTER, 0 },		{ P_BROAD_SWORD, P_MASTER, 0 },
    { P_LONG_SWORD, P_MASTER, 0 },		{ P_TWO_HANDED_SWORD, P_MASTER, 0 },
    { P_SCIMITAR, P_MASTER, 0 },		{ P_SABER, P_MASTER, 0 },
    { P_CLUB, P_MASTER, 0 },		{ P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_MASTER, 0 },		{ P_MORNING_STAR, P_MASTER, 0 },
    { P_FLAIL, P_MASTER, 0 },		{ P_HAMMER, P_MASTER, 0 },
    { P_QUARTERSTAFF, P_GRAND_MASTER, 0 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_SPEAR, P_MASTER, 0 },		{ P_JAVELIN, P_MASTER, 0 },
    { P_TRIDENT, P_MASTER, 0 },		{ P_LANCE, P_MASTER, 0 },
    { P_BOW, P_MASTER, 0 },		{ P_FIREARM, P_MASTER, 0 },
    { P_CROSSBOW, P_MASTER, 0 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 1 },		{ P_ATTACK_SPELL, P_MASTER, 0 },
    { P_HEALING_SPELL, P_EXPERT, 0 },		{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_MASTER, 0 },		{ P_MATTER_SPELL, P_GRAND_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },		{ P_HIGH_HEELS, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },		{ P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },		{ P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 2 },		{ P_DEVICES, P_MASTER, 0 },
    { P_PETKEEPING, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },		{ P_MEMORIZATION, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 2 },		{ P_ATARU, P_EXPERT, 1 },
    { P_NIMAN, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pre[] = {

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },

	{ P_FIREARM, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_WHIP, P_EXPERT, 1 },                { P_LIGHTSABER, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sec[] = {

    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE, P_MASTER, 0 },
    { P_CLUB, P_EXPERT, 2 },		{ P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 2 },		{ P_FLAIL, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_ORB, P_EXPERT, 0 },
    { P_CLAW, P_MASTER, 0 },		{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 2 },
    { P_FIREARM, P_GRAND_MASTER, 0 },		{ P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_MASTER, 0 },		{ P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_MASTER, 0 },		{ P_LIGHTSABER, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },		{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },		{ P_PROTECTION_SPELL, P_MASTER, 0 },
    { P_BODY_SPELL, P_MASTER, 0 },		{ P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },		{ P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_GRAND_MASTER, 0 },		{ P_SEARCHING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },		{ P_TECHNIQUES, P_MASTER, 0 },
    { P_IMPLANTS, P_EXPERT, 2 },		{ P_SEXY_FLATS, P_MASTER, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },		{ P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },		{ P_SYMBIOSIS, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 0 },		{ P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 0 },		{ P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_MASTER, 0 },		{ P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_MASTER, 0 },		{ P_WEDI, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_VENOM, P_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sho[] = { /* shoe fetishist */

    { P_CLUB, P_EXPERT, 0 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_EXPERT, 2 },		{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_WHIP, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },		{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },		{ P_PETKEEPING, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_MASTER, 0 },		{ P_RIDING, P_EXPERT, 2 },

	/* it is not a mistake that they have no high heel forms; they love heels, but can't really walk in them --Amy */

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Scr[] = { /* intel scribe */

    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_DAGGER, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sup[] = {

    { P_KNIFE, P_EXPERT, 0 },		{ P_UNICORN_HORN,  P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_DART,  P_EXPERT, 0 },
    { P_PICK_AXE, P_EXPERT, 1 },		{ P_LONG_SWORD,  P_EXPERT, 1 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_DIVINATION_SPELL, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Lib[] = {

    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },

    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 1 },
    { P_ORB, P_EXPERT, 2 },
    { P_CONE_HEELS, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Aug[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_QUARTERSTAFF,  P_EXPERT, 0 },
	{ P_WHIP, P_EXPERT, 2 },
	{ P_DIVINATION_SPELL, P_EXPERT, 0 },
	{ P_ENCHANTMENT_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
	{ P_MATTER_SPELL, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },

    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Coo[] = {

    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_GRAND_MASTER, 0 },
    { P_SLING, P_EXPERT, 2 },    { P_CLUB, P_EXPERT, 2 },
	{ P_FIREARM, P_EXPERT, 2 },	{ P_BOOMERANG, P_MASTER, 0 },

	{ P_PROTECTION_SPELL, P_EXPERT, 2 },

    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 1 },
    { P_STILETTO_HEELS, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_B[] = { /* barbarian */
    { P_DAGGER, P_EXPERT, 1 },		{ P_AXE, P_MASTER, 0 },
    { P_PICK_AXE, P_EXPERT, 2 },	{ P_SHORT_SWORD, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_EXPERT, 2 },	{ P_LONG_SWORD, P_EXPERT, 2 },
    { P_TWO_HANDED_SWORD, P_MASTER, 0 },	{ P_SCIMITAR, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 1 },		{ P_CLUB, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 2 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_SPEAR, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },            
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_BODY_SPELL, P_EXPERT, 2 },
/*WAC - 'B' is good at attack spells and body manipulation spells
        -both combat oriented */
    { P_RIDING, P_EXPERT, 1 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },  
    { P_TECHNIQUES, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Noo[] = { /* noob mode barb is much less skilled than regular barbarian --Amy */
    { P_DAGGER, P_EXPERT, 1 },		{ P_AXE, P_EXPERT, 0 },
    { P_PICK_AXE, P_EXPERT, 2 },	{ P_SHORT_SWORD, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_EXPERT, 2 },	{ P_LONG_SWORD, P_EXPERT, 2 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },	{ P_SCIMITAR, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 1 },		{ P_CLUB, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 2 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },  
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Bard[] = {
    { P_FIREARM, P_EXPERT, 1 },
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SCIMITAR, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 2 },		{ P_FLAIL, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },	{ P_POLEARMS, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 0 },
    { P_UNICORN_HORN, P_EXPERT, 1 },	{ P_CROSSBOW, P_EXPERT, 2 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sta[] = { /* stand user */
    { P_FIREARM, P_EXPERT, 2 },
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_SCIMITAR, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },		{ P_FLAIL, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },	{ P_POLEARMS, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_SPEAR, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 1 },		{ P_DART, P_EXPERT, 1 },
    { P_UNICORN_HORN, P_EXPERT, 2 },	{ P_CROSSBOW, P_EXPERT, 1 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_GRAND_MASTER, 0 },
    { P_BOULDER_THROWING, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 1 },
    { P_MAKASHI, P_EXPERT, 1 },
    { P_SORESU, P_EXPERT, 2 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_JUYO, P_EXPERT, 1 },
    { P_VAAPAD, P_EXPERT, 1 },
    { P_WEDI, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 1 },
    { P_GRINDER, P_EXPERT, 1 },
    { P_BLOCK_HEELS, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_C[] = { /* caveman */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_CLUB, P_GRAND_MASTER, 0 },               { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 1 },	{ P_FLAIL, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 0 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_TRIDENT, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 0 },                { P_SLING, P_MASTER, 0 },
    { P_BOOMERANG, P_EXPERT, 0 },		{ P_UNICORN_HORN, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 3 },      { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 1 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 1 },

/*WAC - 'C' is at one with the elements - matter spells, as well as
        basic enchantments - removed attack spell basic skill as
        it is now "dark" spells*/
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ass[] = {

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_GRAND_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 2 },    { P_DART, P_EXPERT, 0 },

	{ P_DIVINATION_SPELL, P_EXPERT, 0 },	{ P_MATTER_SPELL, P_EXPERT, 2 },
	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_CLAW, P_GRAND_MASTER, 0 },
    { P_VENOM, P_MASTER, 0 },

    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_ATARU, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Bul[] = {
    { P_CLUB, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_SABER, P_EXPERT, 2 },             { P_LONG_SWORD,  P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 2 },             { P_DART,  P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 1 },             { P_BARE_HANDED_COMBAT,  P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pic[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 1 },		{ P_DART,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_BARE_HANDED_COMBAT,  P_EXPERT, 0 },
	{ P_FIREARM,  P_EXPERT, 2 },		{ P_TWO_WEAPON_COMBAT,  P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_WEDI, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Roc[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 1 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 2 },               { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 2 },    { P_FIREARM, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 1 },	{ P_FLAIL, P_EXPERT, 1 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 1 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_TRIDENT, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },                { P_SLING, P_GRAND_MASTER, 0 },
    { P_BOOMERANG, P_EXPERT, 0 },		{ P_UNICORN_HORN, P_EXPERT, 1 },

    { P_MATTER_SPELL, P_EXPERT, 1 },      { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_DIVINATION_SPELL, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 2 },
    { P_BLOCK_HEELS, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_F[] = { /* flame mage */
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 1 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 2 },        { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 1 },                { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 1 },               { P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },        { P_POLEARMS, P_EXPERT, 1 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 1 },               { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_LANCE, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },                { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 2 },      { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_PROTECTION_SPELL, P_EXPERT, 1 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_MASTER, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },

    { P_ELEMENTAL_SPELL, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static struct def_skill Skill_Fig[] = {

    { P_DAGGER, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_LONG_SWORD, P_EXPERT, 0 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 1 }, { P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 1 },	/*add P_PADDLE*/
    { P_SPEAR, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },		{ P_SLING, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 2 },		{ P_SHURIKEN, P_EXPERT, 1 },
	{ P_BROAD_SWORD, P_EXPERT, 2 }, { P_SCIMITAR, P_EXPERT, 2 },
	{ P_CROSSBOW, P_EXPERT, 1 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },	{ P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static struct def_skill Skill_Fen[] = {
    { P_DAGGER, P_MASTER, 0 },
    { P_SHORT_SWORD, P_MASTER, 0 },	{ P_BROAD_SWORD, P_MASTER, 0 },
    { P_LONG_SWORD, P_MASTER, 0 },		{ P_TWO_HANDED_SWORD, P_MASTER, 0 },
    	{ P_SCIMITAR, P_MASTER, 0 },		{ P_SABER, P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_MASTER, 0 },	{ P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_HEALING_SPELL, P_EXPERT, 2 },	
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 2 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },
    { P_NIMAN, P_EXPERT, 1 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Med[] = {

    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_SABER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_POLEARMS, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 2 },		{ P_UNICORN_HORN, P_EXPERT, 1 },

    { P_HEALING_SPELL, P_EXPERT, 0 },	{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },	{ P_FIREARM, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 1 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_MASTER, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_NIMAN, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sha[] = { /* shapeshifter */
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 2 },             { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 2 },        { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 1 },        { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 2 },                { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },               { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },        { P_POLEARMS, P_EXPERT, 1 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 2 },               { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_LANCE, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 2 },
    { P_CROSSBOW, P_EXPERT, 1 },            { P_DART, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },                { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 1 },      { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_MASTER, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 1 },

    { P_POLYMORPHING, P_GRAND_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Fir[] = {
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },        { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 1 },        { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 1 },
    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 2 },                { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 2 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },        { P_POLEARMS, P_EXPERT, 0 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 2 },               { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 1 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 1 },

    { P_ATTACK_SPELL, P_EXPERT, 2 },      { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_GRINDER, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },
    { P_TECHNIQUES, P_EXPERT, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_WEDI, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_Zyb[] = { /* really has expert in everything, even when vanillaoid */

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },                 { P_SLING, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Tha[] = {

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 2 },                 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_MASTER, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 1 },    { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 2 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 2 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },
    { P_BOW, P_MASTER, 0 },                 { P_SLING, P_EXPERT, 1 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 2 },                { P_UNICORN_HORN, P_EXPERT, 1 },
	{ P_LIGHTSABER, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_MASTER, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Lun[] = {

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },                 { P_SLING, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pol[] = {
	{ P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },

    { P_SPIRITUALITY, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sli[] = {
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Spe[] = {

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_All[] = {
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sof[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_CLUB, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_HAMMER, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 2 },		{ P_LIGHTSABER, P_EXPERT, 1 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },		{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 0 },		{ P_HIGH_HEELS, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 2 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_TECHNIQUES, P_MASTER, 0 },		{ P_SEXY_FLATS, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 2 },		{ P_MAKASHI, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 1 },		{ P_NIMAN, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Car[] = {
    { P_DAGGER, P_EXPERT, 0 },	    { P_KNIFE, P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 1 },	    { P_SHORT_SWORD, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 1 },	    { P_MACE, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	    { P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },	    { P_TRIDENT, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 2 },	    { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_MASTER, 0 },	    { P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 1 },	    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },	    { P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_BODY_SPELL, P_EXPERT, 0 },	    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 1 },	    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_FIREARM, P_EXPERT, 2 },
    { P_OCCULT_SPELL, P_EXPERT, 0 },		{ P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },		{ P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_MASTER, 0 },		{ P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 1 },		{ P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 0 },		{ P_MEMORIZATION, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 2 },		{ P_DJEM_SO, P_EXPERT, 2 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Dra[] = {
    { P_DAGGER, P_MASTER, 0 },	    { P_KNIFE, P_MASTER, 0 },
    { P_AXE, P_EXPERT, 1 },	    { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_MASTER, 0 },	    { P_BROAD_SWORD, P_GRAND_MASTER, 0 },
    { P_LONG_SWORD, P_MASTER, 0 },	    { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_GRAND_MASTER, 0 },	    { P_SABER, P_GRAND_MASTER, 0 },
    { P_CLUB, P_EXPERT, 1 },	    { P_MACE, P_MASTER, 0 },
    { P_MORNING_STAR, P_MASTER, 0 },	    { P_FLAIL, P_EXPERT, 1 },
    { P_HAMMER, P_EXPERT, 1 },	    { P_POLEARMS, P_GRAND_MASTER, 0 },
    { P_SPEAR, P_GRAND_MASTER, 0 },	    { P_TRIDENT, P_EXPERT, 1 },
    { P_LANCE, P_GRAND_MASTER, 0 },	    { P_BOW, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },	    { P_ATTACK_SPELL, P_EXPERT, 1 },
    { P_JAVELIN, P_GRAND_MASTER, 0 },
    { P_HEALING_SPELL, P_EXPERT, 0 },	    { P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_RIDING, P_GRAND_MASTER, 0 },	    { P_TWO_WEAPON_COMBAT, P_GRAND_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_LIGHTSABER, P_EXPERT, 1 },
    { P_CHAOS_SPELL, P_EXPERT, 2 },		{ P_ELEMENTAL_SPELL, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 2 },		{ P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 1 },		{ P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },		{ P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },		{ P_ATARU, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Com[] = { /* grand master at all combat skills, has no other starting skills */
    { P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },		{ P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },		{ P_SHIELD, P_GRAND_MASTER, 0 },
    { P_BODY_ARMOR, P_GRAND_MASTER, 0 },		{ P_TWO_HANDED_WEAPON, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_GRAND_MASTER, 0 },		{ P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },		{ P_SPIRITUALITY, P_GRAND_MASTER, 0 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },		{ P_IMPLANTS, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },		{ P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },		{ P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_SYMBIOSIS, P_GRAND_MASTER, 0 },		{ P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_GRAND_MASTER, 0 },		{ P_SORESU, P_GRAND_MASTER, 0 },
    { P_ATARU, P_GRAND_MASTER, 0 },		{ P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },		{ P_NIMAN, P_GRAND_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },		{ P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },		{ P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_GRAND_MASTER, 0 },		{ P_RIDING, P_GRAND_MASTER, 0 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },     { P_CONE_HEELS, P_GRAND_MASTER, 0 },
    { P_BLOCK_HEELS, P_GRAND_MASTER, 0 },    { P_WEDGE_HEELS, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Fjo[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_PADDLE, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },		{ P_LANCE, P_EXPERT, 2 },
    { P_SLING, P_MASTER, 0 },		{ P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },		{ P_SHII_CHO, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },		{ P_RIDING, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Pra[] = {
    { P_KNIFE, P_EXPERT, 0 },		{ P_AXE, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_CLUB, P_MASTER, 0 },
    { P_PADDLE, P_EXPERT, 0 },		{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_MASTER, 0 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 0 },		{ P_FIREARM, P_EXPERT, 1 },
    { P_DART, P_MASTER, 0 },		{ P_BOOMERANG, P_EXPERT, 2 },
    { P_UNICORN_HORN, P_MASTER, 0 },		{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },		{ P_OCCULT_SPELL, P_EXPERT, 1 },
    { P_CHAOS_SPELL, P_EXPERT, 1 },		{ P_MATTER_SPELL, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_HIGH_HEELS, P_MASTER, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_SHIELD, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },		{ P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 2 },		{ P_PETKEEPING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 1 },		{ P_SEXY_FLATS, P_MASTER, 0 },
    { P_SQUEAKING, P_MASTER, 0 },		{ P_SORESU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 2 },		{ P_DJEM_SO, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 2 },		{ P_RIDING, P_EXPERT, 2 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },     { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 2 },
    { P_VENOM, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Eme[] = {
    { P_AXE, P_MASTER, 0 },		{ P_PICK_AXE, P_MASTER, 0 },
    { P_LONG_SWORD, P_EXPERT, 2 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_PADDLE, P_MASTER, 0 },		{ P_MACE, P_EXPERT, 2 },
    { P_MORNING_STAR, P_MASTER, 0 },		{ P_FLAIL, P_MASTER, 0 },
    { P_HAMMER, P_GRAND_MASTER, 0 },		{ P_QUARTERSTAFF, P_MASTER, 0 },
    { P_POLEARMS, P_EXPERT, 0 },		{ P_BOW, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 0 },		{ P_FIREARM, P_GRAND_MASTER, 0 },
    { P_CROSSBOW, P_MASTER, 0 },		{ P_DART, P_MASTER, 0 },
    { P_SHURIKEN, P_EXPERT, 2 },		{ P_LIGHTSABER, P_MASTER, 0 },
    { P_ATTACK_SPELL, P_GRAND_MASTER, 0 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_CHAOS_SPELL, P_GRAND_MASTER, 0 },		{ P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },		{ P_BODY_ARMOR, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },		{ P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },		{ P_ATARU, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_MASTER, 0 },		{ P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },		{ P_TWO_WEAPON_COMBAT, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 2 },		{ P_GRINDER, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Tos[] = {
    { P_JAVELIN, P_GRAND_MASTER, 0 },		{ P_DAGGER, P_EXPERT, 0 },
    { P_KNIFE, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 1 },
    { P_SABER, P_EXPERT, 2 },		{ P_CLUB, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 2 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_HAMMER, P_EXPERT, 2 },
    { P_SPEAR, P_MASTER, 0 },		{ P_TRIDENT, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 2 },		{ P_WHIP, P_EXPERT, 1 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },		{ P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_HIGH_HEELS, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_SHIELD, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 2 },		{ P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 1 },		{ P_TECHNIQUES, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 1 },		{ P_SHII_CHO, P_EXPERT, 1 },
    { P_SHIEN, P_EXPERT, 1 },		{ P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_RIDING, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Akl[] = {
    { P_CLUB, P_GRAND_MASTER, 0 },		{ P_DAGGER, P_EXPERT, 2 },
    { P_KNIFE, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_BROAD_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_EXPERT, 0 },		{ P_MORNING_STAR, P_MASTER, 0 },
    { P_FLAIL, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },		{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 1 },		{ P_CROSSBOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 2 },		{ P_WHIP, P_MASTER, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },		{ P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_BODY_SPELL, P_EXPERT, 2 },		{ P_OCCULT_SPELL, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },		{ P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 2 },		{ P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_MASTER, 0 },		{ P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 1 },		{ P_MAKASHI, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },		{ P_JUYO, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 2 },		{ P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Mil[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 0 },		{ P_PADDLE, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 1 },		{ P_MATTER_SPELL, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_BODY_ARMOR, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 0 },		{ P_TECHNIQUES, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Sym[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_SHORT_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_CLUB, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },		{ P_FLAIL, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },		{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },		{ P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_SYMBIOSIS, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },		{ P_PETKEEPING, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },		{ P_SHIEN, P_EXPERT, 2 },
    { P_NIMAN, P_EXPERT, 2 },		{ P_RIDING, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};
static const struct def_skill Skill_Gen[] = {
    { P_KNIFE, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 2 },
    { P_SABER, P_MASTER, 0 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_FIREARM, P_MASTER, 0 },
    { P_LIGHTSABER, P_EXPERT, 2 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },		{ P_POLYMORPHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },		{ P_PETKEEPING, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_EXPERT, 2 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },		{ P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },    { P_WEDGE_HEELS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cra[] = {
    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },		{ P_PICK_AXE, P_EXPERT, 0 },
    { P_SABER, P_MASTER, 0 },		{ P_CLUB, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },		{ P_MACE, P_EXPERT, 0 },
    { P_FLAIL, P_MASTER, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SLING, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },		{ P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },		{ P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_BODY_ARMOR, P_EXPERT, 1 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },		{ P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_GRAND_MASTER, 0 },		{ P_SEARCHING, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },		{ P_ATARU, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },		{ P_NIMAN, P_EXPERT, 1 },
    { P_JUYO, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Jan[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },		{ P_CLUB, P_EXPERT, 0 },
    { P_PADDLE, P_MASTER, 0 },		{ P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 2 },		{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 2 },		{ P_SLING, P_MASTER, 0 },
    { P_FIREARM, P_EXPERT, 0 },		{ P_CROSSBOW, P_EXPERT, 2 },
    { P_WHIP, P_MASTER, 0 },		{ P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_BODY_SPELL, P_EXPERT, 2 },		{ P_MATTER_SPELL, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 1 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },		{ P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },		{ P_TECHNIQUES, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 1 },		{ P_SHIEN, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 2 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sma[] = {
    { P_AXE, P_EXPERT, 0 },		{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 0 },
    { P_FIREARM, P_GRAND_MASTER, 0 },		{ P_CROSSBOW, P_EXPERT, 2 },
    { P_LIGHTSABER, P_MASTER, 0 },		{ P_BODY_SPELL, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },		{ P_BODY_ARMOR, P_GRAND_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },		{ P_MAKASHI, P_MASTER, 0 },
    { P_ATARU, P_MASTER, 0 },		{ P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_MASTER, 0 },		{ P_JUYO, P_MASTER, 0 },
    { P_VAAPAD, P_MASTER, 0 },		{ P_TWO_WEAPON_COMBAT, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sto[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_SABER, P_MASTER, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_TRIDENT, P_MASTER, 0 },		{ P_FIREARM, P_MASTER, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },		{ P_DART, P_EXPERT, 1 },
    { P_LIGHTSABER, P_EXPERT, 0 },		{ P_ATTACK_SPELL, P_MASTER, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_MATTER_SPELL, P_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },		{ P_HIGH_HEELS, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },		{ P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 1 },		{ P_SPIRITUALITY, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },		{ P_ATARU, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },		{ P_JUYO, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },		{ P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Joc[] = {
    { P_WHIP, P_GRAND_MASTER, 0 },		{ P_RIDING, P_GRAND_MASTER, 0 },
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_SCIMITAR, P_MASTER, 0 },
    { P_PADDLE, P_MASTER, 0 },		{ P_FLAIL, P_EXPERT, 0 },
    { P_POLEARMS, P_MASTER, 0 },		{ P_SPEAR, P_MASTER, 0 },
    { P_JAVELIN, P_EXPERT, 0 },		{ P_LANCE, P_MASTER, 0 },
    { P_BOW, P_EXPERT, 0 },		{ P_SLING, P_MASTER, 0 },
    { P_FIREARM, P_EXPERT, 0 },		{ P_DART, P_EXPERT, 0 },
    { P_BOOMERANG, P_MASTER, 0 },		{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },		{ P_CHAOS_SPELL, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_HIGH_HEELS, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },		{ P_SEARCHING, P_EXPERT, 2 },
    { P_PETKEEPING, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 2 },		{ P_GUN_CONTROL, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },		{ P_JUYO, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }

};

static const struct def_skill Skill_Yau[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },		{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_CLUB, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },		{ P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },		{ P_POLEARMS, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 0 },		{ P_SLING, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 0 },		{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },		{ P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_OCCULT_SPELL, P_EXPERT, 0 },		{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },		{ P_POLYMORPHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 2 },		{ P_PETKEEPING, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_EXPERT, 1 },		{ P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },		{ P_SORESU, P_EXPERT, 2 },
    { P_NIMAN, P_EXPERT, 2 },		{ P_VAAPAD, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 2 },
    { P_WEDGE_HEELS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Qua[] = {
    { P_KNIFE, P_EXPERT, 0 },		{ P_AXE, P_EXPERT, 0 },
    { P_CLUB, P_GRAND_MASTER, 0 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_MASTER, 0 },		{ P_MORNING_STAR, P_MASTER, 0 },
    { P_FLAIL, P_MASTER, 0 },		{ P_HAMMER, P_MASTER, 0 },
    { P_QUARTERSTAFF, P_MASTER, 0 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_MASTER, 0 },
    { P_TRIDENT, P_EXPERT, 2 },		{ P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },		{ P_SLING, P_GRAND_MASTER, 0 },
    { P_FIREARM, P_EXPERT, 0 },		{ P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_MASTER, 0 },		{ P_SHURIKEN, P_EXPERT, 2 },
    { P_BOOMERANG, P_GRAND_MASTER, 0 },		{ P_WHIP, P_MASTER, 0 },
    { P_UNICORN_HORN, P_EXPERT, 1 },		{ P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },		{ P_PROTECTION_SPELL, P_EXPERT, 1 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },		{ P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },		{ P_DEVICES, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },		{ P_TECHNIQUES, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },		{ P_DJEM_SO, P_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },		{ P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Psy[] = {
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 1 },		{ P_PADDLE, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_MASTER, 0 },		{ P_UNICORN_HORN, P_EXPERT, 0 },
    { P_LIGHTSABER, P_EXPERT, 2 },		{ P_ATTACK_SPELL, P_MASTER, 0 },
    { P_HEALING_SPELL, P_EXPERT, 0 },		{ P_DIVINATION_SPELL, P_MASTER, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },		{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_MASTER, 0 },		{ P_OCCULT_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },		{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },		{ P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },		{ P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },		{ P_PETKEEPING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_MASTER, 0 },		{ P_SEXY_FLATS, P_EXPERT, 1 },
    { P_SHII_CHO, P_EXPERT, 0 },		{ P_SORESU, P_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 0 },		{ P_NIMAN, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },   { P_ORB, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Emp[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_SCIMITAR, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 1 },		{ P_CLUB, P_EXPERT, 2 },
    { P_MACE, P_MASTER, 0 },		{ P_FLAIL, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_FIREARM, P_EXPERT, 1 },
    { P_UNICORN_HORN, P_MASTER, 0 },		{ P_HEALING_SPELL, P_GRAND_MASTER, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },		{ P_PROTECTION_SPELL, P_MASTER, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },		{ P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_HIGH_HEELS, P_MASTER, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },		{ P_POLYMORPHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_GRAND_MASTER, 0 },		{ P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },		{ P_SHII_CHO, P_EXPERT, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },		{ P_SHIEN, P_EXPERT, 0 },
    { P_NIMAN, P_MASTER, 0 },		{ P_WEDI, P_EXPERT, 2 },
    { P_RIDING, P_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },
    { P_SYMBIOSIS, P_GRAND_MASTER, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mam[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_PICK_AXE, P_EXPERT, 1 },		{ P_CLUB, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },		{ P_HAMMER, P_EXPERT, 2 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SLING, P_MASTER, 0 },
    { P_FIREARM, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 2 },
    { P_UNICORN_HORN, P_EXPERT, 1 },		{ P_LIGHTSABER, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },		{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_GRAND_MASTER, 0 },		{ P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_OCCULT_SPELL, P_MASTER, 0 },		{ P_ELEMENTAL_SPELL, P_MASTER, 0 },
    { P_CHAOS_SPELL, P_MASTER, 0 },		{ P_MATTER_SPELL, P_GRAND_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_HIGH_HEELS, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },		{ P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_MASTER, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },		{ P_SPIRITUALITY, P_MASTER, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },		{ P_IMPLANTS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },		{ P_MAKASHI, P_EXPERT, 2 },
    { P_ATARU, P_EXPERT, 1 },		{ P_SHIEN, P_EXPERT, 0 },
    { P_NIMAN, P_MASTER, 0 },		{ P_VAAPAD, P_EXPERT, 1 },
    { P_WEDI, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Wei[] = {
    { P_KNIFE, P_MASTER, 0 },		{ P_AXE, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_MASTER, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_MASTER, 0 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MORNING_STAR, P_EXPERT, 2 },		{ P_POLEARMS, P_GRAND_MASTER, 0 },
    { P_JAVELIN, P_EXPERT, 0 },		{ P_BOW, P_MASTER, 0 },
    { P_SLING, P_EXPERT, 0 },		{ P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_MASTER, 0 },		{ P_BOOMERANG, P_MASTER, 0 },
    { P_WHIP, P_EXPERT, 0 },		{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },		{ P_CHAOS_SPELL, P_MASTER, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },		{ P_TWO_HANDED_WEAPON, P_MASTER, 0 },
    { P_POLYMORPHING, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },		{ P_DJEM_SO, P_EXPERT, 0 },
    { P_JUYO, P_MASTER, 0 },		{ P_MARTIAL_ARTS, P_EXPERT, 2 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_CLAW, P_GRAND_MASTER, 0 },
    { P_WEDGE_HEELS, P_GRAND_MASTER, 0 },
    { P_GRINDER, P_MASTER, 0 },
    { P_VENOM, P_MASTER, 0 },
    { P_BOULDER_THROWING, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ast[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },		{ P_PICK_AXE, P_MASTER, 0 },
    { P_SHORT_SWORD, P_MASTER, 0 },		{ P_BROAD_SWORD, P_MASTER, 0 },
    { P_LONG_SWORD, P_MASTER, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_MASTER, 0 },		{ P_SABER, P_MASTER, 0 },
    { P_CLUB, P_EXPERT, 0 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_EXPERT, 0 },		{ P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_MASTER, 0 },		{ P_HAMMER, P_GRAND_MASTER, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },		{ P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },		{ P_SLING, P_MASTER, 0 },
    { P_FIREARM, P_GRAND_MASTER, 0 },		{ P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_MASTER, 0 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_BOOMERANG, P_MASTER, 0 },		{ P_WHIP, P_EXPERT, 0 },
    { P_UNICORN_HORN, P_EXPERT, 2 },		{ P_LIGHTSABER, P_GRAND_MASTER, 0 },
    { P_BODY_SPELL, P_MASTER, 0 },		{ P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },		{ P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },
    { P_SHIELD, P_MASTER, 0 },		{ P_BODY_ARMOR, P_GRAND_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },		{ P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },		{ P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },		{ P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },		{ P_TECHNIQUES, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },		{ P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 0 },		{ P_ATARU, P_MASTER, 0 },
    { P_SHIEN, P_MASTER, 0 },		{ P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },		{ P_JUYO, P_MASTER, 0 },
    { P_VAAPAD, P_EXPERT, 0 },		{ P_WEDI, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },		{ P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 2 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cyb[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_GRAND_MASTER, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 2 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },      { P_BODY_SPELL, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },	{ P_FIREARM, P_GRAND_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dis[] = {
    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE, P_MASTER, 0 },
    { P_PICK_AXE, P_EXPERT, 0 },		{ P_SHORT_SWORD, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 2 },		{ P_PADDLE, P_MASTER, 0 },
    { P_POLEARMS, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 2 },		{ P_FIREARM, P_EXPERT, 2 },
    { P_DART, P_MASTER, 0 },		{ P_BOOMERANG, P_MASTER, 0 },
    { P_WHIP, P_MASTER, 0 },		{ P_UNICORN_HORN, P_GRAND_MASTER, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },		{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },		{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },		{ P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },		{ P_BODY_ARMOR, P_EXPERT, 0 },
    { P_POLYMORPHING, P_MASTER, 0 },		{ P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 0 },		{ P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_MASTER, 0 },		{ P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_EXPERT, 2 },		{ P_SHII_CHO, P_EXPERT, 2 },
    { P_MAKASHI, P_EXPERT, 2 },		{ P_SORESU, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 1 },		{ P_JUYO, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },		{ P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_CONE_HEELS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Xel[] = {
    { P_ATTACK_SPELL, P_MASTER, 0 },		    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },		    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		    { P_BARE_HANDED_COMBAT, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },		    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },		    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },		    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },		    { P_MAKASHI, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },		    { P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Erd[] = {

    { P_QUARTERSTAFF, P_EXPERT, 2 },        { P_LONG_SWORD, P_EXPERT, 0 },
	{ P_BOOMERANG, P_EXPERT, 0 },		{ P_CLUB, P_EXPERT, 0 },
	{ P_AXE, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 2 },

    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Bin[] = { /* everything at expert, even in vanillaoid mode */

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },                 { P_SLING, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Jes[] = {

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },             { P_MATTER_SPELL,  P_EXPERT, 1 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },             { P_BODY_SPELL,  P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },             { P_RIDING,  P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },             { P_ENCHANTMENT_SPELL,  P_EXPERT, 2 },
    { P_PICK_AXE, P_EXPERT, 1 },             { P_MARTIAL_ARTS,  P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 1 },     { P_BOOMERANG, P_EXPERT, 0 }, 

    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },

    { P_CHAOS_SPELL, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Lad[] = {

	 { P_MARTIAL_ARTS, P_EXPERT, 2 },
	 { P_DART, P_EXPERT, 2 },
    { P_DAGGER, P_EXPERT, 2 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sin[] = { /* singslave */

	{ P_CLUB, P_EXPERT, 0 },	{ P_FLAIL, P_EXPERT, 0 },
	{ P_HAMMER, P_EXPERT, 0 },	{ P_SLING, P_EXPERT, 2 },
	{ P_DART, P_EXPERT, 2 },	{ P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
	{ P_DEVICES, P_EXPERT, 2 },	{ P_SEARCHING, P_MASTER, 0 },
	{ P_DJEM_SO, P_EXPERT, 1 },	{ P_JUYO, P_EXPERT, 1 },
	{ P_RIDING, P_EXPERT, 2 },

	{ P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sex[] = {

	 { P_MARTIAL_ARTS, P_EXPERT, 2 },
	 { P_DART, P_EXPERT, 2 },
	 { P_FIREARM, P_EXPERT, 1 },
    { P_DAGGER, P_EXPERT, 2 },             { P_KNIFE,  P_EXPERT, 2 },
	 { P_HEALING_SPELL, P_EXPERT, 0 },
	 { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_EXPERT, 1 },
    { P_SORESU, P_EXPERT, 1 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Blo[] = { /* bloodseeker */

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },               { P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },               { P_LANCE, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },               { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 0 },               { P_FIREARM, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 2 },
    { P_GRINDER, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mys[] = { /* knows all skills, except martial arts; vanillaoid still gets expert */

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },                 { P_SLING, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dem[] = { /* knows all skills, vanillaoid still gets expert */

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },                 { P_SLING, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cel[] = {

    { P_ATTACK_SPELL, P_MASTER, 0 },		{ P_PROTECTION_SPELL, P_MASTER, 0 },
    { P_HEALING_SPELL, P_GRAND_MASTER, 0 },		{ P_BODY_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_MASTER, 0 },		{ P_DIVINATION_SPELL, P_MASTER, 0 },
    { P_OCCULT_SPELL, P_MASTER, 0 },		{ P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_MASTER, 0 },		{ P_CHAOS_SPELL, P_MASTER, 0 },
    { P_QUARTERSTAFF, P_MASTER, 0 },		{ P_DAGGER, P_EXPERT, 0 },
    { P_KNIFE, P_EXPERT, 0 },		{ P_SCIMITAR, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 2 },		{ P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_EXPERT, 1 },		{ P_FLAIL, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 1 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 0 },		{ P_BOOMERANG, P_MASTER, 0 },
    { P_WHIP, P_EXPERT, 2 },		{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },		{ P_TECHNIQUES, P_EXPERT, 1 },
    { P_SHII_CHO, P_EXPERT, 2 },		{ P_SORESU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 1 },		{ P_NIMAN, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_SYMBIOSIS, P_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ble[] = { /* bleeder */

	/* Mainly uses edged weapons. --Amy */

    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_MASTER, 0 },
    { P_AXE, P_EXPERT, 2 },                 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 1 },
	{ P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 2 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },                { P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_LIGHTSABER, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 2 },      { P_HEALING_SPELL, P_GRAND_MASTER, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_EXPERT, 1 },

    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_SHIELD, P_GRAND_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_MARTIAL_ARTS, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Spa[] = {

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },

	{ P_FIREARM, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_WHIP, P_EXPERT, 1 },                { P_LIGHTSABER, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Wal[] = {

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },

	{ P_FIREARM, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_WHIP, P_EXPERT, 1 },                { P_LIGHTSABER, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cam[] = {

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },

	{ P_FIREARM, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_WHIP, P_EXPERT, 1 },                { P_LIGHTSABER, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sco[] = { /* gang scholar */

    { P_DAGGER, P_MASTER, 0 },             { P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },        { P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },

    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 1 },

	{ P_FIREARM, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },

    { P_WHIP, P_EXPERT, 1 },                { P_LIGHTSABER, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ele[] = { /* electric mage */
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 2 },             { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },                 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },        { P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 1 },        { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 2 },                { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },               { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 0 },               { P_JAVELIN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 2 },             { P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 2 },                 { P_SLING, P_EXPERT, 2 },
    { P_CROSSBOW, P_EXPERT, 2 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 2 },                { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_ELEMENTAL_SPELL, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Poi[] = { /* poison mage */
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 2 },                 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 2 },        { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 2 },               { P_JAVELIN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 0 },             { P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 2 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 2 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 2 },                { P_UNICORN_HORN, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_VENOM, P_GRAND_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_MASTER, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 1 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Aci[] = { /* acid mage */
/*Style: small-med edged weapons, blunt weapons*/
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 0 },                 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },        { P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 2 },        { P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 0 },          { P_SABER, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },                { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 0 },               { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },        { P_POLEARMS, P_EXPERT, 2 },
/* Relies on spells for ranged attack*/
    { P_SPEAR, P_EXPERT, 2 },               { P_JAVELIN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },            { P_DART, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 2 },                { P_UNICORN_HORN, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },      { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_MASTER, 0 },
/*  Added expert matter spell (elements), skilled in attack, basic in rest
        He is a mage,  so knows the types.*/
    { P_RIDING, P_EXPERT, 1 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 2 },

    { P_ELEMENTAL_SPELL, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Con[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },		    { P_MACE, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 2 },		    { P_FLAIL, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_EXPERT, 1 },
    { P_CLAW, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mur[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },		    { P_MACE, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 2 },		    { P_FLAIL, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_EXPERT, 1 },
    { P_CLAW, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sla[] = {

    { P_SABER, P_EXPERT, 0 },		{ P_UNICORN_HORN,  P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },		{ P_SHORT_SWORD,  P_EXPERT, 2 },
    { P_DART, P_EXPERT, 0 },		{ P_PICK_AXE,  P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_ATARU, P_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_GRINDER, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Abu[] = {
    { P_WHIP, P_EXPERT, 0 },		{ P_FLAIL,  P_EXPERT, 0 },
	{ P_PADDLE,  P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_CHAOS_SPELL, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 2 },
    { P_ATARU, P_EXPERT, 2 },
    { P_WEDI, P_MASTER, 0 },
    { P_GRINDER, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dru[] = { /* drunk */
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 1 },		    { P_CLUB, P_EXPERT, 2 },		    
    { P_DART, P_EXPERT, 0 },		    { P_FLAIL, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 2 },    { P_UNICORN_HORN, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_MATTER_SPELL, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_JUYO, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pro[] = {

    { P_WHIP, P_GRAND_MASTER, 0 },		{ P_DEVICES, P_GRAND_MASTER, 0 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_FIREARM, P_EXPERT, 0 },
    { P_KNIFE, P_EXPERT, 0 },		{ P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },		{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 1 },
    { P_NIMAN, P_GRAND_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 2 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Kur[] = {

    { P_WHIP, P_GRAND_MASTER, 0 },		{ P_DEVICES, P_GRAND_MASTER, 0 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_FIREARM, P_EXPERT, 0 },
    { P_KNIFE, P_EXPERT, 0 },		{ P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },		{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },		{ P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 1 },
    { P_NIMAN, P_GRAND_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_CLAW, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 2 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Hus[] = { /* hussy: quite restricted - meant to be a difficult role --Amy */

    { P_MARTIAL_ARTS, P_MASTER, 0 },	{ P_HAMMER, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },	{ P_SEXY_FLATS, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },
    { P_WEDI, P_MASTER, 0 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_VENOM, P_MASTER, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Acu[] = { /* anachronounbinder - none, has to unlock them via leveling up */

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mas[] = { /* mason */

    { P_DAGGER, P_EXPERT, 2 },	{ P_KNIFE, P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 0 },	{ P_PICK_AXE, P_MASTER, 0 },
    { P_CLUB, P_EXPERT, 0 },	{ P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },	{ P_MORNING_STAR, P_MASTER, 0 },
    { P_FLAIL, P_MASTER, 0 },	{ P_HAMMER, P_MASTER, 0 },
    { P_SLING, P_MASTER, 0 },	{ P_FIREARM, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_DIVINATION_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 1 },	{ P_BODY_SPELL, P_MASTER, 0 },
    { P_OCCULT_SPELL, P_EXPERT, 0 },	{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_GENERAL_COMBAT, P_EXPERT, 2 },	{ P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 2 },	{ P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_MASTER, 0 },	{ P_TECHNIQUES, P_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 0 },	{ P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Tra[] = {
    { P_HAMMER, P_GRAND_MASTER, 0 },		{ P_PICK_AXE, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },		    { P_MACE, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_MASTER, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },

    { P_CHAOS_SPELL, P_MASTER, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Trs[] = {
    { P_HAMMER, P_GRAND_MASTER, 0 },		{ P_PICK_AXE, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },		    { P_MACE, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_MASTER, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_SORESU, P_EXPERT, 1 },

    { P_CHAOS_SPELL, P_MASTER, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Act[] = {
    { P_PADDLE, P_GRAND_MASTER, 0 },		{ P_WHIP, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 2 },		    { P_SHURIKEN, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },	{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 2 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_WEDI, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Soc[] = { /* sjw, skills are inited in weapon.c */

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Top[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 1 },		    { P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 0 },		{ P_SPEAR, P_EXPERT, 0 },
    { P_JAVELIN, P_EXPERT, 0 },		{ P_TRIDENT, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 2 },		{ P_SLING, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },		{ P_WHIP, P_EXPERT, 2 },
	{ P_LIGHTSABER, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 1 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },	{ P_MATTER_SPELL, P_EXPERT, 1 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_MASTER, 0 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },
    { P_BOULDER_THROWING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },
    { P_CONE_HEELS, P_GRAND_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Fai[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 1 },		    { P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 0 },		{ P_SPEAR, P_EXPERT, 0 },
    { P_JAVELIN, P_EXPERT, 0 },		{ P_TRIDENT, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 2 },		{ P_SLING, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },		{ P_WHIP, P_EXPERT, 2 },
	{ P_LIGHTSABER, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 1 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_PROTECTION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },	{ P_MATTER_SPELL, P_EXPERT, 1 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_MASTER, 0 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },
    { P_BOULDER_THROWING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },
    { P_CONE_HEELS, P_GRAND_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cou[] = {
    { P_KNIFE,  P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 0 },		    { P_MACE, P_EXPERT, 2 },
    { P_CROSSBOW, P_EXPERT, 2 },		    { P_FLAIL, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_BODY_SPELL, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gun[] = {

    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE,  P_MASTER, 0 },
    { P_FIREARM, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_IMPLANTS, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mar[] = { /* doom marine */

    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 1 },		{ P_PICK_AXE, P_EXPERT, 1 },		
    { P_SHORT_SWORD, P_EXPERT, 1 },	{ P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 1 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_SABER, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 2 },                { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 1 },
    { P_MORNING_STAR, P_EXPERT, 1 },	{ P_FLAIL, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 2 },			{ P_CROSSBOW, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 2 },			{ P_DART, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },			{ P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 2 },			{ P_UNICORN_HORN, P_EXPERT, 1 },
    { P_GRINDER, P_GRAND_MASTER, 0 },
    { P_LIGHTSABER, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gan[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 2 },		{ P_SHURIKEN,  P_EXPERT, 0 },
    { P_DART, P_EXPERT, 0 },		    { P_WHIP, P_EXPERT, 2 },		    

    { P_FIREARM, P_MASTER, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 1 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 1 },

    { P_CHAOS_SPELL, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sci[] = {
    { P_KNIFE,  P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },		{ P_HAMMER,  P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },		    { P_FLAIL, P_EXPERT, 0 },		    
    { P_POLEARMS, P_EXPERT, 2 },		    { P_SLING, P_EXPERT, 2 },		    
    { P_WHIP, P_EXPERT, 0 },		    { P_LIGHTSABER, P_EXPERT, 2 },		    
    { P_VENOM, P_EXPERT, 0 },

    { P_FIREARM, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 2 },
	{ P_DIVINATION_SPELL, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },

    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_IMPLANTS, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_EXPERT, 1 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 1 },
    { P_WEDI, P_EXPERT, 2 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Nuc[] = {
    { P_KNIFE,  P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },		{ P_HAMMER,  P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },		    { P_FLAIL, P_EXPERT, 0 },		    
    { P_POLEARMS, P_EXPERT, 1 },		    { P_SLING, P_EXPERT, 2 },		    
    { P_WHIP, P_EXPERT, 0 },		    { P_LIGHTSABER, P_EXPERT, 0 },		    

    { P_FIREARM, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 1 },
	{ P_DIVINATION_SPELL, P_MASTER, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },

    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_IMPLANTS, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 2 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_JUYO, P_EXPERT, 2 },
    { P_VAAPAD, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_MASTER, 0 },
    { P_GRINDER, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_For[] = {

    { P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_AXE, P_EXPERT, 2 },		{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_LANCE, P_EXPERT, 1 },
    { P_BOOMERANG, P_MASTER, 0 },		{ P_UNICORN_HORN, P_MASTER, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },		{ P_BODY_SPELL, P_GRAND_MASTER, 0 },
    { P_OCCULT_SPELL, P_EXPERT, 2 },		{ P_CHAOS_SPELL, P_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },		{ P_HIGH_HEELS, P_EXPERT, 2 },
    { P_SHIELD, P_MASTER, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },		{ P_MISSILE_WEAPONS, P_EXPERT, 1 },
    { P_RIDING, P_EXPERT, 2 },
    { P_IMPLANTS, P_EXPERT, 1 },
    { P_ATARU, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Fem[] = {
    { P_MATTER_SPELL, P_EXPERT, 0 },		{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 0 },		{ P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },		{ P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },		{ P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_OCCULT_SPELL, P_EXPERT, 0 },		{ P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_CLUB, P_EXPERT, 0 },
    { P_PADDLE, P_MASTER, 0 },		{ P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },		{ P_POLEARMS, P_EXPERT, 0 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_TRIDENT, P_EXPERT, 2 },
    { P_LANCE, P_MASTER, 0 },		{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_MASTER, 0 },		{ P_CROSSBOW, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },		{ P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },		{ P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },		{ P_RIDING, P_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 2 },
    { P_SORESU, P_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_MASTER, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_WEDI, P_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_GRAND_MASTER, 0 },
    { P_ORB, P_EXPERT, 1 },
    { P_CLAW, P_MASTER, 0 },
    { P_VENOM, P_GRAND_MASTER, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_G[] = { /* geek */
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_CLUB, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },	{ P_MACE, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },	{ P_HAMMER, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },	{ P_TRIDENT, P_EXPERT, 2 },
    { P_LANCE, P_EXPERT, 2 },	{ P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },	{ P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_EXPERT, 0 },	{ P_BOOMERANG, P_EXPERT, 2 },
    { P_LIGHTSABER, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },        
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_RIDING, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 2 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 1 },
    { P_GRINDER, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gra[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 0 },
	{ P_AXE, P_EXPERT, 2 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },	{ P_CLUB, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 0 },	{ P_MACE, P_EXPERT, 0 },
	{ P_MORNING_STAR, P_EXPERT, 0 },	{ P_QUARTERSTAFF, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 0 },	{ P_HAMMER, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 0 },	{ P_JAVELIN, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 0 },	{ P_SLING, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 0 },	{ P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_MASTER, 0 },	{ P_SHURIKEN, P_EXPERT, 0 },
    { P_LIGHTSABER, P_EXPERT, 0 },    { P_WHIP, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },        
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },

    { P_RIDING, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 1 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 2 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_H[] = { /* healer */
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_SCIMITAR, P_EXPERT, 1 },
    { P_SABER, P_EXPERT, 1 },		{ P_CLUB, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 1 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 1 },		{ P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_TRIDENT, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 2 },		{ P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 2 },		{ P_UNICORN_HORN, P_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 1 },        { P_HEALING_SPELL, P_GRAND_MASTER, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_PROTECTION_SPELL, P_EXPERT, 1 },    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_RIDING, P_EXPERT, 1 },
    { P_STILETTO_HEELS, P_EXPERT, 2 },
    { P_CONE_HEELS, P_EXPERT, 0 },

    { P_DEVICES, P_EXPERT, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 2 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_I[] = { /* ice mage */
/*Resorts mostly to stabbing weapons*/
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 2 },
  { P_AXE, P_EXPERT, 1 },                 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },        { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 2 },      { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },          { P_SABER, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 1 },                { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 1 },               { P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },      { P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },               { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_LANCE, P_EXPERT, 1 },
  { P_BOW, P_EXPERT, 1 },                 { P_SLING, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },            { P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },                { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_MASTER, 0 },        { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },    { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },  { P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    /*WAC - same as Flame Mage*/
    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_ELEMENTAL_SPELL, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_J[] = { /* jedi */
    { P_LIGHTSABER, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 }, { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 2 }, { P_SABER, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 1 },{ P_BOOMERANG, P_EXPERT, 1 },

    { P_FIREARM, P_EXPERT, 1 },
    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_MASTER, 0 },    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_MASTER, 0 },

    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_GRAND_MASTER, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sdw[] = { /* shadow jedi */
    { P_LIGHTSABER, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 }, { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 2 }, { P_SABER, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 1 },{ P_BOOMERANG, P_EXPERT, 1 },

    { P_FIREARM, P_EXPERT, 1 },
    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_MASTER, 0 },    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_MASTER, 0 },

    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_GRAND_MASTER, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Hed[] = { /* hedderjedi - grand master in all forms */
    { P_LIGHTSABER, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 1 }, { P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 2 }, { P_SABER, P_EXPERT, 2 },

    { P_FIREARM, P_EXPERT, 1 },
    { P_BODY_SPELL, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_GRAND_MASTER, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_ATARU, P_GRAND_MASTER, 0 },
    { P_SHIEN, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_NIMAN, P_GRAND_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Fox[] = {

    { P_LONG_SWORD, P_EXPERT, 2 },                { P_SHORT_SWORD, P_EXPERT, 2 },
    { P_DART, P_EXPERT, 0 },

    { P_CROSSBOW, P_MASTER, 0 },                { P_KNIFE, P_MASTER, 0 },
    { P_DAGGER, P_MASTER, 0 },                { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_BOW, P_MASTER, 0 },                { P_FIREARM, P_MASTER, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Stu[] = { /* feat master */

	{ P_FLAIL, P_GRAND_MASTER, 0 },
    { P_WHIP, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },
    { P_DAGGER, P_EXPERT, 0 },		{ P_AXE, P_EXPERT, 2 },
    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_BOULDER_THROWING, P_MASTER, 0 },

    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_DJEM_SO, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pal[] = {

    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_MASTER, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },	

    { P_BOW, P_EXPERT, 2 },                { P_CROSSBOW, P_EXPERT, 1 },

    { P_CLUB, P_EXPERT, 0 },                { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },	{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		    { P_QUARTERSTAFF, P_MASTER, 0 },		

    { P_PROTECTION_SPELL, P_MASTER, 0 },      { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },      { P_HEALING_SPELL, P_MASTER, 0 },
	{ P_DIVINATION_SPELL, P_EXPERT, 0 },

	{ P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_GRAND_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_ORB, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Wan[] = {

    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_FLAIL, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 2 },		{ P_UNICORN_HORN, P_EXPERT, 0 },
	{ P_FIREARM, P_EXPERT, 0 },

    { P_PROTECTION_SPELL, P_EXPERT, 0 },      { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 0 },      { P_ATTACK_SPELL, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 0 },      { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Elm[] = {
    { P_DAGGER, P_EXPERT, 0 },		    { P_KNIFE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },		{ P_SCIMITAR, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 2 },		{ P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 0 },		{ P_FLAIL, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_MASTER, 0 },		{ P_POLEARMS, P_EXPERT, 2 },
    { P_TRIDENT, P_MASTER, 0 },		{ P_WHIP, P_EXPERT, 1 },
    { P_LIGHTSABER, P_EXPERT, 1 },		{ P_BODY_SPELL, P_EXPERT, 1 },
    { P_ELEMENTAL_SPELL, P_GRAND_MASTER, 0 },		{ P_MATTER_SPELL, P_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },		{ P_HIGH_HEELS, P_EXPERT, 1 },
    { P_GENERAL_COMBAT, P_EXPERT, 1 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_VAAPAD, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_WEDI, P_EXPERT, 2 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Occ[] = {
    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE, P_MASTER, 0 },
    { P_AXE, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 1 },		{ P_SABER, P_EXPERT, 1 },
    { P_PADDLE, P_MASTER, 0 },		{ P_MORNING_STAR, P_MASTER, 0 },
    { P_HAMMER, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_LANCE, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 2 },		{ P_CROSSBOW, P_EXPERT, 1 },
    { P_WHIP, P_MASTER, 0 },		{ P_ATTACK_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },		{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },		{ P_HIGH_HEELS, P_EXPERT, 1 },
    { P_GENERAL_COMBAT, P_EXPERT, 1 },		{ P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },		{ P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },		{ P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 2 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cha[] = {
    { P_AXE, P_EXPERT, 0 },		{ P_LONG_SWORD, P_EXPERT, 2 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_LANCE, P_EXPERT, 0 },		{ P_SLING, P_GRAND_MASTER, 0 },
    { P_FIREARM, P_MASTER, 0 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_LIGHTSABER, P_MASTER, 0 },		{ P_BODY_SPELL, P_EXPERT, 2 },
    { P_CHAOS_SPELL, P_GRAND_MASTER, 0 },		{ P_HIGH_HEELS, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 1 },		{ P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_MASTER, 0 },		{ P_DEVICES, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_IMPLANTS, P_EXPERT, 1 },
    { P_ATARU, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_JUYO, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 2 },
    { P_GRINDER, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Wil[] = { /* nothing */

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Trc[] = { /* nothing */

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_K[] = { /* knight */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE, P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 2 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_SABER, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 1 },                { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 2 },
    { P_MORNING_STAR, P_EXPERT, 2 },	{ P_FLAIL, P_EXPERT, 1 },
    { P_HAMMER, P_EXPERT, 1 },		{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_JAVELIN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_GRAND_MASTER, 0 },
    { P_BOW, P_EXPERT, 1 },			{ P_CROSSBOW, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },      { P_BODY_SPELL, P_EXPERT, 1 },
/*WAC - removed the attack spells - no good having knights summoning
        undead!  Replaced with skilled body spells*/

    { P_RIDING, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Jus[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE, P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 1 },		{ P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },                { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },	{ P_FLAIL, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_POLEARMS, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_GRAND_MASTER, 0 },
    { P_BOW, P_EXPERT, 0 },			{ P_CROSSBOW, P_EXPERT, 2 },
    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },      { P_BODY_SPELL, P_EXPERT, 2 },

    { P_RIDING, P_MASTER, 0 },
    { P_JUYO, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mah[] = {

    { P_ATTACK_SPELL, P_MASTER, 0 },      { P_HEALING_SPELL, P_MASTER, 0 },
	{ P_BARE_HANDED_COMBAT, P_MASTER, 0 },	{ P_FIREARM, P_MASTER, 0 },
    { P_VENOM, P_EXPERT, 0 },

    { P_PROTECTION_SPELL, P_EXPERT, 0 },      { P_DIVINATION_SPELL, P_EXPERT, 2 },
	{ P_WHIP, P_EXPERT, 0 },		{ P_CLUB, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
	{ P_BOW, P_EXPERT, 0 },		{ P_BOOMERANG, P_EXPERT, 2 },
	{ P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_AXE, P_EXPERT, 2 },
	{ P_RIDING, P_EXPERT, 2 },
	{ P_SPEAR, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SQUEAKING, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_MASTER, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 1 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_CLAW, P_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dol[] = {

    { P_KNIFE, P_GRAND_MASTER, 0 },
    { P_WHIP, P_MASTER, 0 },

    { P_FIREARM, P_GRAND_MASTER, 0 },

    { P_DAGGER, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_MARTIAL_ARTS, P_EXPERT, 2 },

    { P_PROTECTION_SPELL, P_EXPERT, 0 },      { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_ATTACK_SPELL, P_EXPERT, 2 },      { P_DIVINATION_SPELL, P_EXPERT, 0 },
	{ P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },

    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_IMPLANTS, P_EXPERT, 2 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_NIMAN, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 1 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_MASTER, 0 },
    { P_CLAW, P_EXPERT, 2 },
    { P_WEDGE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_War[] = { /*master of all weapons*/
    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE, P_MASTER, 0 },
    { P_AXE, P_MASTER, 0 },		{ P_PICK_AXE, P_MASTER, 0 },		
    { P_SHORT_SWORD, P_MASTER, 0 },	{ P_BROAD_SWORD, P_MASTER, 0 },
    { P_LONG_SWORD, P_MASTER, 0 },	{ P_TWO_HANDED_SWORD, P_MASTER, 0 },
    { P_SCIMITAR, P_MASTER, 0 },		{ P_SABER, P_MASTER, 0 },
    { P_CLUB, P_MASTER, 0 },                { P_PADDLE, P_MASTER, 0 },
    { P_MACE, P_MASTER, 0 },
    { P_MORNING_STAR, P_MASTER, 0 },	{ P_FLAIL, P_MASTER, 0 },
    { P_HAMMER, P_MASTER, 0 },		{ P_QUARTERSTAFF, P_MASTER, 0 },		{ P_POLEARMS, P_MASTER, 0 },
    { P_SPEAR, P_MASTER, 0 },		{ P_JAVELIN, P_MASTER, 0 },
    { P_TRIDENT, P_MASTER, 0 },		{ P_LANCE, P_MASTER, 0 },
    { P_BOW, P_MASTER, 0 },			{ P_CROSSBOW, P_MASTER, 0 },
    { P_SLING, P_MASTER, 0 },			{ P_DART, P_MASTER, 0 },
    { P_FIREARM, P_MASTER, 0 },
    { P_SHURIKEN, P_MASTER, 0 },			{ P_BOOMERANG, P_MASTER, 0 },
    { P_WHIP, P_MASTER, 0 },			{ P_UNICORN_HORN, P_MASTER, 0 },
    { P_LIGHTSABER, P_MASTER, 0 },
/* no magic skills at all*/
    { P_RIDING, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_ORB, P_MASTER, 0 },
    { P_CLAW, P_MASTER, 0 },
    { P_GRINDER, P_MASTER, 0 },
    { P_BOULDER_THROWING, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ord[] = { /*master of all weapons*/
    { P_DAGGER, P_GRAND_MASTER, 0 },		{ P_KNIFE, P_GRAND_MASTER, 0},
    { P_AXE, P_GRAND_MASTER, 0},		{ P_PICK_AXE, P_GRAND_MASTER, 0},		
    { P_SHORT_SWORD, P_GRAND_MASTER, 0},	{ P_BROAD_SWORD, P_GRAND_MASTER, 0},
    { P_LONG_SWORD, P_GRAND_MASTER, 0},	{ P_TWO_HANDED_SWORD, P_GRAND_MASTER, 0},
    { P_SCIMITAR, P_GRAND_MASTER, 0},		{ P_SABER, P_GRAND_MASTER, 0},
    { P_CLUB, P_GRAND_MASTER, 0},                { P_PADDLE, P_GRAND_MASTER, 0},
    { P_MACE, P_GRAND_MASTER, 0},
    { P_MORNING_STAR, P_GRAND_MASTER, 0},	{ P_FLAIL, P_GRAND_MASTER, 0},
    { P_HAMMER, P_GRAND_MASTER, 0},		{ P_QUARTERSTAFF, P_GRAND_MASTER, 0},		{ P_POLEARMS, P_GRAND_MASTER, 0},
    { P_SPEAR, P_GRAND_MASTER, 0},		{ P_JAVELIN, P_GRAND_MASTER, 0},
    { P_TRIDENT, P_GRAND_MASTER, 0},		{ P_LANCE, P_GRAND_MASTER, 0},
    { P_BOW, P_GRAND_MASTER, 0},			{ P_CROSSBOW, P_GRAND_MASTER, 0},
    { P_SLING, P_GRAND_MASTER, 0},			{ P_DART, P_GRAND_MASTER, 0},
    { P_FIREARM, P_GRAND_MASTER, 0},
    { P_SHURIKEN, P_GRAND_MASTER, 0},			{ P_BOOMERANG, P_GRAND_MASTER, 0},
    { P_WHIP, P_GRAND_MASTER, 0},			{ P_UNICORN_HORN, P_GRAND_MASTER, 0},
    { P_LIGHTSABER, P_GRAND_MASTER, 0},
    { P_RIDING, P_EXPERT, 0 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_GRAND_MASTER, 0 },
    { P_ATARU, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_VAAPAD, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },
    { P_GUN_CONTROL, P_GRAND_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },
    { P_CLAW, P_GRAND_MASTER, 0 },
    { P_GRINDER, P_GRAND_MASTER, 0 },
    { P_VENOM, P_GRAND_MASTER, 0 },
    { P_BOULDER_THROWING, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },

	{ P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Off[] = { /*master of all weapons*/
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },		{ P_PICK_AXE, P_EXPERT, 2 },		
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 0 },                { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },	{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_POLEARMS, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 0 },		{ P_LANCE, P_EXPERT, 0 },
    { P_BOW, P_EXPERT, 0 },			{ P_CROSSBOW, P_EXPERT, 0 },
    { P_SLING, P_EXPERT, 0 },			{ P_DART, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 0 },			{ P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },			{ P_UNICORN_HORN, P_EXPERT, 2 },
    { P_LIGHTSABER, P_EXPERT, 0 },
/* no magic skills at all*/
    { P_RIDING, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_JUYO, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mon[] = {
    { P_PADDLE, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },	{ P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_BOW, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_DART, P_EXPERT, 1 },    { P_CROSSBOW, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 1 },    { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_HIGH_HEELS, P_EXPERT, 1 },

    { P_ATTACK_SPELL, P_EXPERT, 1 },    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },	{ P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SORESU, P_MASTER, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 2 },

/*WAC - monks are good healers - expert healing - and expert protect*/
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Hba[] = { /* half-baked, weaker version of monk */
    { P_QUARTERSTAFF, P_EXPERT, 2 },	{ P_SPEAR, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 1 },            { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_CROSSBOW, P_EXPERT, 1 },		{ P_JAVELIN, P_EXPERT, 1 },

    { P_ATTACK_SPELL, P_EXPERT, 1 },    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sai[] = { /* saiyan */
    { P_PADDLE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_SPEAR, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_DART, P_EXPERT, 0 },    { P_CROSSBOW, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 0 },    { P_UNICORN_HORN, P_EXPERT, 2 },

    { P_HIGH_HEELS, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },	{ P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_SORESU, P_MASTER, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_DJEM_SO, P_GRAND_MASTER, 0 },
    { P_NIMAN, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Psi[] = { /* psion */
    { P_PADDLE, P_EXPERT, 2 },{ P_FIREARM, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },	{ P_SPEAR, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_BOW, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 0 },            { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },	{ P_BODY_SPELL, P_GRAND_MASTER, 0 },
    { P_MATTER_SPELL, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },

    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_TECHNIQUES, P_GRAND_MASTER, 0 },
    { P_IMPLANTS, P_GRAND_MASTER, 0 },
    { P_MAKASHI, P_EXPERT, 1 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_CHAOS_SPELL, P_EXPERT, 2 },

/*WAC - monks are good healers - expert healing - and expert protect*/
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Nob[] = {
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 1 },		{ P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 1 },	{ P_FLAIL, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 0 },		{ P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 2 },			{ P_CROSSBOW, P_EXPERT, 1 },
	{ P_FIREARM, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 2 },	{ P_HEALING_SPELL, P_EXPERT, 2 },
    { P_BODY_SPELL, P_EXPERT, 2 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },
    { P_MEMORIZATION, P_EXPERT, 1 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_N[] = { /* necromancer */
    { P_DAGGER, P_EXPERT, 0 },             { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },               { P_PICK_AXE, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 2 },              { P_MACE, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },       { P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 1 },               { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },             { P_SLING, P_EXPERT, 2 },
    { P_DART, P_EXPERT, 0 },               { P_SHURIKEN, P_EXPERT, 1 },
    { P_CROSSBOW, P_GRAND_MASTER, 0 },
    { P_FLAIL, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_VENOM, P_GRAND_MASTER, 0 },

    { P_ATTACK_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_GUN_CONTROL, P_EXPERT, 1 },

    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 2 },
    { P_CHAOS_SPELL, P_EXPERT, 2 },
    { P_MAKASHI, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 2 },

/*WAC-  expert of dark arts - attack spells,  skilled in matter
        -for fireball and cone of cold*/
    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static struct def_skill Skill_P[] = { /* priest */
	/* KMH -- Long sword for Sunsword */
	{ P_LONG_SWORD, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },               { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 0 },	{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 2 },
    { P_JAVELIN, P_EXPERT, 2 },		{ P_TRIDENT, P_EXPERT, 2 },
    { P_LANCE, P_EXPERT, 1 },		{ P_BOW, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 1 },		{ P_CROSSBOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 1 },		{ P_SHURIKEN, P_EXPERT, 1 },
    { P_BOOMERANG, P_EXPERT, 1 },		{ P_UNICORN_HORN, P_MASTER, 0 },

    /* [ALI] Depending on the spellbook which priests enter the dungeon with,
     * one of the maximum skill levels listed here will be raised by one.
     */
    { P_ATTACK_SPELL, P_EXPERT, 1 },        { P_HEALING_SPELL, P_MASTER, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },  { P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_SQUEAKING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_SHIELD, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_GRAND_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_WEDI, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_ORB, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },  /* the monk is added in slash */ 
    { P_NONE, 0, 0 }
};

static struct def_skill Skill_Che[] = {

	{ P_LONG_SWORD, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },               { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 2 },	{ P_FLAIL, P_EXPERT, 0 },
    { P_HAMMER, P_EXPERT, 0 },		{ P_QUARTERSTAFF, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_TRIDENT, P_EXPERT, 0 },
    { P_LANCE, P_EXPERT, 0 },		{ P_BOW, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 0 },		{ P_CROSSBOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 1 },		{ P_SHURIKEN, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 0 },		{ P_UNICORN_HORN, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 1 },

    /* [ALI] Depending on the spellbook which priests enter the dungeon with,
     * one of the maximum skill levels listed here will be raised by one.
     */
    { P_ATTACK_SPELL, P_EXPERT, 1 },        { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },   { P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },  { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_ORB, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },  /* the monk is added in slash */ 
    { P_RIDING, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_Pir[] = {
    { P_DAGGER, P_EXPERT, 0 },	{ P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 2 },	    { P_SHORT_SWORD, P_EXPERT, 1 },
	{ P_BROAD_SWORD, P_EXPERT, 0 },{ P_LONG_SWORD, P_EXPERT, 1 },
	{ P_SCIMITAR, P_GRAND_MASTER, 0 },	{ P_SABER, P_EXPERT, 0 },
	{ P_CLUB, P_EXPERT, 0 },		{ P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 0 },		{ P_SPEAR, P_EXPERT, 1 },
	{ P_JAVELIN, P_EXPERT, 1 },	{ P_TRIDENT, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },   { P_DART, P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 2 },   	{ P_UNICORN_HORN, P_EXPERT, 1 },
	{ P_FIREARM, P_MASTER, 0 },
	{ P_ATTACK_SPELL, P_EXPERT, 1 },{ P_DIVINATION_SPELL, P_EXPERT, 1 },
	{ P_ENCHANTMENT_SPELL, P_EXPERT, 1 },{ P_BODY_SPELL, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_ATARU, P_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 2 },

    { P_CHAOS_SPELL, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Div[] = {
    { P_TRIDENT, P_GRAND_MASTER, 0 },	{ P_KNIFE,  P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },	    { P_SHORT_SWORD, P_EXPERT, 1 },
	{ P_DAGGER, P_EXPERT, 0 },{ P_SPEAR, P_EXPERT, 0 },
	{ P_JAVELIN, P_EXPERT, 0 },	{ P_FIREARM, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },

	{ P_DIVINATION_SPELL, P_EXPERT, 0 }, { P_BODY_SPELL, P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_SQUEAKING, P_MASTER, 0 },

    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 2 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_ELEMENTAL_SPELL, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Kor[] = {
    { P_DAGGER, P_EXPERT, 0 },	{ P_LONG_SWORD,  P_EXPERT, 0 },
    { P_PICK_AXE, P_EXPERT, 0 },	    { P_SHORT_SWORD, P_EXPERT, 0 },
	{ P_DART, P_EXPERT, 0 },{ P_KNIFE, P_EXPERT, 0 },
	{ P_AXE, P_EXPERT, 2 },	{ P_POLEARMS, P_EXPERT, 0 },
	{ P_SPEAR, P_EXPERT, 0 },		{ P_TRIDENT, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_WHIP, P_EXPERT, 2 },
	{ P_SABER, P_EXPERT, 0 },	{ P_FIREARM, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },

	{ P_ATTACK_SPELL, P_EXPERT, 0 },{ P_DIVINATION_SPELL, P_EXPERT, 2 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_MASTER, 0 },
    { P_CONE_HEELS, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 2 },
    { P_WEDI, P_MASTER, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gla[] = {
    { P_SABER, P_EXPERT, 0 },	{ P_PICK_AXE,  P_EXPERT, 1 },
    { P_UNICORN_HORN, P_EXPERT, 1 },	    { P_CROSSBOW, P_EXPERT, 0 },
	{ P_KNIFE, P_EXPERT, 0 },{ P_JAVELIN, P_EXPERT, 0 },
	{ P_POLEARMS, P_EXPERT, 0 },	{ P_SCIMITAR, P_EXPERT, 0 },
	{ P_FLAIL, P_EXPERT, 2 },		{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },		{ P_MORNING_STAR, P_EXPERT, 0 },
	{ P_HAMMER, P_EXPERT, 0 },	{ P_LANCE, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },   { P_LONG_SWORD, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },   	{ P_DAGGER, P_EXPERT, 0 },
	{ P_SPEAR, P_EXPERT, 0 },	{ P_TRIDENT, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_GRAND_MASTER, 0 },

	{ P_ATTACK_SPELL, P_EXPERT, 2 },{ P_BODY_SPELL, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 1 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_SORESU, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_EXPERT, 1 },
    { P_JUYO, P_EXPERT, 0 },
    { P_VAAPAD, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gof[] = {
    { P_DAGGER, P_EXPERT, 2 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },    { P_FIREARM, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_GRAND_MASTER, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },  { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },  { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },
    { P_STILETTO_HEELS, P_GRAND_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 1 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_CHAOS_SPELL, P_EXPERT, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_VAAPAD, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_R[] = { /* rogue */
    { P_DAGGER, P_MASTER, 0 },		{ P_KNIFE,  P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 2 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_SABER, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 2 },              { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 2 },              { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 1 },               { P_HAMMER, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 1 },            { P_SPEAR, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_MASTER, 0 },		{ P_SHURIKEN, P_MASTER, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },        { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
/*WAC Left as is*/
    { P_RIDING, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },  { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 2 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_CLAW, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dun[] = { /* dunmer */
    { P_DAGGER, P_GRAND_MASTER, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 1 },              { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 2 },              { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },               { P_HAMMER, P_EXPERT, 2 },
    { P_POLEARMS, P_EXPERT, 0 },            { P_SPEAR, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 0 },
    { P_CROSSBOW, P_EXPERT, 2 },
    { P_DART, P_EXPERT, 0 },		{ P_SHURIKEN, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },        { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
/*WAC Left as is*/
    { P_RIDING, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 2 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },

    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },  { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Loc[] = { /* locksmith */
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 1 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_SABER, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 0 },              { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 2 },              { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },               { P_HAMMER, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 1 },            { P_SPEAR, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 0 },		{ P_SHURIKEN, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },        { P_BODY_SPELL, P_EXPERT, 1 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
/*WAC Left as is*/
    { P_RIDING, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_WEDI, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },  { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_Nin[] = { /* ninja */
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_SABER, P_EXPERT, 0 },
    { P_CLUB, P_EXPERT, 1 },              { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 1 },              { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 1 },               { P_HAMMER, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 1 },            { P_SPEAR, P_EXPERT, 2 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 0 },		{ P_SHURIKEN, P_GRAND_MASTER, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },        { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_HEALING_SPELL, P_EXPERT, 1 },    { P_PROTECTION_SPELL, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 0 },

/*WAC Left as is*/
    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_GRAND_MASTER, 0 },
    { P_BODY_ARMOR, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_SHII_CHO, P_EXPERT, 0 },
    { P_MAKASHI, P_EXPERT, 0 },
    { P_ATARU, P_EXPERT, 0 },
    { P_DJEM_SO, P_EXPERT, 0 },
    { P_JUYO, P_EXPERT, 0 },
    { P_CLAW, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },  { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ran[] = {
    { P_DAGGER, P_EXPERT, 0 },		 { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },	 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 1 },	 { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 2 },	 { P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 1 }, { P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },	 { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 1 },	 { P_BOW, P_MASTER, 0 },
    { P_SLING, P_EXPERT, 0 },	 { P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_EXPERT, 0 },	 { P_SHURIKEN, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 0 },	 { P_WHIP, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_RIDING, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },
    { P_SQUEAKING, P_EXPERT, 2 },
    { P_GUN_CONTROL, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 2 },

    { P_HIGH_HEELS, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Elp[] = {
    { P_DAGGER, P_EXPERT, 0 },		 { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },	 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 1 },	 { P_MORNING_STAR, P_EXPERT, 1 },

    { P_BROAD_SWORD, P_EXPERT, 2 },	 { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },	 { P_SABER, P_EXPERT, 2 },

    { P_FLAIL, P_EXPERT, 2 },	 { P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 1 }, { P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },	 { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 1 },	 { P_BOW, P_GRAND_MASTER, 0 },
    { P_SLING, P_EXPERT, 0 },	 { P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_EXPERT, 0 },	 { P_SHURIKEN, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 0 },	 { P_WHIP, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_RIDING, P_EXPERT, 1 },
    { P_GENERAL_COMBAT, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },

    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mid[] = { /* midget, aka dwarf role */
    { P_DAGGER, P_EXPERT, 2 },		 { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_MASTER, 0 },	 { P_PICK_AXE, P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD, P_EXPERT, 2 },

    { P_BROAD_SWORD, P_EXPERT, 2 },	 { P_TWO_HANDED_SWORD, P_EXPERT, 2 },
	{ P_PADDLE, P_EXPERT, 0 },	 	 { P_MORNING_STAR, P_EXPERT, 0 },

    { P_FLAIL, P_EXPERT, 0 },	 { P_HAMMER, P_MASTER, 0 },
    { P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 0 },
    { P_ATTACK_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_RIDING, P_EXPERT, 1 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_GRINDER, P_EXPERT, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_GRAND_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_WEDI, P_GRAND_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Rin[] = { /* ringseeker, aka hobbit role */
	{ P_DAGGER, P_EXPERT, 2 },	{ P_SHORT_SWORD, P_MASTER, 0 },
	{ P_SCIMITAR, P_EXPERT, 0 },		{ P_SLING, P_GRAND_MASTER, 0 },	
    { P_HEALING_SPELL, P_EXPERT, 0 },    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },    { P_PROTECTION_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_EXPERT, 2 },    { P_MATTER_SPELL, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 2 },

    { P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },
    { P_WEDI, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gol[] = { /* goldminer, aka gnome role */
	{ P_PICK_AXE, P_GRAND_MASTER, 0 },	{ P_CLUB, P_MASTER, 0 },
	{ P_DAGGER, P_EXPERT, 1 },	{ P_CROSSBOW, P_MASTER, 0 },
	{ P_MATTER_SPELL, P_EXPERT, 2 },	

    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_WEDI, P_MASTER, 0 },
    { P_GRINDER, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Bos[] = {
    { P_DAGGER, P_EXPERT, 2 },		 { P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 0 },	 { P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	 { P_MORNING_STAR, P_EXPERT, 2 },

    { P_BROAD_SWORD, P_EXPERT, 2 },	 { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },	 { P_SABER, P_EXPERT, 2 },

    { P_FLAIL, P_EXPERT, 2 },	 { P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 1 }, { P_POLEARMS, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },	 { P_JAVELIN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 2 },	 { P_BOW, P_GRAND_MASTER, 0 },
    { P_SLING, P_EXPERT, 0 },	 { P_CROSSBOW, P_EXPERT, 0 },
    { P_DART, P_EXPERT, 0 },	 { P_SHURIKEN, P_EXPERT, 2 },
    { P_BOOMERANG, P_EXPERT, 0 },	 { P_WHIP, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },
    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 1 },
    { P_SQUEAKING, P_MASTER, 0 },

    { P_ELEMENTAL_SPELL, P_EXPERT, 2 },

    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Mus[] = { /* musician */
    { P_DAGGER, P_EXPERT, 2 },		 { P_KNIFE,  P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 1 },	 { P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	 { P_MORNING_STAR, P_EXPERT, 2 },

    { P_BROAD_SWORD, P_EXPERT, 1 },	 { P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 1 },	 { P_SABER, P_EXPERT, 2 },

    { P_FLAIL, P_EXPERT, 0 },	 { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 2 }, { P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },	 { P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },	 { P_BOW, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 0 },	 { P_CROSSBOW, P_EXPERT, 2 },
    { P_DART, P_EXPERT, 2 },	 { P_SHURIKEN, P_EXPERT, 1 },
    { P_BOOMERANG, P_EXPERT, 0 },	 { P_WHIP, P_EXPERT, 0 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_UNICORN_HORN, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_RIDING, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_GRAND_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },

    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_S[] = { /* samurai */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_SHORT_SWORD, P_GRAND_MASTER, 0 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_SABER, P_EXPERT, 1 },
    { P_PADDLE, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 0 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },      { P_BODY_SPELL, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 1 },

/* WAC - removed the attack spells, replace with body.  clairvoyance, meditate*/
    { P_RIDING, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Gre[] = { /* grenadonin */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_SHORT_SWORD, P_GRAND_MASTER, 0 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 1 },		{ P_SABER, P_EXPERT, 1 },
    { P_PADDLE, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 2 },		{ P_QUARTERSTAFF, P_EXPERT, 1 },
    { P_POLEARMS, P_EXPERT, 2 },		{ P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 0 },		{ P_SHURIKEN, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 2 },      { P_BODY_SPELL, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 1 },	{ P_FIREARM, P_GRAND_MASTER, 0 },

/* WAC - removed the attack spells, replace with body.  clairvoyance, meditate*/
    { P_RIDING, P_EXPERT, 2 },
    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_GRAND_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ama[] = {
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 0 },
	{ P_AXE,  P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 0 },
    { P_LONG_SWORD, P_EXPERT, 0 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 0 },
    { P_SCIMITAR, P_EXPERT, 0 },		{ P_SABER, P_EXPERT, 0 },
    { P_PADDLE, P_EXPERT, 2 },    { P_CLUB, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 0 },    { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },		{ P_HAMMER, P_EXPERT, 0 },		
    { P_POLEARMS, P_EXPERT, 0 },		{ P_SPEAR, P_MASTER, 0 },
    { P_JAVELIN, P_GRAND_MASTER, 0 },		{ P_LANCE, P_MASTER, 0 },{ P_TRIDENT, P_MASTER, 0 },
    { P_BOW, P_MASTER, 0 },		{ P_SLING, P_EXPERT, 1 },{ P_FIREARM, P_MASTER, 0 },
	{ P_CROSSBOW, P_EXPERT, 0 },{ P_DART, P_EXPERT, 0 },
	{ P_WHIP,  P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 1 },
    { P_SQUEAKING, P_MASTER, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_GRAND_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 1 },

    { P_PROTECTION_SPELL, P_EXPERT, 2 },      { P_BODY_SPELL, P_EXPERT, 0 },{ P_ATTACK_SPELL, P_EXPERT, 1 },

    { P_RIDING, P_EXPERT, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Drd[] = { /* druid */
    { P_CLUB, P_EXPERT, 1 },		{ P_AXE,  P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },	{ P_BOW, P_MASTER, 0 },
    { P_POLEARMS, P_EXPERT, 0 },		{ P_FIREARM,  P_EXPERT, 2 },
    { P_CROSSBOW, P_EXPERT, 2 },		{ P_UNICORN_HORN,  P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },	    { P_HEALING_SPELL, P_EXPERT, 2 },	
    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_MATTER_SPELL, P_MASTER, 0 },
    { P_ENCHANTMENT_SPELL, P_GRAND_MASTER, 0 },	    { P_PROTECTION_SPELL, P_EXPERT, 1 },	
    { P_VENOM, P_EXPERT, 2 },

    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 1 },
    { P_SYMBIOSIS, P_EXPERT, 0 },
    { P_GRINDER, P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 1 },

    { P_ELEMENTAL_SPELL, P_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Ota[] = {

	{ P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_SCIMITAR, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_EXPERT, 2 },	{ P_TWO_HANDED_SWORD, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 0 },	{ P_MACE, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },	{ P_AXE, P_EXPERT, 1 },
    { P_PICK_AXE, P_EXPERT, 1 },	{ P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 2 },	{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },	{ P_BOW, P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 0 },	{ P_CROSSBOW, P_EXPERT, 1 },
    { P_DAGGER, P_EXPERT, 2 },	{ P_SLING, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 0 },	{ P_HAMMER, P_EXPERT, 1 },
    { P_UNICORN_HORN, P_EXPERT, 0 },	{ P_LONG_SWORD, P_MASTER, 0 },
    { P_QUARTERSTAFF, P_MASTER, 0 },	{ P_SHURIKEN, P_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_SEXY_FLATS, P_EXPERT, 0 },

    { P_DIVINATION_SPELL, P_EXPERT, 2 },	{ P_MATTER_SPELL, P_EXPERT, 2 },
	{ P_BODY_SPELL, P_EXPERT, 2 },	{ P_FIREARM, P_EXPERT, 2 },
	{ P_LIGHTSABER, P_MASTER, 0 },
    { P_SHII_CHO, P_EXPERT, 2 },
    { P_MAKASHI, P_EXPERT, 1 },
    { P_SORESU, P_EXPERT, 1 },
    { P_ATARU, P_EXPERT, 1 },
    { P_SHIEN, P_EXPERT, 2 },
    { P_DJEM_SO, P_EXPERT, 2 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_JUYO, P_EXPERT, 1 },
    { P_VAAPAD, P_EXPERT, 1 },
    { P_WEDI, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_EXPERT, 2 },

    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 1 },
    { P_SEARCHING, P_MASTER, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_EXPERT, 2 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_T[] = { /* tourist */
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 1 },			{ P_PICK_AXE, P_EXPERT, 1 },
    { P_SHORT_SWORD, P_EXPERT, 0 },	{ P_BROAD_SWORD, P_EXPERT, 1 },
    { P_LONG_SWORD, P_EXPERT, 1 },		{ P_TWO_HANDED_SWORD, P_EXPERT, 1 },
    { P_SCIMITAR, P_EXPERT, 2 },		{ P_SABER, P_EXPERT, 2 },
    { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 1 },		{ P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 1 },		{ P_HAMMER, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 1 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },			{ P_SLING, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },		{ P_DART, P_EXPERT, 0 },
    { P_SHURIKEN, P_EXPERT, 1 },		{ P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },		{ P_UNICORN_HORN, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_GRAND_MASTER, 0 },	{ P_ENCHANTMENT_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_EXPERT, 2 },
/*WAC left alone*/
    { P_RIDING, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_SQUEAKING, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 1 },
    { P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },

    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 }, { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_U[] = { /* undead slayer */
/*WAC
 * -made dagger skill expert too,  since it's a starting weapon
 * -made spear skill Expert rather than Skilled
 *      Slayer artifact is a spear,  after all
 * -made crossbow skill Expert - Dracula movies
 * -changed bare handed basic to martial arts master-Buffy the Vampire Slayer
 * -Added whip Expert - Castlevania
 * -made club, flail, mace, morning star, hammer, quarterstaff Skilled
        from Expert to balance
 * -removed Trident skill - from Skilled to Restricted
 * -removed Lance skill - from Basic to Restricted
 */
    { P_DAGGER, P_EXPERT, 0 },             { P_LONG_SWORD, P_EXPERT, 2 },
    { P_CLUB, P_EXPERT, 2 },              { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 2 },              { P_MORNING_STAR, P_EXPERT, 2 },
    { P_FLAIL, P_EXPERT, 2 },             { P_HAMMER, P_EXPERT, 2 },
    { P_QUARTERSTAFF, P_EXPERT, 2 },      { P_POLEARMS, P_EXPERT, 2 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 1 },	{ P_SCIMITAR, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 0 },              { P_JAVELIN, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 1 },			        { P_SLING, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 0 },
    { P_CROSSBOW, P_MASTER, 0 },           { P_DART, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 1 },		{ P_BOOMERANG, P_EXPERT, 1 },
    { P_WHIP, P_MASTER, 0 },               { P_UNICORN_HORN, P_EXPERT, 2 },
    { P_TRIDENT, P_EXPERT, 2 },      { P_LANCE, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 1 },

    { P_PROTECTION_SPELL, P_EXPERT, 2 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 1 },    { P_ATTACK_SPELL, P_EXPERT, 1 },
/*WAC - added PROTECTION spells,  body spells as skilled, basic
        matter spells - for the fire vs undead*/
    { P_RIDING, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_TECHNIQUES, P_EXPERT, 1 },

    { P_OCCULT_SPELL, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Unb[] = { /* unbeliever */
    { P_DAGGER, P_EXPERT, 0 },             { P_LONG_SWORD, P_EXPERT, 0 },
    { P_SHORT_SWORD, P_EXPERT, 0 },         { P_BROAD_SWORD, P_MASTER, 0 },
    { P_CLUB, P_EXPERT, 0 },              { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 0 },              { P_MORNING_STAR, P_EXPERT, 0 },
    { P_FLAIL, P_EXPERT, 0 },             { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },      { P_POLEARMS, P_EXPERT, 0 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },	{ P_SCIMITAR, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },              { P_JAVELIN, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 0 },			        { P_SLING, P_EXPERT, 0 },
    { P_FIREARM, P_MASTER, 0 },
    { P_CROSSBOW, P_EXPERT, 0 },           { P_DART, P_EXPERT, 1 },
    { P_SHURIKEN, P_EXPERT, 1 },		{ P_BOOMERANG, P_EXPERT, 0 },
    { P_WHIP, P_EXPERT, 0 },               { P_UNICORN_HORN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 0 },      { P_LANCE, P_EXPERT, 2 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },

    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_EXPERT, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_MASTER, 0 },
    { P_WEDI, P_EXPERT, 2 },
    { P_CLAW, P_EXPERT, 1 },
    { P_GRINDER, P_EXPERT, 1 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },    { P_NONE, 0, 0 }
};


static const struct def_skill Skill_Unt[] = { /* undertaker */
    { P_DAGGER, P_EXPERT, 2 },             { P_LONG_SWORD, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 2 },              { P_PADDLE, P_EXPERT, 0 },
    { P_MACE, P_EXPERT, 2 },              { P_MORNING_STAR, P_EXPERT, 1 },
    { P_FLAIL, P_EXPERT, 0 },             { P_HAMMER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },      { P_POLEARMS, P_EXPERT, 1 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 1 },	{ P_SCIMITAR, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },              { P_JAVELIN, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },			        { P_SLING, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_VENOM, P_EXPERT, 1 },
    { P_BOULDER_THROWING, P_EXPERT, 2 },

    { P_PICK_AXE, P_MASTER, 0 }, /* thanks 5lo for reminding me that undertakers are supposed to have that skill --Amy */

    { P_FIREARM, P_EXPERT, 1 },
    { P_CROSSBOW, P_EXPERT, 1 },           { P_DART, P_EXPERT, 2 },
    { P_SHURIKEN, P_EXPERT, 1 },		{ P_BOOMERANG, P_EXPERT, 2 },
    { P_WHIP, P_EXPERT, 0 },               { P_UNICORN_HORN, P_EXPERT, 0 },
    { P_TRIDENT, P_EXPERT, 1 },      { P_LANCE, P_EXPERT, 1 },

    { P_PROTECTION_SPELL, P_EXPERT, 0 },    { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_GRAND_MASTER, 0 },    { P_ATTACK_SPELL, P_EXPERT, 1 },
    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 },    { P_DIVINATION_SPELL, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 1 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_ATARU, P_EXPERT, 1 },
    { P_NIMAN, P_EXPERT, 2 },
    { P_CONE_HEELS, P_EXPERT, 0 },

    { P_SHIELD, P_EXPERT, 1 },
    { P_BODY_ARMOR, P_EXPERT, 1 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_TECHNIQUES, P_EXPERT, 2 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_GRINDER, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_MARTIAL_ARTS, P_GRAND_MASTER, 0 },    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_V[] = { /* valkyrie */
    { P_DAGGER, P_EXPERT, 0 },		{ P_AXE, P_EXPERT, 0 },
    { P_PICK_AXE, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 2 },
    { P_BROAD_SWORD, P_EXPERT, 2 },	{ P_LONG_SWORD, P_EXPERT, 0 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },	{ P_SCIMITAR, P_EXPERT, 1 },
    { P_SABER, P_EXPERT, 1 },		{ P_HAMMER, P_MASTER, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_LANCE, P_EXPERT, 2 },
    { P_SLING, P_EXPERT, 1 },
    { P_BOW, P_EXPERT, 1 },    { P_CROSSBOW, P_EXPERT, 1 },
    { P_HIGH_HEELS, P_EXPERT, 1 },
    { P_SEXY_FLATS, P_MASTER, 0 },
    { P_BOULDER_THROWING, P_MASTER, 0 },

    { P_BODY_SPELL, P_EXPERT, 1 },          { P_MATTER_SPELL, P_EXPERT, 0 },
/*  replace attack spell with matter spell - cone of cold, lightning
 *  Boosted to Expert
 */
    { P_RIDING, P_EXPERT, 2 },

    { P_GENERAL_COMBAT, P_EXPERT, 0 },
    { P_SHIELD, P_MASTER, 0 },
    { P_BODY_ARMOR, P_EXPERT, 0 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },
    { P_TECHNIQUES, P_MASTER, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Van[] = { /* vanilla valk, other version of valkyrie */
    { P_SCIMITAR, P_EXPERT, 0 },	{ P_SABER, P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 1 },	{ P_TRIDENT, P_EXPERT, 1 },
    { P_SLING, P_EXPERT, 1 },	{ P_ATTACK_SPELL, P_EXPERT, 1 },
    { P_BODY_SPELL, P_EXPERT, 1 },	{ P_PICK_AXE, P_EXPERT, 2 },
    { P_SHORT_SWORD, P_EXPERT, 2 },	{ P_BROAD_SWORD, P_EXPERT, 2 },
    { P_POLEARMS, P_EXPERT, 2 },	{ P_SPEAR, P_EXPERT, 2 },
    { P_LANCE, P_EXPERT, 2 },	{ P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },
    { P_RIDING, P_EXPERT, 2 },	{ P_DAGGER, P_EXPERT, 0 },
    { P_AXE, P_EXPERT, 0 },	{ P_LONG_SWORD, P_EXPERT, 0 },
    { P_TWO_HANDED_SWORD, P_EXPERT, 0 },	{ P_HAMMER, P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Sag[] = {

    { P_DAGGER, P_EXPERT, 1 },		{ P_CLUB,  P_EXPERT, 0 },
    { P_DART, P_EXPERT, 2 },		{ P_CROSSBOW, P_EXPERT, 1 },

    { P_QUARTERSTAFF, P_EXPERT, 0 },		{ P_HAMMER,  P_EXPERT, 0 },
    { P_UNICORN_HORN, P_EXPERT, 0 },		{ P_MACE, P_EXPERT, 0 },
    { P_MORNING_STAR, P_EXPERT, 2 },		{ P_FLAIL,  P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_EXPERT, 0 },	{ P_HEALING_SPELL, P_EXPERT, 0 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },  { P_ENCHANTMENT_SPELL, P_EXPERT, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },  { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_EXPERT, 0 },
    { P_SHII_CHO, P_GRAND_MASTER, 0 },
    { P_SORESU, P_GRAND_MASTER, 0 },
    { P_SHIEN, P_EXPERT, 2 },

    { P_SHIELD, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_TECHNIQUES, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_ORB, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_W[] = { /* wizard */
    { P_DAGGER, P_EXPERT, 0 },		{ P_KNIFE,  P_EXPERT, 2 },
    { P_AXE, P_EXPERT, 2 },		{ P_SHORT_SWORD, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 2 },              { P_PADDLE, P_EXPERT, 1 },
    { P_MACE, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_MASTER, 0 },	{ P_POLEARMS, P_EXPERT, 2 },
    { P_SPEAR, P_EXPERT, 1 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 2 },
    { P_DART, P_EXPERT, 0 },		{ P_SHURIKEN, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 1 },

    { P_ATTACK_SPELL, P_GRAND_MASTER, 0 },	{ P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 2 },  { P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },  { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 2 },
/*      added matter spell skilled,  as fireball and cone of cold are
        matter spells, but now specialty of F/I Mages*/
    { P_RIDING, P_EXPERT, 1 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },

    { P_OCCULT_SPELL, P_EXPERT, 2 },

    { P_DEVICES, P_EXPERT, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 1 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Alt[] = { /* altmer */
    { P_DAGGER, P_EXPERT, 1 },		{ P_KNIFE,  P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 1 },		{ P_SHORT_SWORD, P_EXPERT, 1 },
    { P_CLUB, P_EXPERT, 1 },              { P_PADDLE, P_EXPERT, 2 },
    { P_MACE, P_EXPERT, 1 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },	{ P_POLEARMS, P_EXPERT, 1 },
    { P_SPEAR, P_EXPERT, 2 },		{ P_JAVELIN, P_EXPERT, 1 },
    { P_TRIDENT, P_EXPERT, 1 },		{ P_SLING, P_EXPERT, 1 },
    { P_DART, P_EXPERT, 1 },		{ P_SHURIKEN, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 1 },

    { P_ATTACK_SPELL, P_GRAND_MASTER, 0 },	{ P_HEALING_SPELL, P_GRAND_MASTER, 0},
    { P_DIVINATION_SPELL, P_GRAND_MASTER, 0},  { P_ENCHANTMENT_SPELL, P_GRAND_MASTER, 0},
    { P_PROTECTION_SPELL, P_GRAND_MASTER, 0},  { P_BODY_SPELL, P_GRAND_MASTER, 0},
    { P_MATTER_SPELL, P_GRAND_MASTER, 0},
/*      added matter spell skilled,  as fireball and cone of cold are
        matter spells, but now specialty of F/I Mages*/
    { P_RIDING, P_EXPERT, 2 },
    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_GRAND_MASTER, 0 },
    { P_CHAOS_SPELL, P_GRAND_MASTER, 0 },
    { P_MEMORIZATION, P_GRAND_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },

    { P_BARE_HANDED_COMBAT, P_EXPERT, 2 },
    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Pok[] = { /* pokemon */

    { P_ATTACK_SPELL, P_MASTER, 0 },	{ P_HEALING_SPELL, P_MASTER, 0 },
    { P_DIVINATION_SPELL, P_MASTER, 0 },  { P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_MASTER, 0 },  { P_BODY_SPELL, P_MASTER, 0 },
    { P_MATTER_SPELL, P_MASTER, 0 },
/*      added matter spell skilled,  as fireball and cone of cold are
        matter spells, but now specialty of F/I Mages*/
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_BARE_HANDED_COMBAT, P_EXPERT, 0 },
    { P_HIGH_HEELS, P_EXPERT, 0 },
    { P_SEXY_FLATS, P_EXPERT, 0 },
    { P_MEMORIZATION, P_MASTER, 0 },
    { P_SQUEAKING, P_EXPERT, 0 },
    { P_GUN_CONTROL, P_EXPERT, 2 },
    { P_SYMBIOSIS, P_GRAND_MASTER, 0 },

    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_POLYMORPHING, P_GRAND_MASTER, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 2 },
    { P_SPIRITUALITY, P_EXPERT, 0 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },
    { P_IMPLANTS, P_MASTER, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_MAKASHI, P_MASTER, 0 },
    { P_SORESU, P_MASTER, 0 },
    { P_ATARU, P_MASTER, 0 },
    { P_SHIEN, P_MASTER, 0 },
    { P_DJEM_SO, P_MASTER, 0 },
    { P_NIMAN, P_MASTER, 0 },
    { P_JUYO, P_MASTER, 0 },
    { P_VAAPAD, P_MASTER, 0 },
    { P_WEDI, P_MASTER, 0 },
    { P_STILETTO_HEELS, P_MASTER, 0 },
    { P_CONE_HEELS, P_MASTER, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },
    { P_WEDGE_HEELS, P_MASTER, 0 },

    { P_OCCULT_SPELL, P_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_MASTER, 0 },
    { P_CHAOS_SPELL, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Zoo[] = {

    { P_WHIP, P_EXPERT, 0 },
    { P_SPEAR, P_EXPERT, 0 },    { P_JAVELIN, P_EXPERT, 0 },
    { P_POLEARMS, P_EXPERT, 0 },    { P_FIREARM, P_EXPERT, 2 },
    { P_BOW, P_EXPERT, 1 },    { P_CROSSBOW, P_EXPERT, 1 },
    { P_BOOMERANG, P_EXPERT, 2 },

    { P_ATTACK_SPELL, P_EXPERT, 1 },	{ P_HEALING_SPELL, P_EXPERT, 2 },
    { P_DIVINATION_SPELL, P_EXPERT, 1 },  
    { P_PROTECTION_SPELL, P_EXPERT, 2 },  { P_BODY_SPELL, P_EXPERT, 2 },
    { P_MATTER_SPELL, P_EXPERT, 1 },
/*      added matter spell skilled,  as fireball and cone of cold are
        matter spells, but now specialty of F/I Mages*/
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT, P_EXPERT, 2 },

    { P_POLYMORPHING, P_EXPERT, 1 },
    { P_DEVICES, P_MASTER, 0 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_PETKEEPING, P_GRAND_MASTER, 0 },
    { P_MISSILE_WEAPONS, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Cli[] = {

    { P_DAGGER,  P_MASTER, 0 },	{ P_KNIFE,  P_GRAND_MASTER, 0 },
    { P_SHORT_SWORD,  P_EXPERT, 1 },	{ P_SCIMITAR,  P_EXPERT, 2 },
    { P_SABER,  P_EXPERT, 1 },	{ P_PADDLE,  P_EXPERT, 0 },
    { P_SPEAR,  P_EXPERT, 0 },	{ P_JAVELIN,  P_MASTER, 0 },
    { P_LANCE,  P_EXPERT, 0 },	{ P_FIREARM,  P_EXPERT, 0 },
    { P_CROSSBOW,  P_EXPERT, 0 },	{ P_DART,  P_MASTER, 0 },
    { P_SHURIKEN,  P_MASTER, 0 },	{ P_WHIP,  P_MASTER, 0 },
    { P_UNICORN_HORN,  P_GRAND_MASTER, 0 },	{ P_LIGHTSABER,  P_EXPERT, 2 },
    { P_ATTACK_SPELL,  P_EXPERT, 2 },	{ P_HEALING_SPELL,  P_MASTER, 0 },
    { P_ENCHANTMENT_SPELL,  P_EXPERT, 0 },	{ P_PROTECTION_SPELL,  P_MASTER, 0 },
    { P_BODY_SPELL,  P_GRAND_MASTER, 0 },	{ P_CHAOS_SPELL,  P_EXPERT, 0 },
    { P_BARE_HANDED_COMBAT,  P_GRAND_MASTER, 0 },	{ P_HIGH_HEELS,  P_MASTER, 0 },
    { P_GENERAL_COMBAT,  P_EXPERT, 2 },	{ P_DEVICES,  P_EXPERT, 2 },
    { P_SEARCHING,  P_EXPERT, 1 },	{ P_SPIRITUALITY,  P_EXPERT, 2 },
    { P_TECHNIQUES,  P_EXPERT, 0 },	{ P_MEMORIZATION,  P_EXPERT, 1 },
    { P_SQUEAKING,  P_GRAND_MASTER, 0 },	{ P_SHIEN,  P_EXPERT, 1 },
    { P_DJEM_SO,  P_EXPERT, 2 },	{ P_JUYO,  P_MASTER, 0 },
    { P_TWO_WEAPON_COMBAT,  P_EXPERT, 2 },	{ P_RIDING,  P_MASTER, 0 },
    { P_VENOM, P_EXPERT, 0 },
    { P_CONE_HEELS, P_EXPERT, 0 },
    { P_BLOCK_HEELS, P_MASTER, 0 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Wom[] = {

    { P_SABER,  P_EXPERT, 2 },	{ P_CLUB,  P_EXPERT, 0 },
    { P_PADDLE,  P_MASTER, 0 },	{ P_FLAIL,  P_EXPERT, 0 },
    { P_ORB,  P_MASTER, 0 },	{ P_TRIDENT,  P_EXPERT, 1 },
    { P_SLING,  P_GRAND_MASTER, 0 },	{ P_DART,  P_MASTER, 0 },
    { P_WHIP,  P_GRAND_MASTER, 0 },	{ P_LIGHTSABER,  P_EXPERT, 2 },
    { P_BODY_SPELL,  P_MASTER, 0 },	{ P_BARE_HANDED_COMBAT,  P_EXPERT, 2 },
    { P_BODY_ARMOR,  P_EXPERT, 1 },	{ P_POLYMORPHING,  P_EXPERT, 2 },
    { P_SEARCHING,  P_EXPERT, 1 },	{ P_PETKEEPING,  P_MASTER, 0 },
    { P_SEXY_FLATS,  P_MASTER, 0 },	{ P_SHII_CHO,  P_EXPERT, 2 },
    { P_RIDING,  P_EXPERT, 0 },
    { P_WEDGE_HEELS, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Dea[] = {
    { P_KNIFE,  P_EXPERT, 0 },
    { P_QUARTERSTAFF, P_EXPERT, 0 },	
    { P_TRIDENT,  P_EXPERT, 2 },
    { P_DART,  P_EXPERT, 2 },     { P_SHURIKEN,  P_EXPERT, 1 },
    { P_WHIP,  P_EXPERT, 0 },     { P_UNICORN_HORN,  P_EXPERT, 0 },
    { P_HIGH_HEELS, P_MASTER, 0 },
    { P_VENOM, P_MASTER, 0 },

    { P_GENERAL_COMBAT, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_EXPERT, 2 },
    { P_POLYMORPHING, P_EXPERT, 0 },
    { P_DEVICES, P_EXPERT, 0 },
    { P_SEARCHING, P_EXPERT, 0 },
    { P_SPIRITUALITY, P_EXPERT, 2 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_MEMORIZATION, P_EXPERT, 0 },
    { P_STILETTO_HEELS, P_EXPERT, 0 },

    { P_FIREARM, P_EXPERT, 0 },
    { P_SHII_CHO, P_MASTER, 0 },
    { P_DJEM_SO, P_EXPERT, 1 },
    { P_NIMAN, P_GRAND_MASTER, 0 },
    { P_SYMBIOSIS, P_EXPERT, 0 },

    { P_ATTACK_SPELL, P_GRAND_MASTER, 0 },	{ P_HEALING_SPELL, P_EXPERT, 1 },
    { P_DIVINATION_SPELL, P_EXPERT, 0 },  { P_ENCHANTMENT_SPELL, P_MASTER, 0 },
    { P_PROTECTION_SPELL, P_EXPERT, 0 },  { P_BODY_SPELL, P_EXPERT, 0 },
    { P_MATTER_SPELL, P_MASTER, 0 },
/*      added matter spell skilled,  as fireball and cone of cold are
        matter spells, but now specialty of F/I Mages*/
    { P_RIDING, P_EXPERT, 2 },
    { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_OCCULT_SPELL, P_GRAND_MASTER, 0 },
    { P_ELEMENTAL_SPELL, P_EXPERT, 0 },
    { P_CHAOS_SPELL, P_GRAND_MASTER, 0 },
    { P_ORB, P_GRAND_MASTER, 0 },
    { P_CLAW, P_EXPERT, 2 },
    { P_GRINDER, P_EXPERT, 1 },

    { P_NONE, 0, 0 }
};

static const struct def_skill Skill_Y[] = { /* yeoman */
    { P_DAGGER, P_EXPERT, 2 },            { P_KNIFE, P_EXPERT, 1 },
    { P_AXE, P_EXPERT, 2 },               { P_SHORT_SWORD, P_EXPERT, 0 },
    { P_BROAD_SWORD, P_EXPERT, 1 },         { P_LONG_SWORD, P_EXPERT, 2 },
    { P_SABER, P_EXPERT, 2 },             { P_PADDLE, P_EXPERT, 2 },
    { P_HAMMER, P_EXPERT, 1 },              { P_QUARTERSTAFF, P_EXPERT, 2 },
    { P_POLEARMS, P_GRAND_MASTER, 0 },           { P_SPEAR, P_EXPERT, 1 },
    { P_JAVELIN, P_EXPERT, 2 },           { P_TRIDENT, P_EXPERT, 2 },
    { P_LANCE, P_EXPERT, 2 },             { P_BOW, P_EXPERT, 0 },
    { P_SLING, P_EXPERT, 1 },
    { P_FIREARM, P_EXPERT, 2 },
    { P_CROSSBOW, P_EXPERT, 2 },          { P_DART, P_EXPERT, 1 },
    { P_WHIP, P_EXPERT, 1 },                { P_UNICORN_HORN, P_EXPERT, 1 },

    { P_ENCHANTMENT_SPELL, P_EXPERT, 2 }, { P_PROTECTION_SPELL, P_EXPERT, 2 },
    { P_BODY_SPELL, P_EXPERT, 1 },
    { P_RIDING, P_GRAND_MASTER, 0 },
    { P_HIGH_HEELS, P_EXPERT, 2 },
    { P_MEMORIZATION, P_EXPERT, 1 },

    { P_GENERAL_COMBAT, P_MASTER, 0 },
    { P_SHIELD, P_EXPERT, 2 },
    { P_BODY_ARMOR, P_EXPERT, 2 },
    { P_TWO_HANDED_WEAPON, P_MASTER, 0 },
    { P_POLYMORPHING, P_EXPERT, 2 },
    { P_DEVICES, P_EXPERT, 2 },
    { P_SEARCHING, P_EXPERT, 1 },
    { P_SPIRITUALITY, P_MASTER, 0 },
    { P_PETKEEPING, P_EXPERT, 1 },
    { P_MISSILE_WEAPONS, P_MASTER, 0 },
    { P_TECHNIQUES, P_EXPERT, 0 },

    { P_TWO_WEAPON_COMBAT, P_EXPERT, 1 }, { P_MARTIAL_ARTS, P_MASTER, 0 },
    { P_NONE, 0, 0 }
};

STATIC_OVL void
knows_object(obj)
register int obj;
{
	if ((obj == SPE_BEAMSWORD) || (obj == SPE_DRAINING_ARROW) || (obj == SPE_MENSTRUATION) || (obj == SPE_BLADE_ANGER)) return;

	discover_object(obj,TRUE,FALSE);
	objects[obj].oc_pre_discovered = 1;	/* not a "discovery" */
}

/* Know ordinary (non-magical) objects of a certain class,
 * like all gems except the loadstone and luckstone.
 */
STATIC_OVL void
knows_class(sym)
register char sym;
{
	register int ct;
	for (ct = 1; ct < NUM_OBJECTS; ct++)
		if (objects[ct].oc_class == sym && !objects[ct].oc_magic)
			knows_object(ct);
}

/* Know all objects of a certain class, like all potions (healer). */
STATIC_OVL void
knows_classX(sym)
register char sym;
{
	register int ct;
	for (ct = 1; ct < NUM_OBJECTS; ct++)
		if (objects[ct].oc_class == sym)
			knows_object(ct);
}

/* [ALI] Raise one spell skill by one level. Priorities:
 * - The skill for the chosen spellbook if not already expert.
 * - A skill currently at skilled level.
 * - A skill currently at basic level.
 * Where more than one skill is possible at a priority level, choose one
 * at random.
 *
 * The idea is that where a role may be given spellbooks in which the
 * role is normally at basic level, then the Skill array can be tweaked
 * to reduce one skill from expert to skilled. After choosing the
 * spellbook we can then dynamically raise one skill which will either be
 * the one for the spellbook if that is currently basic (and so avoid the
 * warning message from skill_init) or raise the tweaked skill to expert.
 *
 * Currently only used by priests.
 */

static void
spellbook_skill_raise(class_skill, spellbook)
register struct def_skill *class_skill;
int spellbook;
{
    register int i, j;
    j = spell_skilltype(spellbook);
    for(i = 0; class_skill[i].skill != P_NONE; i++)
	if (class_skill[i].skill == j)
	    break;
    if (class_skill[i].skill == P_NONE)
	pline("Warning: No entry for %s in Skill array.",
	  obj_typename(spellbook));
    else if (class_skill[i].skmax < P_EXPERT)
	class_skill[i].skmax++;
    else
    {
	j = 0;
	for(i = 0; class_skill[i].skill != P_NONE; i++) {
	    if (class_skill[i].skill >= P_FIRST_SPELL &&
	      class_skill[i].skill <= P_LAST_SPELL &&
	      class_skill[i].skmax == P_SKILLED)
		j++;
	}
	if (j) {
	    j = rn2(j);
	    for(i = 0; class_skill[i].skill != P_NONE; i++) {
		if (class_skill[i].skill >= P_FIRST_SPELL &&
		  class_skill[i].skill <= P_LAST_SPELL &&
		  class_skill[i].skmax == P_SKILLED)
		    if (!j--) {
			class_skill[i].skmax++;
			break;
		    }
	    }
	}
	else {
	    for(i = 0; class_skill[i].skill != P_NONE; i++) {
		if (class_skill[i].skill >= P_FIRST_SPELL &&
		  class_skill[i].skill <= P_LAST_SPELL &&
		  class_skill[i].skmax >= P_BASIC &&
		  class_skill[i].skmax < P_EXPERT)
		    j++;
	    }
	    if (j) {
		j = rn2(j);
		for(i = 0; class_skill[i].skill != P_NONE; i++) {
		    if (class_skill[i].skill >= P_FIRST_SPELL &&
		      class_skill[i].skill <= P_LAST_SPELL &&
		      class_skill[i].skmax >= P_BASIC &&
		      class_skill[i].skmax < P_EXPERT)
			if (!j--) {
			    class_skill[i].skmax++;
			    break;
			}
		}
	    }
	}
    }
}

/* Know 5 to 15 random magical objects (wands, potions, scrolls, ...)
   For now we decide that tools while possibly magical (bag of holding/tricks,
   magic lamp) are excempt because the Bard already knows all instruments
   which appear to be more than enough tools.
   We might also add GEM_CLASS with oc_material != GLASS 
*** Contributed by Johanna Ploog */
STATIC_OVL void
know_random_obj()
{
        register int obj, count, ct;

        count = rn1(11,5);
        for (ct = 500; ct > 0 && count > 0; ct--) {
           obj = rn2(NUM_OBJECTS);
           if (objects[obj].oc_magic &&

               /* We have to make an exception for those dummy
                  objects (wand and scroll) that exist to allow
                  for additional descriptions. */

               obj_descr[(objects[obj].oc_name_idx)].oc_name != 0 /*&&

              (objects[obj].oc_class == ARMOR_CLASS &&*/

               /* Dragon scales and mails are considered magical,
                  but as they don't have different descriptions,
                  they don't appear in the discovery list,
                  so as not to rob the player of an opportunity... */

                /*!(obj > HELM_OF_TELEPATHY && obj < PLATE_MAIL) ||

               objects[obj].oc_class == RING_CLASS ||
               objects[obj].oc_class == POTION_CLASS ||
               objects[obj].oc_class == SCROLL_CLASS ||
               objects[obj].oc_class == SPBOOK_CLASS ||
               objects[obj].oc_class == WAND_CLASS ||
               objects[obj].oc_class == AMULET_CLASS)*/)
            {
              knows_object(obj);
              count--;
            }
        }
}

/* heretic race characters can sometimes get arbitrary gods --Amy */
static const char * const hereticgods[] = {

"Wolf", "Big Bear", "Ryu", "Tacitus", "Urbaldi", "Pete", "Lex", "Denshi Gasu", "Mr. Black", "Tiger's Claw", "Katzou", "Mohmar Deathstrike", "Ingo", "Septimus", "Martius", "Faster-Than-All-Others", "Senator Antius", "H.", "Pokoh", "Davide", "Aee", "Doctor Maex", "Marc", "Arno", "Hailbush", "Romann", "Siegfried", "Roy", "G-cheater", "Bastian", "Nicyan", "Queelix", "Miesael", "Honno", "Robin", "JNR", "Lars", "Tommy", "Giglio", "Kastortransport", "Larry", "Morton", "Iggy", "Lemmy", "Ludwig", "Oberdan", "Len-kind", "Ilie", "Till", "Tomas", "Nikolob", "Tillbull", "Robat", "Robert", "Tobi", "Tobias", "Flo-ooo", "Florian", "Cristi", "Christian", "Alex", "Egas", "Hannes", "Leo", "Leopold", "Baschdi Deathstrike", "Markus", "Martin", "Max", "Maximilian", "Jannik", "Conse", "Constantin", "Paul", "David", "Arne", "Julian", "Sebastian", "Yannick", "Felix", "Michael", "Hanno", "Nino", "Daniel", "Lennart", "Ilja", "Nico", "Tillmann", "Stefan", "Lukas", "Selinger", "Gallardo", "Baenni", "Peeer", "Peeta", "Walter", "Klaus", "Walker", "Nikolei", "Jonas", "Iwan", "Rubinho", "Coffin Nail", "Evillan", "Thilo", "Maurus", "Freddie", "Laurens", "Loorenz", "Jorin", "Rinjo", "Andrej", "Anselm", "Aram", "Boris", "Burkhard", "Nils", "Siln", "Ozan", "Otzan", "Thorwald", "Forestgate", "Dominik", "Albert", "Don Finwe", "Gerrit", "Jens", "Leon", "Marius", "Mirko", "Sigurd", "Wilhelm", 

"_JoJo", "_Jyllia", "_Sabrina", "_Sabine", "_Yvara", "_Lenka", "_Evita", "_Liebea", "_Isolde", "_Elli", "_Vilja", "_Sunija", "_Rhea", "_Jasmin", "_Erosina", "_Irmina", "_Melirija", "_Larissa", "_Sysette", "_Miss Haskill", "_Elenya", "_Golden Mary", "_Lara", "_Sandrina", "_Tonilia", "_Claire", "_Lumia", "_Lahira", "_Estrella", "_Maricia", "_Sontaire", "_Marje", "_Jill", "_Trycja", "_Kersey", "_Sally", "_Hannya", "_Svantje", "_Jynnifyr", "_Elke", "_Rinka", "_Nicoletta", "_Betti", "_Ina", "_Heikipa", "_Jora", "_Maitine", "_Esruth", "_Verene", "_Lousie", "_Irinella", "_Amandina", "_Lillie", "_Leodoch", "_Mirella", "_Fisoa", "_Suesska", "_Ann", "_Nurisha", "_Desiree", "_Birgit", "_Elsbeth", "_Lamy", "_Lissie", "_Arabella", "_Anastasia", "_Henrietta", "_Katrin", "_Jana", "_Aniya", "_Yasni", "_Almina", "_Xeni", "_Mirri", "_Eleanor", "_Kirja", "_Inge", "_Helli", "_Lucia", "_Viktorija", "_Simona", "_Natalyana", "_Krista", "_Nellina", "_Raidara", "_Vera", "_Noko", "_Jasajeen", "_Marika", "_Merbek", "_Marianna", "_Sinja", "_Rodotha", "_Natinya", "_Aline", "_Michaela", "_Mare", "_Noenoe", "_Tschulia", "_Lea", "_Sarah", "_Iris", "_Charravalga", "_Fridrika", "_Great Jaguar Claw", "_Lynette", "_Celina", "_Irya", "_Mariya", "_Wendy", "_Katia", "_Tanja", "_Vanessa", "_Anne", "_Lena", "_Jeanetta", "_Rungud", "_Melissa", "_Everella", "_Madeleine", "_Anita", "_Nina", "_Natascha", "_Manola", "_Litta", "_Kiwi", "_Maja", "_Natalje", "_Little Marie", "_Ronja", "_Roswitha", "_Sing", "_Johanetta", "_Julia", "_Julchen", "_Yvonne", "_Magdalena", "_Eveline", "_Bea", "_Beatriz", "_Corina", "_Elif", "_Nadja", "_Sunali", "_Solvejg", "_Thai", "_Meltem", "_Susanne", "_Rita", "_Kati", "_Katinka", "_Mailie", "_Marie", "_Klara", "_Sandra", "_Antonia", "_Chaska", "_Ludgera", "_Laura", "_Eva", "_Maurah", "_Sophie", "_Marian", "_Jil", "_Patricia", "_Kerstin", "_Hanh", "_Antje", "_Jennifer", "_Karin", "_Nicole", "_Bettina", "_Heike", "_Dora", "_Maite", "_Ruth", "_Verena", "_Lou", "_Danielle", "_Amandine", "_Lily", "_Leonie", "_Mira", "_Sofia", "_Christiane", "_Ann Kathrin", "_Njusha", "_Elisabeth", "_Conny", "_Constanze", "_Lisa", "_Anja", "_Yasaman", "_Almut", "_Ksenia", "_Miriam", "_Elena", "_Katharina", "_Helen", "_Victoria", "_Simone", "_Nataliya", "_Kristin", "_Nelly", "_Rejda", "_Nora", "_Jasieen", "_Yacine", "_Marike", "_Merle", "_Marianne", "_Sina", "_Dorothea", "_Tinanya", "_Noemi", "_Giulia", "_Charlotte", "_Friederike", "_Sophia", "_Sue Lyn", "_Juen", "_Ruea", "_Gudrun", "_Ella", "_Manuela", "_Tilla", "_Greta", "_Jane", "_Celia", "_Boese", "_Bad", "_Eliane", "_O'Neill", "_Fenja", "_Silvana", "_Vanasil", "_Sarina", "_Alexia", "_Vida", "_Isis", "_Ilse", "_Melanie", "_Lareena", "_Janina", "_Jannie", "_Micha", "_Chirin", "_Ingrid", "_Tonja", "_Tapia", "_Ligasa", "_Andrea", "_Mia", "_Annemarie", "_Caro", "_Mandarina", "_Ariane", "_Carina", "_Denise", "_Kira", "_Nadine", "_Franzi", "_Amelie", "_Annika", "_Barbara", "_Elsa", "_Isabel", "_Bianca", "_Carmen", "_Hilda", "_Johanna", "_Julietta", "_Linda", "_Petra", "_Sonja", "_Stella", "_Ismella", "_Teresa", "_Sagarah", "_Rosy",

"Cerberus", "Kroo the Kobold King", "_Aphrodite", "Grund the Orc King", "Jumbo the Elephant", "Catoblepas", "The Rat King", "_Girtab", "_Shelob", "Pegasus", "Deep Thought", "Eddie", "Douglas Adams", "Ruggo the Gnome King", "The Largest Giant", "Father Dagon", "_Mother Hydra", "Doctor Frankenstein", "Vlad the Impaler", "Prostetnik Vogon Jeltz", "Marvin", "Zaphod Breeblebrox", "Frankenstein's Monster", "Sizzle", "_Katniss", "Ford Prefect", "Arthur Dent", "Mr. Prosser", "_Medusa", "The Wizard of Yendor", "Croesus", "Charon", "UNIX Kernel", "Juiblex", "Jubilex", "_Fierna", "_Shami-Amourae", "Bael", "_Zuggtmoy", "Baphomet", "_Daughter Lilith", "Mammon", "_Xinivrae", "_Malcanthet", "_Mother Lilith", "Belial", "_Crone Lilith", "_Lynkhab", "Leviathan", "Mephistopheles", "_Baalphegor", "Yeenoghu", "Orcus", "_Shaktari", "Graz'zt", "Geryon", "Dispater", "Baalzebub", "_Pale Night", "Verier", "Asmodeus", "Demogorgon", "Cthulhu", "Death", "Pestilence", "Famine", "War", "_Nightmare", "Beholder", "Vecna", "Lord Carnarvon", "Pelias", "the strange corpse", "Fwagglebrapo", "Vlad the Skewerer", "the diseased heir", "Acidsnort", "Rockin Roller", "Christian Gray", "Pindar", "Shaman Karnov", "Driud the Druid", "Andy Stahl", "Smokey", "Master of Locks", "Harry the Cowboy", "Robert the Lifer", "Master Shifter", "Thorin", "Earendil", "_Elwing", "Sinderion", "Glarthir", "Vivec", "_Elenwen", "High Flame Mage", "The Dev Team", "Top Gunner", "Upper Graduate", "Gordon Freeman", "Snap and Loopin", "Hippocrates", "_Bellatrix Lestrange", "_Celeste", "_Madam Tequila the Clubhouse Owner", "Dave", "The Angry Video Game Nerd", "Guitar Hero", "Mister Mulberry", "Yes Man", "Crowned Drag Queen", "Camp Porter", "Activist Speaker", "Erec", "Dr. Wusiji", "Bilbo Baggins", "High Ice Mage", "King Arthur", "King Chester", "Sir Lancelot", "High Lycanthrope", "_the old Gypsy woman", "Grand Master", "Psi Master", "Dark Lord", "Arch Priest", "Paladin Colvin", "Mayor Cummerbund", "Master Caster", "Blackbeard", "Jacques Cousteau", "Orion", "Tutor", "Master of Thieves", "Master of Assassins", "Lord Sato", "_Tenshi and Meiling", "Senior Otaku", "Master Roshi", "Cato", "Ken Hayabusa", "Marc", "Stunt Double", "Otacon", "Principal Clark", "Mustached Nightshift Supermarket Manager", "Master Librarian", "some guy called Shade", "Commissioner Hunter", "Slave Emperor", "Paintmaster", "_Ajela", "Master Zookeeper", "Upper Augurer", "Master Bookkeeper", "Ancient Sage", "Twoflower", "Van Helsing", "King K. Rool", "_Norn", "_Neferet the Green", "Chief Yeoman Warder", "_The Queen", "The Jedi Master", "Minion of Huhetotl", "Thoth Amon", "Acererak", "_Aglaope", "Chromatic Dragon", "_Warden Arianna", "Transmuter", "Smaug", "Goblin King", "Water Mage", "Lareth", "_Bloody Beauties", "Colin Moriarty", "Esbern", "Eddie the Pyro", "Burglar Ed", "Draco the Sharpshooter", "Mannimarco", "Jaquio", "Grandpa Tank Breaker", "_Seducer Saint", "fearful triceratops", "Bill Gates", "Student Leader", "_Tara Gilesbie", "Harry Potter", "Cyclops", "Gollum", "Earth Mage", "Ixoth", "Sir Lorimar", "Rebel Ringleader", "Master Kaen", "_Master Sabrina", "The Champion of Pompeji", "_Archnemesis", "_Master Brain", "Maugneshaagar", "Blackbeard's Ghost", "Spearathan", "Moby Dick", "Nalzok", "Scorpius", "Master Assassin", "Ashikaga Takauji", "some random guy", "Activist Leader", "Elvis Presley", "_Imelda's Ghost", "Alduin", "Death Metal Orchestra Leader", "Lightningrod", "Amy Bluescreenofdeath", "Dagoth Ur", "Jyggalag", "_Else God-Hater", "Nihilanth", "Ho-oh", "Count Dracula", "Lord Surtur", "Buffy the Vampire Slayer", "Dark One", "Colonel Blood", "Lord Sidious", "_Anastasia Steele", "Dark Goku", "BNP Leader", "Donkey Kong", "Estormo", "Rodney's Twin", "Crabbe and Goyle", "Yet Another Gun Nut", "_Dana Dynamite Beauty Miss", "Bragging Vandal", "Bowser", "_Flandre Scarlet", "Ron Weasley", "Oberon Principal", "Ventos Effigil", "Mysterious Necromancer", "Plaster Blaster", "Joe the Greaser", "The Local Health Inspector", "Rincewind", "Yeldud Twen", "mailer daemon", "Mr. Uncool", "_Lady Elly", "Don Rio the Master Thief", "Pettler", "Farmer Maggot", "Killed Bill", "Upper Bull", "Gruff Co-Worker", "_Irina", "Slime Emperor", "King Lorik", "Dragonlord", "Legendary Hero", "Halbu", "Heffer", "Last Surviving Other Human", "John Romero", "_Rigil", "_Toliman", "_Princess of Moon", "Jedeite", "Birdman", "Evil Robot", "Shinto Priest", "Nine Tailed Fox", "Messenger of SPW", "Dio", "Judo Captain", "Gigock", "Geneworm", "Pitworm", "G-cheater", "_Melinda Proudfoot", "_Helen the Activist Leader", "Morgoth", "H. the Motherfucker", "Cristi the Robber", "_Laura the Elemental Lady", "_Lahira the Evil Elementalist", "_Nadja the Occultist", "_Vilja the Bitch", "_Elli Pseudo", "Chris Cheng",

};

/* pantheons for priests etc. These contain all the roles pantheons; they need to be aligned so that if we pick a random number and apply that to all three, a consistent role's pantheon is created! It also contains made-up pantheons that don't belong to an actual role. --Amy */
static const char * const lawfulgods[] = {

"The Lord of the Pit", "Anti-War Movement", "_Eilistraee", "_Suzanne Collins", "Quetzalcoatl", "Leonardo", "Ehud", "Dunlain", "Mitra", "Garl Glittergold", "Yaldabaoth", "Glycocalyx", "_Rhea Oro", "Eddergud", "_Everella Shrine", "Anu", "Buddha", "Ilmater", "McDonalds", "President Kimball", "Jacob Black", "Merlin", "Tane", "_Sakuya", "Apollo", "Orome", "Thomas Alva Edison", "Solonor Thelandira", "James Bond", "Prometheus", "Earth", "Colonel Campbell", "Nintendo", "Claude Speed", "UNIX", "Sulla", "_B'loody Mary", "Jobs", "_Athena", "Air", "Bowditch", "the Light Side", "Barnum", "Lugh", "Erzulie Freda", "Hugh Hefner", "Leo Tolstoi", "Nuada", "Eluvian", "_Queen Serenity", "Shan Lai Ching", "Falis", "Donblas", "Nharlotep", "Votishal", "God the Father", "Magnum", "_Vaire", "Brahma", "Ariel", "Danzai", "the Lord", "A'En", "Democracy", "Bickney", "Mercury", "Classic Rock", "Issek", "_Cassandra", "Moori", "_Amaterasu Omikami", "Nikola Tesla", "Airyaman", "_Lady Ariane", "the Homies", "Manwe Sulimo", "Speedy Gonzales", "Blind Io", "_Olivia", "Seeker", "_Hel", "Tyr", "Larry Koopa", "Talos", "Ptah", "His Majesty", "Balder", "Andromorph", "Seraphimon", "Scorpion", "Dios", "Ceipheid", "_Tsunami", "Ladon", "_Osiris", "_Goddess", "Biron", "_Ishtar", "_Nayru", "Zephyr", "Aslan", "Bahamut", "_Princess Celestia", "_Rainbow Dash", "Ceiling Cat", "SlimKirby", "Superego", "Porphyry", "Nike", "Little Mac", "Noeda", "Dungeon Collapse", "Commissioner Hunter", "upper bull", "Acehack", "Johanna from Orleans", "Kelvin", "Bar", "Deckard Cain", "Pepin the Healer", "Sulla", "Cheibriados", "Fedhas", "Lugonu", "Okawaru", "Vehumet", "Zin", "_the Bitches", "King Somnus", "Gaia", "Khronos", "Brahma", "Pangu", "Atum", "Khepri", "Corak", "Chiyo-chichi", "Truth", "Mr. Black", "_Irina", "Ulfric Stormcloak", "Gaming PC", "Aurum", "Moradin", "Lurtz", "Legolas", "Selvetarm", "Mahal", "Ilneval", "_Vandria", "Saint Cuthbert", "_Breasts", "_Mother", "Eden", "_Balam", "Enki", "_Eurynome", "Nudziarth", "Huginn and Muninn", "Jack", "Shiro", "Tenebrous", "_Paimon", "Dahlver-Nar", "potion of urine", "Tal Rascha", "China", "General Fai", "Terrans", "Kormu", "_Demeter", "Tartarica", "_Minerva", "Static", "Jiraiya", "Nereus", "_Tenderness", "_Softness", "Toesmashing", "Bill Gates", "Albert Einstein", "Dagobert Duck", "Donkey Kong", "Mr. Spock", "the U.N.O.", "the gnome with the wand of death", "bhaak", "Elronnd", "Dudley", "stth", "muad", "Eidolos", "Boko Haram", "_Nicki Minaj", "Full Moon", "Doenerteller Versace", "Grizz", "Zombieman Brigade", "Powdery Snow", "Sol", "_Selene", "Lawful Good", "_Umbrellarina Madeline", "Jonathan Joestar", "Seveso Toxin", "Milahowalpaw", "Kanigyilak", "The Riddler", "Zeon Zum Deikun", "_Laya", "the Great Light", "Asgore Dreemurr", "the Wave Existence", "_Arle Nadja", "Amon Ra", "Fate", "Regunin", "_Mercedes", "_Ewa", "_Kumiromi of Harvest", "Yacatect of Wealth", "_Jure of Healing", "_Morodwyn", "Corellius", "Elderon", "The One Who Sees", "Onn", "Sssracht", "_Shalla", "Ka'Omsh", "Gnarl", "Order", "Fiit-Ssaaar", "Valpurus", "Legifer", "Atavus", "_Dulcis", "_Seges", "Polypiling", "Mr. Maradonna", "_Gina", "_Polyhymnia", "Tariru", "_Madeleine", "The Battlehorse", "Utu", "_Your Magical Roommate", "Heimskr", "_Margaret", "_Zoe Quinn", "Speaker Walt", "Linus Torvalds", "Wikileaks", "Grime", "Krog", "Cortege", "Macbeth", "Roger Staubach", "Bill Rizer", "_Grolla Seyfarth", "_Marie Curie", "Tax Evasion", "Neil Armstrong", "Diddy the Fail Master", "_Aung San Suu Kyi", "Jim Raynor", "Johnny", "Enki", "Cheep Cheep", "Divert", "Slim Jim", "Arihant", "_Sulis", "Indra", "Erotic Air Current Noises", "Buergerinnen und Buerger", "Arev", "_Eveline", "_the Archomentals", "Athulua", "0.54A", "_Katrin", "Birkenstock", "_Nuwa", "P-Point", "Charlie Sheen", "_Sophie Kinsella", "_Blue-Heeled Ute", "Bill Shoemaker", "_The Sexy Maidens", "Earnest Dejesus", 

};

static const char * const neutralgods[] = {

"Goldblight of the Flame", "Global Freedom Council", "_Kiaransali", "_Effie Trinket", "Camaxtli", "Picasso", "Ford", "Savos Aren", "Crom", "Flandal Steelskin", "the void", "Fibrinogen", "_Liebea Luna", "Vhaeraun", "Butch DeLoria", "_Ishtar", "Jahwe", "Grumbar", "Kentucky's Fried Chicken", "Mr. House", "_Bella Swan", "Salazar Slytherin", "Tangaroa", "_Reimu", "Dionysus", "_Yavanna", "Benjamin Franklin", "Aerdrie Faenya", "Chuck Norris", "Thor", "Fire", "Deepthroat", "Microsoft", "Carl CJ Johnson", "the PDP-7", "Cicero", "_Ebony Dark'ness", "Wozniak", "Hermes", "Frost", "Peabody", "the Force", "Bailey", "_Brigit", "Marassa Jumeaux", "G-boy", "Stephen Hawking", "Dagda", "Moon", "_Angel Aphrodite", "Chih Sung-tzu", "_Marfa", "Grome", "Zugguthobal", "Raiden", "_Mother Earth", "Smith", "_Varda Elentari", "Vishnu", "Tyrael", "Milanor", "_the deep blue sea", "Dr. Oujide", "Communism", "Corridor", "_Venus", "Symphonic Metal", "Mog", "Menelaos", "King Kai", "Raijin", "Erwin Schroedinger", "Gandarewa", "Lord Stahngnir", "the Robbers", "Mandos", "Dan Naginati", "_The Lady", "Peyman", "_Osiris", "Pluto", "Odin", "Roy Koopa", "_Meridia", "Thoth", "His Holiness", "_Edda", "Technix", "_Ophanimon", "Sub-Zero", "_the Rose Bride", "_the Lord of Nightmares", "_Washu", "Namanda", "Obelisk", "Doom", "Tieg", "Filaha", "_Farore", "_Raftina", "the Emperor-beyond-the-Sea", "Io", "_the Fausticorn", "_Fluttershy", "Longcat", "Lucahjin", "Ego", "_Fanny Kemble", "Adidas", "Mister Sandman", "Soviet5lo", "Segfault Bug", "Jeweler Jublgrais", "type of ice block", "DNethack", "Queen Katharina", "Celsius", "Torr", "Qual-Kehk", "Griswold the Armorer", "Amenophis", "Beogh", "Elyvilon", "Kikubaaqudgha", "Nemelex", "Trog", "Yredelemnul", "_the Hell Brides", "_Rubiss", "Ahura Mazda", "Demiourgos", "Aeon", "Bulaing", "Kamui", "Vishvakarman", "the Dragon Pharaoh", "Neco Coneco", "Love", "Big Bear", "Max", "_Delphine", "Sony PlayStation", "Argentum", "Dumathoin", "Saruman", "_Eowyn", "Keptolo", "Holashner", "_Luthic", "Corellon", "Helm", "_Feet", "Andromalius", "Berith", "_Cosmos", "Buer", "Amon", "Andrealphus", "Fafnir", "Astaroth", "_Eve", "_Chupoclops", "Naberius", "Orthos", "scroll of bullshit", "_Blood Raven", "USA", "General Townes", "Zerg", "_Sophie", "_Hestia", "Acetica", "Apollo", "Magnet", "_Tsunade", "Neptune", "_Beautifulness", "_Squeakiness", "Shin Kick", "_Britney Spears", "Homer Simpson", "_Xena", "Jack Bauer", "_Your mom", "the Flying Spaghetti Monster", "paxed", "tungtn", "Dion Nicolaas", "the RNG", "Adeon", "speedycat7", "dograt", "The Taliban", "_Taylor Swift", "New Moon", "Fish and Chips", "Panda", "The Revenants", "Large Snowflakes", "_Terra", "Helios", "True Neutral", "_Medium Deborah", "Hirohiko Araki", "Fukoshima Radiation", "_Timalixomol", "Omeatl", "_Poison Ivy", "Degwin Sodo Zabi", "Orakio", "Lutz", "the Absolute GOD of Hyperdeath", "Emperor Cain", "_Celine Jules", "Hersifon", "Unlimited Blade Works", "Caxon", "_Misty", "Lorskel", "Opatos of Earth", "Itzpalt of Element", "Mani of Machine", "Clamgaddin", "_Ayssia", "_Anssaria", "The One Who Kills", "_Istaria", "Issrecht", "_Auroree", "Ne'Ftrr", "_Berwyn", "Balance", "Sssaass", "Loricatus", "_Silva", "Mellis", "_Cleptia", "Sophos", "Monster Polymorphing", "_Ms. Unfortunate Forest", "Gordon Freeman", "_Euterpe", "FIQ", "_Sofia", "The Wild Boar", "Kossuth", "_Your Annoying Sister", "_Suffragette", "_Anaconda", "_Brianna Wu", "Great Corner-Hard", "Bjarne Stroustrup", "Guccifer 2.0", "Dog Shit", "Winston", "Tache", "Zoness", "Peyton Manning", "Lance Bean", "Pamela & Carl Arwig", "Georg Simon Ohm", "Murder and Arson", "_Sally Ride", "Bantor the Gay Voice", "Ai Weiwei", "Hierarch Artanis", "Spike", "Enlil", "Blubber", "Oat Camper", "Milwaukee Jon", "Siddha", "_Sequana", "Soma", "Wonderful Rubbing Noises", "Buergerlnnen", "U.GUR", "_Elena", "Cryonax", "Bul-Kathos", "Level Change UAE", "Len-kind", "Tamaris", "Pangu", "I Have To Reload", "Tiger Woods", "_Mavis Cheek", "_Red-Heeled Nancy", "Lester Piggott", "_The Sassy Girls", "_Madelene Thursday Lo", 

};

static const char * const chaoticgods[] = {

"Warpfire Hellspawn", "Human Rights Progression", "_Lolth", "President Snow", "Huhetotl", "Dali", "Ivins", "_Hert the Vampire", "Set", "Urdlen", "_Sophia", "_Hemophilia", "_Elenya Pure", "the black web", "Draco Malfoy", "Anshar", "Allah", "_Tymora", "Burger King", "Caesar", "Edward Cullen", "Lord Voldemort", "Whiro", "_Yukari Yakumo", "Pan", "Tulkas", "_Marilyn Monroe", "Erevan Ilesere", "Jackie Chan", "Arson", "Ash", "The Patriots", "Sony", "Tommy Vercetti", "VMS", "Catilina", "Darth Valer", "Gates", "Poseidon", "Smoke", "Rothchild", "the Dark Side", "Shaco", "Manannan Mac Lir", "Papa Legba", "Arsene Lupin", "H. P. Lovecraft", "Morrigan", "Lycanthus", "_Queen Beryl", "Huan Ti", "Falaris", "Arioch", "Gothuulbe", "Rat God", "the Satan", "Wesson", "_Nessa", "_Shiva", "Gabriel", "Daini", "the Devil", "Team Missile Bomb", "Despotism", "Lockney", "Mars", "Hardcore Punk", "Kos", "_Helen of Troy", "Vegeta", "Susanowo", "Wernher von Braun", "Daevas", "Sven Fanara", "the Motherfuckers", "Lorien", "_Kylie Lum", "Offler", "_Lady Gaga", "Seth", "Orcus", "Loki", "Morton Koopa Jr.", "Clavicus Vile", "Anhur", "The Commons", "Hagen", "Mechatron", "Cherubimon", "Kano", "End of the World", "Shabranigdo", "_Tokimi", "_Myria", "Ra", "Poltergeist", "the Mist", "Asmodeus", "_Din", "Justine", "Tash", "_Tiamat", "_Princess Luna", "_Pinkie Pie", "Basement Cat", "The Dark Id", "Id", "Amos Bronson Alcott", "Puma", "Mike Tyson", "Kerio", "Game Freeze", "Captain Future", "water puddle", "SLASH'EM Extended", "Al-Mutasim", "Fahrenheit", "Atue", "Geglash", "Farnham the Drunk", "Pyrrhus", "Ashenzari", "Dithmenos", "Jiyva", "Makhleb", "Sif Muna", "Xom", "_the Sluts with Syphilis", "Malroth", "Viracocha", "Mbombo", "Unkulunkulu", "Apsu", "Coatlique", "Tepeu", "Sheltem", "Kamineko", "Courage", "Faster-Than-All-Others", "Anton", "General Tullius", "XBox 360", "Antimony", "Abbathor", "Morgoth", "Eol", "Ghaunadaur", "Armok", "Gruumsh", "_Sehanine", "_Mask", "Sexy Butt", "_Marionette", "Ymir", "Dantalion", "_Iris", "Acererak", "Ose", "Ahazu", "_Echidna", "Miska", "Malphas", "Otias", "_Simurgh", "wand of summon sexy girl", "B-a-a-l", "Global Liberation Army", "Rodall 'Demo' Juhziz", "Protoss", "Gabnid", "_Adephagia", "Hydrocloria", "Linus", "Lightning", "Orochimaru", "Proteus", "_Disgustingness", "_Loudness", "Kick in the Nuts", "_Mother Teresa", "George W. Bush", "Super Mario", "the blue Power Ranger", "the universe", "the Invisible Pink Unicorn", "the DevTeam", "_Bluescreenofdeath", "marvin", "Tariru", "mrivan", "stenno", "DeathOnAStick", "The IS", "_Miley Cyrus", "Friday the 13th", "Fugu Globefish Sushi", "Ice Bear", "Cyberdemon MkIII Deluxe", "Blizzard", "_Luna", "_Eos", "Chaotic Evil", "_Crueltrainer Cindy", "Cars", "Mustard Gas", "Emoxivalirex", "Tleselagyila", "Two-Face", "Gihren Zabi", "Dark Force", "_the Profound Darkness", "Chara", "Deus", "_Miki Onimaru", "Mor Havoc", "Heaven's Feel", "_Jylla", "_Kendl", "Kaczynski", "_Ehekatl of Luck", "_Lulwy of Wind", "Eyth of Infidel", "Abbad-Undar", "Ni'Pregh", "_Rofl'th", "The One Who Rages", "Ssraxx", "Ussrachs", "Fnordjar", "Vagrak", "_Urglyn", "Chaos", "Fiit-Yaaar", "Mortifer", "Cruentus", "_Infuscor", "_Scabies", "_Nefas", "Self-Polymorph", "_Ms. Storm", "G-Man", "_Terpsichore", "Demo", "_Wendy", "The Dire Wolf", "Garyx", "_Your Insufferable Mother-In-Law", "Cromwell", "Aerschie-Miesie", "_Anita Sarkeesian", "Left Guenter", "Mark Zuckerberg", "Anonymous", "Fag Butt", "Cyrus", "Pillory", "_Titania", "Tom Brady", "Haggle Man", "Iris Sepperin", "Albert Einstein", "Prison Outbreak", "Yuri Gagarin", "Conker the Bad Fur Squirrel", "Vladimir Bukovsky", "_Sarah Kerrigan", "Timmy", "_Ereshkigal", "Boss Bass", "_Jeannine", "Bose Jefferson", "Acharya", "_Damona", "Ishwara", "Sexy Licking Noises", "Buerger*innen", "Khaldi", "_Marlen", "_the Elder Elemental", "Rathma", "Reset Button Without A Confirmation", "Coffin Nail", "Peter Kaiser", "Fuxi", "Upper Failure Kornop", "George Clooney", "_Charlotte Roche", "_Ski-Heeled Brigitte", "John Velazquez", "_The Indomitable Women", "Gray Hayes", 

};


void
u_init()
{

	register int i, temp, racebounus, rolebounus, alignbounus, genderbounus, maxbounus, randpantheon, starlitmonster, starlitattempts;
	register struct permonst *ptr;
	struct permonst* shamblerm = &mons[PM_NITROHACK_HORROR];
	struct permonst* shamblerma = &mons[PM_SPEEDHACK_HORROR];
	struct permonst* shamblern = &mons[PM_NETHACKFOUR_HORROR];
	struct permonst* shamblerna = &mons[PM_DEVTEAM_HORROR];
	struct permonst* shamblerl = &mons[PM_DNETHACK_HORROR];
	struct permonst* shamblerln = &mons[PM_BEGINNER_HORROR];
	struct permonst* shamblerlo = &mons[PM_NOOB_HORROR];
	struct permonst* shamblerla = &mons[PM_NETHACKBRASS_HORROR];
	struct permonst* shamblerx = &mons[PM_INTERHACK_HORROR];
	struct permonst* shamblerxz = &mons[PM_VERBOTEN_SIGN];
	struct permonst* gloshamblerx = &mons[PM_GLORKUM];
	struct permonst* gloshamblert = &mons[PM_MASTER_GLORKUM];
	struct permonst* gloshamblerz = &mons[PM_ARCHGLORKUM];
	struct permonst* shamblerxa = &mons[PM_NHTNG_HORROR];
	struct permonst* shambler = &mons[PM_UNNETHACK_HORROR];
	struct permonst* shamblerp = &mons[PM_UNNETHACKPLUS_HORROR];
	struct permonst* shamblera = &mons[PM_ANGBAND_HORROR];
	struct permonst* shamblerap = &mons[PM_ADOM_HORROR];
	struct permonst* shamblerb = &mons[PM_PETTY_ANGBAND_HORROR];
	struct permonst* shamblerbp = &mons[PM_PETTY_ADOM_HORROR];
	struct permonst* shamblers = &mons[PM_SPORKHACK_HORROR];
	struct permonst* shamblersp = &mons[PM_SLASHEM_HORROR];
	struct permonst* shamblerr = &mons[PM_NETHACK_HORROR];
	struct permonst* shamblerrp = &mons[PM_ROGUE_HORROR];	
	struct permonst* shamblert = &mons[PM_GRUNTHACK_HORROR];
	struct permonst* shamblerta = &mons[PM_ACEHACK_HORROR];
	struct permonst* shamblery = &mons[PM_MAIDENHACK_HORROR];
	struct permonst* shamblerya = &mons[PM_YASD_HORROR];
	struct permonst* shamblertp = &mons[PM_PETTY_GRUNTHACK_HORROR];
	struct permonst* shamblertpa = &mons[PM_PETTY_ACEHACK_HORROR];

	struct permonst* rshamblerx = &mons[PM_INTERHACK_HORROR_X];
	struct permonst* rshamblerxa = &mons[PM_NHTNG_HORROR_X];
	struct permonst* rpokshamblert = &mons[PM_SUIKUN_X];
	struct permonst* rpokshamblertp = &mons[PM_HOUOU_X];
	struct permonst* rshamblerz = &mons[PM_STONE_COLD_HORROR_X];
	struct permonst* rshamblerza = &mons[PM_PETROGRAPHY_HORROR_X];

	struct permonst* shamblerz = &mons[PM_STONE_COLD_HORROR];
	struct permonst* shamblerza = &mons[PM_PETROGRAPHY_HORROR];

	struct permonst* shamblernl = &mons[PM_NAMELESS_HORROR];
	struct permonst* shamblernla = &mons[PM_FACELESS_HORROR];

	struct permonst* shamblerplayer = &mons[PM_AK_THIEF_IS_DEAD_];
	struct permonst* shamblerplayerb = &mons[PM_UN_IN_PROTECT_MODE];

	struct permonst* shamblerplayergl = &mons[PM_PLAYER_GLORKUM];

	struct permonst* shamblerplayerc = &mons[PM_BROWN_MISSINGNO];
	struct permonst* shamblerplayerd = &mons[PM_RED_MISSINGNO];
	struct permonst* shamblerplayere = &mons[PM_BLACK_MISSINGNO];
	struct permonst* shamblerplayerf = &mons[PM_CYAN_MISSINGNO];
	struct permonst* shamblerplayerg = &mons[PM_GRAY_MISSINGNO];
	struct permonst* shamblerplayerh = &mons[PM_WHITE_MISSINGNO];
	struct permonst* shamblerplayeri = &mons[PM_GREEN_MISSINGNO];
	struct permonst* shamblerplayerj = &mons[PM_MAGENTA_MISSINGNO];
	struct permonst* shamblerplayerk = &mons[PM_YELLOW_MISSINGNO];
	struct permonst* shamblerplayerl = &mons[PM_ORANGE_MISSINGNO];
	struct permonst* shamblerplayerm = &mons[PM_BRIGHT_CYAN_MISSINGNO];
	struct permonst* shamblerplayern = &mons[PM_BRIGHT_MAGENTA_MISSINGNO];
	struct permonst* shamblerplayero = &mons[PM_BRIGHT_BLUE_MISSINGNO];
	struct permonst* shamblerplayerp = &mons[PM_BRIGHT_GREEN_MISSINGNO];

	struct permonst* shamblerplayerq = &mons[PM_BEIGE_MISSINGNO];
	struct permonst* shamblerplayerr = &mons[PM_SHADY_MISSINGNO];
	struct permonst* shamblerplayers = &mons[PM_DARK_MISSINGNO];
	struct permonst* shamblerplayert = &mons[PM_SCARLET_MISSINGNO];
	struct permonst* shamblerplayeru = &mons[PM_VIRIDIAN_MISSINGNO];
	struct permonst* shamblerplayerv = &mons[PM_UMBRA_MISSINGNO];
	struct permonst* shamblerplayerflum = &mons[PM_FLUMBUGUS];
	struct permonst* shamblerplayerw = &mons[PM_PURPLE_MISSINGNO];
	struct permonst* shamblerplayerx = &mons[PM_STEEL_MISSINGNO];
	struct permonst* shamblerplayery = &mons[PM_VIVID_MISSINGNO];
	struct permonst* shamblerplayerz = &mons[PM_POISONOUS_MISSINGNO];
	struct permonst* shamblerplayeraa = &mons[PM_TOPAZ_MISSINGNO];
	struct permonst* shamblerplayerab = &mons[PM_ULTRAMARINE_MISSINGNO];
	struct permonst* shamblerplayerac = &mons[PM_PINK_MISSINGNO];
	struct permonst* shamblerplayerad = &mons[PM_AZURE_MISSINGNO];
	struct permonst* shamblerplayerae = &mons[PM_MULTICOLORED_MISSINGNO];

	struct permonst* shamblerplayermso = &mons[PM_MISSINGNO];
	struct permonst* shamblerplayermsp = &mons[PM_POLYMORPHED_MISSINGNO];

	struct permonst* deathraylord = &mons[PM_YEENOGHU];
	struct permonst* coldlord = &mons[PM_ASMODEUS];
	struct permonst* multigrue = &mons[PM_MULTICOLOR_GRUE];

	struct permonst* lolirace = &mons[PM_LOLI];

	struct permonst* riderone = &mons[PM_DEATH];
	struct permonst* ridertwo = &mons[PM_FAMINE];
	struct permonst* riderthree = &mons[PM_PESTILENCE];

	struct permonst* randomeye = &mons[PM_MYSTIC_EYE];
	struct permonst* randommimic = &mons[PM_UNKNOWN_MIMIC];
	struct permonst* randommimicb = &mons[PM_UNKNOWN_PERMAMIMIC];
	struct permonst* rrandommimic = &mons[PM_UNKNOWN_MIMIC_X];
	struct permonst* rrandommimicb = &mons[PM_UNKNOWN_PERMAMIMIC_X];
	struct permonst* randompiercer = &mons[PM_SHINING_PIERCER];
	struct permonst* randompiercerb = &mons[PM_SHINING_PENETRATOR];
	struct permonst* randompiercerc = &mons[PM_SHINING_SMASHER];
	struct permonst* randompiercerd = &mons[PM_SHINING_RIPPER];
	struct permonst* randompiercere = &mons[PM_SHINING_CRASHER];
	struct permonst* randomvortex = &mons[PM_SIZZLING_VORTEX];
	struct permonst* randomfungus = &mons[PM_COLORLESS_MOLD];
	struct permonst* randomfungusb = &mons[PM_COLORLESS_FUNGUS];
	struct permonst* randomfungusba = &mons[PM_COLORLESS_PATCH];
	struct permonst* randomfungusbb = &mons[PM_COLORLESS_FORCE_FUNGUS];
	struct permonst* randomfungusbbe = &mons[PM_COLORLESS_WORT];
	struct permonst* randomfungusbc = &mons[PM_COLORLESS_FORCE_PATCH];
	struct permonst* randomfungusbd = &mons[PM_COLORLESS_WARP_FUNGUS];
	struct permonst* randomfungusbe = &mons[PM_COLORLESS_WARP_PATCH];
	struct permonst* randomfungusc = &mons[PM_NONDESCRIPT_MOLD];
	struct permonst* randomfungusd = &mons[PM_NONDESCRIPT_FUNGUS];
	struct permonst* randomfungusda = &mons[PM_NONDESCRIPT_PATCH];
	struct permonst* randomfungusdb = &mons[PM_NONDESCRIPT_FORCE_FUNGUS];
	struct permonst* randomfungusdbx = &mons[PM_NONDESCRIPT_WORT];
	struct permonst* randomfungusdc = &mons[PM_NONDESCRIPT_FORCE_PATCH];
	struct permonst* randomfungusdd = &mons[PM_NONDESCRIPT_WARP_FUNGUS];
	struct permonst* randomfungusde = &mons[PM_NONDESCRIPT_WARP_PATCH];
	struct permonst* randomfunguse = &mons[PM_COLORLESS_GROWTH];
	struct permonst* randomfungusf = &mons[PM_COLORLESS_MUSHROOM];
	struct permonst* randomfungusg = &mons[PM_COLORLESS_STALK];
	struct permonst* randomfungush = &mons[PM_COLORLESS_SPORE];
	struct permonst* randomfungusi = &mons[PM_COLORLESS_COLONY];
	struct permonst* randomfungusj = &mons[PM_NONDESCRIPT_GROWTH];
	struct permonst* randomfungusk = &mons[PM_NONDESCRIPT_MUSHROOM];
	struct permonst* randomfungusl = &mons[PM_NONDESCRIPT_STALK];
	struct permonst* randomfungusm = &mons[PM_NONDESCRIPT_SPORE];
	struct permonst* randomfungusn = &mons[PM_NONDESCRIPT_COLONY];

	struct permonst* rrandomfungusa = &mons[PM_COLORLESS_MOLD_X];
	struct permonst* rrandomfungusb = &mons[PM_COLORLESS_FUNGUS_X];
	struct permonst* rrandomfungusc = &mons[PM_COLORLESS_PATCH_X];
	struct permonst* rrandomfungusd = &mons[PM_COLORLESS_FORCE_FUNGUS_X];
	struct permonst* rrandomfungusdx = &mons[PM_COLORLESS_WORT_X];
	struct permonst* rrandomfunguse = &mons[PM_COLORLESS_FORCE_PATCH_X];
	struct permonst* rrandomfungusf = &mons[PM_COLORLESS_WARP_FUNGUS_X];
	struct permonst* rrandomfungusg = &mons[PM_COLORLESS_WARP_PATCH_X];
	struct permonst* rrandomfungush = &mons[PM_COLORLESS_GROWTH_X];
	struct permonst* rrandomfungusi = &mons[PM_COLORLESS_MUSHROOM_X];
	struct permonst* rrandomfungusj = &mons[PM_COLORLESS_STALK_X];
	struct permonst* rrandomfungusk = &mons[PM_COLORLESS_SPORE_X];
	struct permonst* rrandomfungusl = &mons[PM_COLORLESS_COLONY_X];

	struct permonst* randomkop = &mons[PM_ONG_SEPHIRAH];
	struct permonst* randomkopb = &mons[PM_KRONG_SEPHIRAH];
	struct permonst* rrandomkopb = &mons[PM_KRONG_SEPHIRAH_X];
	struct permonst* randomkopc = &mons[PM_ZAKRONG_SEPHIRAH];
	struct permonst* randomtroll = &mons[PM_SPECIAL_TROLL];
	struct permonst* randomeel = &mons[PM_TEETHFISH];
	struct permonst* randomflyfish = &mons[PM_RAZORFIN_FISH];
	struct permonst* randomturret = &mons[PM_UNKNOWN_TURRET];
	struct permonst* randomdragon = &mons[PM_RAINBOW_MODE_DRAGON];
	struct permonst* randompompeji = &mons[PM_POMPEJI_SHAMBLER];
	struct permonst* randompompejib = &mons[PM_POMPEJI_STUMBLER];
	struct permonst* randompompejic = &mons[PM_POMPEJI_SPILLER];

	struct permonst* randomsphere = &mons[PM_RNG_SPHERE];
	struct permonst* randomlight = &mons[PM_RNG_LIGHT];
	struct permonst* randomlightB = &mons[PM_RNG_LASER];
	struct permonst* randomlightC = &mons[PM_RNG_BEAM];
	struct permonst* randomlightD = &mons[PM_RNG_RAY];
	struct permonst* randomlightE = &mons[PM_RNG_BULB];
	struct permonst* randomlightF = &mons[PM_RNG_STAR];
	struct permonst* randomlightG = &mons[PM_RNG_BOOMER];

	struct permonst* shadowwarrior = &mons[PM_SHADOW_WARRIOR];
	struct permonst* shadowwarriorX = &mons[PM_ROBOT];

	struct permonst* randomdragonb = &mons[PM_ADULT_TATZELWORM];
	struct permonst* randomdragonc = &mons[PM_ADULT_AMPHITERE];
	struct permonst* randomdragond = &mons[PM_ADULT_DRAKEN];
	struct permonst* randomdragone = &mons[PM_ADULT_LINDWORM];
	struct permonst* randomdragonf = &mons[PM_ADULT_SARKANY];
	struct permonst* randomdragong = &mons[PM_ADULT_SIRRUSH];
	struct permonst* randomdragonh = &mons[PM_ADULT_LEVIATHAN];
	struct permonst* randomdragoni = &mons[PM_ADULT_WYVERN];
	struct permonst* randomdragonj = &mons[PM_ADULT_GLOWING_DRAGON];
	struct permonst* randomdragonk = &mons[PM_ADULT_GUIVRE];

	struct permonst* randombdragonb = &mons[PM_BABY_TATZELWORM];
	struct permonst* randombdragonc = &mons[PM_BABY_AMPHITERE];
	struct permonst* randombdragond = &mons[PM_BABY_DRAKEN];
	struct permonst* randombdragone = &mons[PM_BABY_LINDWORM];
	struct permonst* randombdragonf = &mons[PM_BABY_SARKANY];
	struct permonst* randombdragong = &mons[PM_BABY_SIRRUSH];
	struct permonst* randombdragonh = &mons[PM_BABY_LEVIATHAN];
	struct permonst* randombdragoni = &mons[PM_BABY_WYVERN];
	struct permonst* randombdragonj = &mons[PM_BABY_GLOWING_DRAGON];
	struct permonst* randombdragonk = &mons[PM_BABY_GUIVRE];

	struct permonst* rrandomdragonb = &mons[PM_ADULT_TATZELWORM_X];
	struct permonst* rrandomdragonc = &mons[PM_ADULT_AMPHITERE_X];
	struct permonst* rrandombdragonb = &mons[PM_BABY_TATZELWORM_X];
	struct permonst* rrandombdragonc = &mons[PM_BABY_AMPHITERE_X];

	struct permonst* splicemona = &mons[PM_SPLICED_AMALGAMATION];
	struct permonst* splicemonb = &mons[PM_SPLICED_BAD_CLONE];

	struct permonst* pokshamblerl = &mons[PM_PUPURIN];
	struct permonst* pokshamblerla = &mons[PM_SAPUSAUR];
	struct permonst* pokshamblerm = &mons[PM_ODDOSHISHI];
	struct permonst* pokshamblerma = &mons[PM_TSUBOTSUBO];
	struct permonst* pokshamblerx = &mons[PM_OKUTAN];
	struct permonst* pokshamblerxa = &mons[PM_RATICLAW];
	struct permonst* pokshambler = &mons[PM_PSYBUR];
	struct permonst* pokshamblerp = &mons[PM_HARISEN];
	struct permonst* pokshamblert = &mons[PM_SUIKUN];
	struct permonst* pokshamblertp = &mons[PM_HOUOU];
	struct permonst* pokshamblers = &mons[PM_LOCUSTOD];
	struct permonst* pokshamblersp = &mons[PM_FORETOSU];	
	struct permonst* pokshamblerxts = &mons[PM_CHARCOLT];
	struct permonst* pokshamblerxtsp = &mons[PM_MILLENUM];

	struct permonst* starlita = &mons[PM_STARLIT_SKY];
	struct permonst* starlitb = &mons[PM_DARK_STARLIT_SKY];
	struct permonst* starlitc = &mons[PM_BLACK_STARLIT_SKY];
	struct permonst* starlitd = &mons[PM_RED_STARLIT_SKY];
	struct permonst* starlite = &mons[PM_BROWN_STARLIT_SKY];
	struct permonst* starlitf = &mons[PM_GREEN_STARLIT_SKY];
	struct permonst* starlitg = &mons[PM_PURPLE_STARLIT_SKY];
	struct permonst* starlith = &mons[PM_YELLOW_STARLIT_SKY];
	struct permonst* starliti = &mons[PM_ORANGE_STARLIT_SKY];
	struct permonst* starlitj = &mons[PM_CYAN_STARLIT_SKY];
	struct permonst* starlitffx = &mons[PM_ENEMY_FROM_LEVEL___];
	struct permonst* starlitk = &mons[PM_VIOLET_STARLIT_SKY];

	struct permonst* starlitl = &mons[PM_MISNAMED_STARLIT_SKY];
	struct permonst* starlitm = &mons[PM_WRONG_NAMED_STARLIT_SKY];
	struct permonst* starlitn = &mons[PM_ERRONEOUS_STARLIT_SKY];

	struct permonst* starlitu = &mons[PM_TRUE_MISSINGNO];
	struct permonst* starlitv = &mons[PM_ETHEREAL_MISSINGNO];

	struct permonst* polyinitor = &mons[PM_POLYINITOR];
	struct permonst* destabilizer = &mons[PM_DESTABILIZER];

	struct permonst* randbossa = &mons[PM_EXTRA_FLEECY_BUNDLE];
	struct permonst* randbossb = &mons[PM_EMMELIE];
	struct permonst* randbossc = &mons[PM_LUISA];
	struct permonst* randbossd = &mons[PM_SHY_LAURA];
	struct permonst* randbosse = &mons[PM_ANNA];
	struct permonst* randbossf = &mons[PM_LEXI];
	struct permonst* randbossg = &mons[PM_SOFT_SARAH];
	struct permonst* randbossh = &mons[PM_MAREIKE];
	struct permonst* randbossi = &mons[PM_REBECCA];
	struct permonst* randbossj = &mons[PM_ROUGH_TERESA];
	struct permonst* randbossk = &mons[PM_JANINE];
	struct permonst* randbossl = &mons[PM_BITCHY_LARA];
	struct permonst* randbossm = &mons[PM_MARLEEN];
	struct permonst* randbossn = &mons[PM_NONEROTIC_IRINA];
	struct permonst* randbosso = &mons[PM_BUNDLY_ANN];
	struct permonst* randbossp = &mons[PM_LISELOTTE];
	struct permonst* randbossq = &mons[PM_LILLY];
	struct permonst* randbossr = &mons[PM_MIRIAM_THE_SPIRIT_GIRL];
	struct permonst* randbosss = &mons[PM_THE_SWEET_HIGH_HEEL_LOVING_ASIAN_GIRL];
	struct permonst* randbosst = &mons[PM_EMMA];
	struct permonst* randbossu = &mons[PM_ALIDA];
	struct permonst* randbossv = &mons[PM_JOSEFINE];
	struct permonst* randbossw = &mons[PM_VILEA];
	struct permonst* randbossx = &mons[PM_VILEA_S_SISTER];
	struct permonst* randbossy = &mons[PM_HANNAH];
	struct permonst* randbossz = &mons[PM_AMELJE];
	struct permonst* randbossaa = &mons[PM_NON_PRETTY_MELANIE];
	struct permonst* randbossab = &mons[PM_THE_SWEET_REDGUARD_GIRL];
	struct permonst* randbossac = &mons[PM_THE_HEELED_TOPMODEL];
	struct permonst* randbossad = &mons[PM_THE_HUGGING_TOPMODEL];
	struct permonst* randbossae = &mons[PM_MARIE];
	struct permonst* randbossaf = &mons[PM_THE_FAIRY];
	struct permonst* randbossag = &mons[PM_FANNY];
	struct permonst* randbossah = &mons[PM_THE_BASTARD_BROTHER_OF_SHY_LAURA];
	struct permonst* randbossai = &mons[PM_APE_HEAD];
	struct permonst* randbossaj = &mons[PM_BEANPOLE];
	struct permonst* randbossak = &mons[PM_CHEESEHEAD_SIMON];
	struct permonst* randbossal = &mons[PM_MALADJUSTED_LEON];
	struct permonst* randbossam = &mons[PM_MAX_THE_BADASS];
	struct permonst* randbossan = &mons[PM_ANTON];
	struct permonst* randbossao = &mons[PM_JONAS_THE_SCHIZO_AUTIST];
	struct permonst* randbossap = &mons[PM_LARS_THE_SCHIZOPHRENIC];
	struct permonst* randbossaq = &mons[PM_MELVIN];
	struct permonst* randbossar = &mons[PM_THE_BASTARD_BROTHER_OF_LILLY];
	struct permonst* randbossas = &mons[PM_THE_DISGUSTING_FRIEND_OF_LILLY_S_BROTHER];
	struct permonst* randbossat = &mons[PM_THE_DISGUSTING_SMOKER_FRIEND_OF_MARIE];
	struct permonst* randbossau = &mons[PM_SCHALOTTE];
	struct permonst* randbossav = &mons[PM_MAY_BRITT];
	struct permonst* randbossaw = &mons[PM_ROXY_GRETA];
	struct permonst* randbossax = &mons[PM_BUNDLE_NADJA];

	struct permonst* randfwea = &mons[PM_THE_EXTRA_FLEECY_BUNDLE_HER_HUGGING_BOOT];
	struct permonst* randfweb = &mons[PM_EMMELIE_S_SNEAKER];
	struct permonst* randfwec = &mons[PM_LUISA_S_HUGGING_BOOT];
	struct permonst* randfwed = &mons[PM_SHY_LAURA_S_LOVELY_COMBAT_BOOT];
	struct permonst* randfwee = &mons[PM_LEXI_S_WONDERFULLY_SOFT_SNEAKER];
	struct permonst* randfwef = &mons[PM_REBECCA_S_HUGGING_BOOT];
	struct permonst* randfweg = &mons[PM_ROUGH_TERESA_S_SNEAKER];
	struct permonst* randfweh = &mons[PM_JANINE_S_SNEAKER];
	struct permonst* randfwei = &mons[PM_BITCHY_LARA_S_HUGGING_BOOT];
	struct permonst* randfwej = &mons[PM_MARLEEN_S_SNEAKER];
	struct permonst* randfwek = &mons[PM_MARLEEN_S_HUGGING_BOOT];
	struct permonst* randfwel = &mons[PM_NONEROTIC_IRINA_S_WEDGE_SANDAL];
	struct permonst* randfwem = &mons[PM_BUNDLY_ANN_S_SOFT_SANDAL];
	struct permonst* randfwen = &mons[PM_LISELOTTE_S_HUGGING_BOOT];
	struct permonst* randfweo = &mons[PM_LISELOTTE_S_SOFT_SNEAKER];
	struct permonst* randfwep = &mons[PM_LILLY_S_FLEECY_COMBAT_BOOT];
	struct permonst* randfweq = &mons[PM_MAY_BRITT_S_FLUFFY_SANDAL];
	struct permonst* randfwer = &mons[PM_ROXY_GRETA_S_SNEAKER];
	struct permonst* randfwes = &mons[PM_THE_HIGH_HEEL_LOVING_ASIAN_GIRL_HER_HEELS];
	struct permonst* randfwet = &mons[PM_EMMA_S_ANKLE_BOOT];
	struct permonst* randfweu = &mons[PM_ALIDA_S_COLORFUL_SNEAKER];
	struct permonst* randfwev = &mons[PM_JOSEFINE_S_SUPER_SWEET_VELCRO_SNEAKER];
	struct permonst* randfwew = &mons[PM_VILEA_S_HUGGING_BOOT];
	struct permonst* randfwex = &mons[PM_HANNAH_S_COMBAT_BOOT];
	struct permonst* randfwey = &mons[PM_AMELJE_S_HUGGING_BOOT];
	struct permonst* randfwez = &mons[PM_AMELJE_S_SANDAL];
	struct permonst* randfweaa = &mons[PM_MELANIE_S_HUGGING_BOOT];
	struct permonst* randfweab = &mons[PM_THE_HUGGING_TOPMODEL_HER_HUGGING_BOOT];
	struct permonst* randfweac = &mons[PM_MARIE_S_HUGGING_BOOT];
	struct permonst* randfwead = &mons[PM_FANNY_S_VELCRO_SNEAKER];
	struct permonst* randfweae = &mons[PM_FANNY_S_BRAND_NEW_SNEAKER];
	struct permonst* randfweaf = &mons[PM_FANNY_S_BUCKLED_SANDAL];
	struct permonst* randfweag = &mons[PM_BUNDLE_NADJA_S_HUGGING_BOOT];
	struct permonst* randfweah = &mons[PM_ROUGH_TERESA_S_GENTLE_SOFT_SNEAKER];
	struct permonst* randfweai = &mons[PM_MARLEEN_S_BLOCK_HEELED_COMBAT_BOOT];
	struct permonst* randfweaj = &mons[PM_ALIDA_S_HUGGING_BOOT];
	struct permonst* randfweak = &mons[PM_BITCHY_LARA_S_BLOCK_HEELED_BOOT];
	struct permonst* randfweal = &mons[PM_EMMA_S_SEXY_WEDGE_SANDAL];
	struct permonst* randfweam = &mons[PM_THE_HIGH_HEEL_LOVING_ASIAN_GIRL_HER_SEXY_WEDGE_SANDAL];
	struct permonst* randfwean = &mons[PM_FANNY_S_LOVELY_WINTER_BOOT];
	struct permonst* randfweao = &mons[PM_EMMELIE_S_WHITE_HUGGING_BOOT];
	struct permonst* randfweap = &mons[PM_LUISA_S_DANCING_SHOE];
	struct permonst* randfweaq = &mons[PM_LUISA_S_SPUTA_FLOWING_BLOCK_HEEL_BOOT];

	struct permonst* randxya = &mons[PM_RANDO_ANT];
	struct permonst* randxyb = &mons[PM_RNGENERAL];
	struct permonst* randxyc = &mons[PM_VICIOUS_WOLF];
	struct permonst* randxyd = &mons[PM_MYRION];
	struct permonst* randxye = &mons[PM_UNEXPECTED_TIGER];
	struct permonst* randxyf = &mons[PM_CUBED_JELLY];
	struct permonst* randxyg = &mons[PM_KOBOLD_DICEROLLER];
	struct permonst* randxyh = &mons[PM_GYM_LEADER];
	struct permonst* randxyi = &mons[PM_RAINBOW_SENTAI];
	struct permonst* randxyj = &mons[PM_UNFAIR_ARCHON];
	struct permonst* randxyk = &mons[PM_CHAOS_RULECHANGER];
	struct permonst* randxyl = &mons[PM_RNGED_MONSTER];
	struct permonst* randxym = &mons[PM_RNG_KOP];
	struct permonst* randxyn = &mons[PM_RNG_SERGEANT];
	struct permonst* randxyo = &mons[PM_RNG_LIEUTENANT];
	struct permonst* randxyp = &mons[PM_RNG_KAPTAIN];
	struct permonst* randxyq = &mons[PM_RNG_KOMMISSIONER];
	struct permonst* randxyr = &mons[PM_RNG_KCHIEF];
	struct permonst* randxys = &mons[PM_RNG_KATCHER];
	struct permonst* randxyt = &mons[PM_RNG_KRIMINOLOGIST];
	struct permonst* randxytX = &mons[PM_RNG_KEELHAULER];
	struct permonst* randxytY = &mons[PM_RNG_KLEEVER];
	struct permonst* randxyu = &mons[PM_GENERATOR_LICH];
	struct permonst* randxyv = &mons[PM_WHIMLICH];
	struct permonst* randxyw = &mons[PM_RAINBOW_OGRE];
	struct permonst* randxyx = &mons[PM_RANDO];
	struct permonst* randxyy = &mons[PM_RNGHOST];
	struct permonst* randxyz = &mons[PM_RANDOMIZER_DRACONIAN];
	struct permonst* randxyaa = &mons[PM_CENTAUR_RENGER];
	struct permonst* randxyab = &mons[PM_MEGASPOILER_YRUAS];
	struct permonst* randxyac = &mons[PM_SHAMBLING_COUSIN];

	struct permonst* randhybrid = &mons[PM_HYBRIDRAGON];

	struct permonst* randspoilera = &mons[PM_ERROR_BUG];
	struct permonst* randspoilerb = &mons[PM_SPOILERHACK_HORROR];
	struct permonst* randspoilerc = &mons[PM_YOUNGWOMANHACK_HORROR];
	struct permonst* randspoilerd = &mons[PM_CHIPPED_BUG];
	struct permonst* randspoilere = &mons[PM_FLAWED_BUG];
	struct permonst* randspoilerf = &mons[PM_NORMAL_BUG];
	struct permonst* randspoilerg = &mons[PM_FLAWLESS_BUG];
	struct permonst* randspoilerh = &mons[PM_PERFECT_BUG];
	struct permonst* randspoileri = &mons[PM_DIVINE_BUG];
	struct permonst* randspoilerj = &mons[PM_GW_L__F____E_OA_];
	struct permonst* randspoilerk = &mons[PM_AGVZDHVZZXI_DGVZDHBHC_N_B_JK];
	struct permonst* randspoilerl = &mons[PM_BLUE_LICH];
	struct permonst* randspoilerm = &mons[PM_SPOILER_LICH];
	struct permonst* randspoilern = &mons[PM_OBER_PWNOR];
	struct permonst* randspoilero = &mons[PM_PWNERDUDE];
	struct permonst* randspoilerp = &mons[PM_BLONTOR];
	struct permonst* randspoilerq = &mons[PM_BLONGOR];

	struct permonst* randfluidator = &mons[PM_FLUIDATOR_WEGA];
	struct permonst* randfluidatorb = &mons[PM_FLUIDATOR_STARRA];

	static char buf[BUFSZ];

	struct attack* attkptr;
	int no_extra_food = FALSE;

	flags.female = flags.initgend;
	flags.beginner = 1;

	/* WAC -- Clear Tech List since adjabil will init the 1st level techs*/
	for (i = 0; i <= MAXTECH; i++) tech_list[i].t_id = NO_TECH;

	/* Initialize spells */
	for (i = 0; i <= MAXSPELL; i++) spl_book[i].sp_id = NO_SPELL;

	/* Initialize the "u" structure.
	 * Note that some values may have been incorrectly set by a failed restore.
	 */
	(void) memset((void *)&u, 0, sizeof(u));
	setustuck((struct monst *)0);
#if 0	/* documentation of more zero values as desirable */
	u.usick_cause[0] = 0;
	u.uluck  = u.moreluck = 0;
	uarmu = 0;
	uarm = uarmc = uarmh = uarms = uarmg = uarmf = 0;
	uwep = uball = uchain = uleft = uright = 0;
	/* WAC Added uswapwep, uquiver*/
	uswapwep = uquiver = 0;
	/* KMH -- added two-weapon combat */
	u.twoweap = 0;
	u.ublessed = 0;				/* not worthy yet */
	u.ugangr   = 0;				/* gods not angry */
	u.ugifts   = 0;				/* no divine gifts bestowed */
	/* WAC not needed - use techs */
/*	u.unextuse = 0;
	u.ulastuse = 0;*/
	u.uevent.uhand_of_elbereth = 0;
	u.uevent.uheard_tune = 0;
	u.uevent.uopened_dbridge = 0;
	u.uevent.udemigod = 0;		/* not a demi-god yet... */
	u.udg_cnt = 0;
	u.mh = u.mhmax = Upolyd = 0;
	u.uz.dnum = u.uz0.dnum = 0;
	u.utotype = 0;
#endif	/* 0 */

	u.uz.dlevel = 1;
	u.uz0.dlevel = 0;
	u.utolev = u.uz;

	u.umoved = FALSE;
	u.umortality = 0;
	u.ugrave_arise = Role_if(PM_PIRATE) ? PM_SKELETAL_PIRATE : Role_if(PM_BINDER) ? PM_SHADE : NON_PM;
	
	u.ukinghill = 0;
	u.protean = 0;

	u.umonnum = u.umonster = (flags.female &&
			urole.femalenum != NON_PM) ? urole.femalenum :
			urole.malenum;

	init_uasmon();

	u.ulevel = 0;	/* set up some of the initial attributes */
	u.uhp = u.uhpmax = u.uhplast = newhp();
	u.uenmax = urole.enadv.infix + urace.enadv.infix;
	if (Role_if(PM_DQ_SLIME) && Race_if(PM_PLAYER_SLIME)) u.uenmax += 20;
	if (urole.enadv.inrnd > 0)
	    u.uenmax += rnd(urole.enadv.inrnd);
	if (urace.enadv.inrnd > 0)
	    u.uenmax += rnd(urace.enadv.inrnd);
	u.uen = u.uenmax;
	u.uspellprot = 0;
	adjabil(0,1);
	u.ulevel = u.ulevelmax = 1;

	init_uhunger();
	u.ublesscnt = rnz(ishaxor ? 150 : 300);			/* no prayers just yet */
	u.weakcheat = 0;	/* increases if a character wearing a stat lock ring grows weak to prevent them from restoring strength points they didn't lose in the first place --Amy */
	u.stethocheat = 0;

      u.monstertimeout = rnz(12000)+rnz(18000);
	while (u.monstertimeout < 10) u.monstertimeout = rnz(12000)+rnz(18000);

	if (rn2(3)) u.monstertimeout += rnz(12000)+rnz(18000);

      u.monstertimefinish = rnz(36000)+rnz(72000)+u.monstertimeout;
	while (u.monstertimefinish < 20) u.monstertimefinish = rnz(36000)+rnz(72000)+u.monstertimeout;

	u.ascensiontimelimit = rnz(100) * rnz(1000 + rnd(30000)); /* if you still didn't ascend at this turn count, the game becomes much harder */
	while (u.ascensiontimelimit < (issoviet ? 500000 : 250000)) u.ascensiontimelimit = rnz(100) * rnz(1000 + rnd(9000));
	u.ascensionfirsthint = ( (u.ascensiontimelimit / 10) + rnd(u.ascensiontimelimit / 10)); 
	u.ascensionsecondhint = ( u.ascensiontimelimit - rnd(u.ascensiontimelimit / 2)); 

	u.legscratching = (Role_if(PM_BLEEDER) ? 3 : 1); /*must also be set here; this may increase over time*/
	if (Race_if(PM_HEMOPHAGE)) u.legscratching += 2; /* racial version of the bleeder role */
	u.next_check = rnz(600); /* it used to be exactly 600 at the start of every game */

	u.statuetrapname = rn2(NUMMONS);

	u.wormpolymorph = 0; /* if this is non-zero, the player's next polymorph will be into the specified monster */

	u.ughmemory = 0;	/* if this is non-zero, the player is protected from segfaults as long as missing_safety is on */

	u.youpolyamount = 0;	/* amount of uses for #youpoly command --Amy */

	u.randomquestlevels = rnd(250);	/* random levels may be replaced with quest levels, 1 in this times --Amy */

	u.hangupcheat = 0;	/* will be set to non-zero if the player hangs up --Amy */
	u.hangupparalysis = 0;
	u.hanguppenalty = 0;

	u.youaredead = 0;	/* if this is non-zero, returning to the game kills you because you should have died --Amy */
	u.youarereallydead = 0;	/* if this is non-zero, returning to the game REALLY kills you, even if you have lifesaving */
	u.datadeletedefer = 0; /* if this is non-zero, returning to the game gives you the data delete effect two times as punishment for trying to circumvent it */

	u.bankcashamount = 0;
	u.bankcashlimit = 0;

	u.ragnaroktimer = 0; /* if nonzero, ragnarok will happen */
	u.footererlevel = 0; /* if nonzero, entering the level with that number spawns mean bastards */

	u.seesilverspell = 1;	/* if this is zero, the entire playing field will be black */

	u.smexyberries = 0;	/* for a specific artifact */

	u.artifactaffinity = 0;
	u.artifinitythreshold = 0;
	u.gormalerturns = 0;

	u.pokelieresistances = 0;
	u.pokeliegeneration = 0;
	u.pokelieflags = 0;
	u.pokeliespeed = 0;
	u.pokelieattacktype = 0;
	u.pokeliedamagetype = 0;

	/* sokosolver special abilities timeout; these will time out even if you're a different race */
	u.sokosolveboulder = rnz(1000);
	u.sokosolveuntrap = rnz(4000);

	/* Duri the Blacksmith (if he exists) has special values with which he's initialized */
	u.durirepaircost = 1000;
	u.durienchantcost = 10000;
	u.duriarticostevil = 15000;
	u.duriarticostnormal = 50000;
	u.durirequest = 0;
	u.duriworking = 0;

	u.manlerx = u.manlery = -1;

	u.temprecursion = 0;
	u.temprecursiontime = 0;
	u.oldrecursionrole = -1;
	u.oldrecursionrace = -1;

	u.demagoguerecursion = 0;
	u.demagoguerecursiontime = 0;
	u.demagogueabilitytimer = 10000;

	u.tarmustrokingturn = 0;

	u.dehydrationtime = 0;
	u.yawmtime = 0;

	u.fakeartifacts = 0; /* does nothing special; just provides interesting statistics for enlightenment --Amy */

	u.totter = 0;

	u.nurseextracost = 1000;	/* cost to buy max HP from nurses, goes up every time the player does so --Amy */
	u.nursedecontamcost = 1000;	/* cost to buy decontamination from nurses */
	u.nursesymbiotecost = 10000;	/* cost to buy a new symbiote from nurses */
	u.nurseshutdowncost = 1000;	/* cost to buy shutdown service from nurses */
	u.nursevaccinecost = 2000;	/* cost to buy covid-19 vaccine from nurses */

	u.shutdowntime = 0;

	u.shaperoomchance = (rnd(15) + 3);	/* chance of irregular rooms */

	u.ungenocidable = randomgoodmclass(TRUE);

	if (!rn2(3)) u.speedymonster = randomgoodmclass(TRUE);
	if (!rn2(20)) u.musemonster = randomgoodmclass(TRUE);

	u.alwaysinvisible = 0;
	if (!rn2(20)) u.alwaysinvisible = randomgoodmclass(TRUE);
	u.alwayshidden = 0;
	if (!rn2(500)) u.alwayshidden = randomgoodmclass(TRUE);

	if (!rn2(2)) {
		u.frequentmonster = randomgoodmclass(FALSE);
		u.freqmonsterbonus = rne(4);
		if (!rn2(5)) u.freqmonsterbonus += rne(3);
		if (!rn2(3)) u.freqmonsterbonus *= 2;
		if (!rn2(5)) u.freqmonsterbonus *= 2;
		if (!rn2(8)) u.freqmonsterbonus += rne(4);
		if (!rn2(12)) u.freqmonsterbonus *= (1 + rne(15));
		if (!rn2(20)) u.freqmonsterbonus *= 3;
		if (!rn2(60)) u.freqmonsterbonus *= (1 + rne(12));
		if (!rn2(200)) u.freqmonsterbonus *= 4;
		if (!rn2(360)) u.freqmonsterbonus *= (1 + rne(10));
		if (!rn2(1360)) u.freqmonsterbonus *= (1 + rne(8));
		if (!rn2(5000)) u.freqmonsterbonus *= 5;
		if (!rn2(6360)) u.freqmonsterbonus *= (1 + rne(7));
		if (!rn2(25000)) u.freqmonsterbonus *= 6;
		if (!rn2(36360)) u.freqmonsterbonus *= (1 + rne(5));
		if (u.freqmonsterbonus > 100) u.freqmonsterbonus = 100; /* fail safe */
	}

	if (!rn2(10)) {
	u.frequentcolor = rnd(15);
	u.freqcolorbonus = rne(4);
	if (!rn2(5)) u.freqcolorbonus += rne(3);
	if (!rn2(3)) u.freqcolorbonus *= 2;
	if (!rn2(5)) u.freqcolorbonus *= 2;
	if (!rn2(8)) u.freqcolorbonus += rne(4);
	if (!rn2(12)) u.freqcolorbonus *= (1 + rne(15));
	if (!rn2(20)) u.freqcolorbonus *= 3;
	if (!rn2(60)) u.freqcolorbonus *= (1 + rne(12));
	if (!rn2(200)) u.freqcolorbonus *= 4;
	if (!rn2(360)) u.freqcolorbonus *= (1 + rne(10));
	if (!rn2(1360)) u.freqcolorbonus *= (1 + rne(8));
	if (!rn2(5000)) u.freqcolorbonus *= 5;
	if (!rn2(6360)) u.freqcolorbonus *= (1 + rne(7));
	if (!rn2(25000)) u.freqcolorbonus *= 6;
	if (!rn2(36360)) u.freqcolorbonus *= (1 + rne(5));
	if (u.freqcolorbonus > 100) u.freqcolorbonus = 100; /* fail safe */
	}

	u.frequentationtrait = 0;

	register int traitamount = rnd(10); /* pick an # of monster traits that are more common --Amy */

	u.frequenttrait1 = rnd(434); /* same as monstercolor function */
	u.freqtraitbonus1 = rne(4);
	if (!rn2(5)) u.freqtraitbonus1 += rne(3);
	if (!rn2(3)) u.freqtraitbonus1 *= 2;
	if (!rn2(5)) u.freqtraitbonus1 *= 2;
	if (!rn2(8)) u.freqtraitbonus1 += rne(4);
	if (!rn2(12)) u.freqtraitbonus1 *= (1 + rne(15));
	if (!rn2(20)) u.freqtraitbonus1 *= 3;
	if (!rn2(60)) u.freqtraitbonus1 *= (1 + rne(12));
	if (!rn2(200)) u.freqtraitbonus1 *= 4;
	if (!rn2(360)) u.freqtraitbonus1 *= (1 + rne(10));
	if (!rn2(1360)) u.freqtraitbonus1 *= (1 + rne(8));
	if (!rn2(5000)) u.freqtraitbonus1 *= 5;
	if (!rn2(6360)) u.freqtraitbonus1 *= (1 + rne(7));
	if (!rn2(25000)) u.freqtraitbonus1 *= 6;
	if (!rn2(36360)) u.freqtraitbonus1 *= (1 + rne(5));
	if (u.freqtraitbonus1 > 100) u.freqtraitbonus1 = 100; /* fail safe */

	u.frequenttrait2 = 0;
	u.frequenttrait3 = 0;
	u.frequenttrait4 = 0;
	u.frequenttrait5 = 0;
	u.frequenttrait6 = 0;
	u.frequenttrait7 = 0;
	u.frequenttrait8 = 0;
	u.frequenttrait9 = 0;
	u.frequenttrait10 = 0;
	u.freqtraitbonus2 = 0;
	u.freqtraitbonus3 = 0;
	u.freqtraitbonus4 = 0;
	u.freqtraitbonus5 = 0;
	u.freqtraitbonus6 = 0;
	u.freqtraitbonus7 = 0;
	u.freqtraitbonus8 = 0;
	u.freqtraitbonus9 = 0;
	u.freqtraitbonus10 = 0;

	if (traitamount >= 2) {

		u.frequenttrait2 = rnd(434);
		u.freqtraitbonus2 = rne(4);
		if (!rn2(5)) u.freqtraitbonus2 += rne(3);
		if (!rn2(3)) u.freqtraitbonus2 *= 2;
		if (!rn2(5)) u.freqtraitbonus2 *= 2;
		if (!rn2(8)) u.freqtraitbonus2 += rne(4);
		if (!rn2(12)) u.freqtraitbonus2 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus2 *= 3;
		if (!rn2(60)) u.freqtraitbonus2 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus2 *= 4;
		if (!rn2(360)) u.freqtraitbonus2 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus2 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus2 *= 5;
		if (!rn2(6360)) u.freqtraitbonus2 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus2 *= 6;
		if (!rn2(36360)) u.freqtraitbonus2 *= (1 + rne(5));
		if (u.freqtraitbonus2 > 100) u.freqtraitbonus2 = 100; /* fail safe */

	}

	if (traitamount >= 3) {

		u.frequenttrait3 = rnd(434);
		u.freqtraitbonus3 = rne(4);
		if (!rn2(5)) u.freqtraitbonus3 += rne(3);
		if (!rn2(3)) u.freqtraitbonus3 *= 2;
		if (!rn2(5)) u.freqtraitbonus3 *= 2;
		if (!rn2(8)) u.freqtraitbonus3 += rne(4);
		if (!rn2(12)) u.freqtraitbonus3 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus3 *= 3;
		if (!rn2(60)) u.freqtraitbonus3 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus3 *= 4;
		if (!rn2(360)) u.freqtraitbonus3 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus3 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus3 *= 5;
		if (!rn2(6360)) u.freqtraitbonus3 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus3 *= 6;
		if (!rn2(36360)) u.freqtraitbonus3 *= (1 + rne(5));
		if (u.freqtraitbonus3 > 100) u.freqtraitbonus3 = 100; /* fail safe */

	}

	if (traitamount >= 4) {

		u.frequenttrait4 = rnd(434);
		u.freqtraitbonus4 = rne(4);
		if (!rn2(5)) u.freqtraitbonus4 += rne(3);
		if (!rn2(3)) u.freqtraitbonus4 *= 2;
		if (!rn2(5)) u.freqtraitbonus4 *= 2;
		if (!rn2(8)) u.freqtraitbonus4 += rne(4);
		if (!rn2(12)) u.freqtraitbonus4 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus4 *= 3;
		if (!rn2(60)) u.freqtraitbonus4 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus4 *= 4;
		if (!rn2(360)) u.freqtraitbonus4 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus4 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus4 *= 5;
		if (!rn2(6360)) u.freqtraitbonus4 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus4 *= 6;
		if (!rn2(36360)) u.freqtraitbonus4 *= (1 + rne(5));
		if (u.freqtraitbonus4 > 100) u.freqtraitbonus4 = 100; /* fail safe */

	}

	if (traitamount >= 5) {

		u.frequenttrait5 = rnd(434);
		u.freqtraitbonus5 = rne(4);
		if (!rn2(5)) u.freqtraitbonus5 += rne(3);
		if (!rn2(3)) u.freqtraitbonus5 *= 2;
		if (!rn2(5)) u.freqtraitbonus5 *= 2;
		if (!rn2(8)) u.freqtraitbonus5 += rne(4);
		if (!rn2(12)) u.freqtraitbonus5 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus5 *= 3;
		if (!rn2(60)) u.freqtraitbonus5 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus5 *= 4;
		if (!rn2(360)) u.freqtraitbonus5 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus5 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus5 *= 5;
		if (!rn2(6360)) u.freqtraitbonus5 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus5 *= 6;
		if (!rn2(36360)) u.freqtraitbonus5 *= (1 + rne(5));
		if (u.freqtraitbonus5 > 100) u.freqtraitbonus5 = 100; /* fail safe */

	}

	if (traitamount >= 6) {

		u.frequenttrait6 = rnd(434);
		u.freqtraitbonus6 = rne(4);
		if (!rn2(5)) u.freqtraitbonus6 += rne(3);
		if (!rn2(3)) u.freqtraitbonus6 *= 2;
		if (!rn2(5)) u.freqtraitbonus6 *= 2;
		if (!rn2(8)) u.freqtraitbonus6 += rne(4);
		if (!rn2(12)) u.freqtraitbonus6 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus6 *= 3;
		if (!rn2(60)) u.freqtraitbonus6 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus6 *= 4;
		if (!rn2(360)) u.freqtraitbonus6 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus6 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus6 *= 5;
		if (!rn2(6360)) u.freqtraitbonus6 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus6 *= 6;
		if (!rn2(36360)) u.freqtraitbonus6 *= (1 + rne(5));
		if (u.freqtraitbonus6 > 100) u.freqtraitbonus6 = 100; /* fail safe */

	}

	if (traitamount >= 7) {

		u.frequenttrait7 = rnd(434);
		u.freqtraitbonus7 = rne(4);
		if (!rn2(5)) u.freqtraitbonus7 += rne(3);
		if (!rn2(3)) u.freqtraitbonus7 *= 2;
		if (!rn2(5)) u.freqtraitbonus7 *= 2;
		if (!rn2(8)) u.freqtraitbonus7 += rne(4);
		if (!rn2(12)) u.freqtraitbonus7 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus7 *= 3;
		if (!rn2(60)) u.freqtraitbonus7 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus7 *= 4;
		if (!rn2(360)) u.freqtraitbonus7 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus7 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus7 *= 5;
		if (!rn2(6360)) u.freqtraitbonus7 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus7 *= 6;
		if (!rn2(36360)) u.freqtraitbonus7 *= (1 + rne(5));
		if (u.freqtraitbonus7 > 100) u.freqtraitbonus7 = 100; /* fail safe */

	}

	if (traitamount >= 8) {

		u.frequenttrait8 = rnd(434);
		u.freqtraitbonus8 = rne(4);
		if (!rn2(5)) u.freqtraitbonus8 += rne(3);
		if (!rn2(3)) u.freqtraitbonus8 *= 2;
		if (!rn2(5)) u.freqtraitbonus8 *= 2;
		if (!rn2(8)) u.freqtraitbonus8 += rne(4);
		if (!rn2(12)) u.freqtraitbonus8 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus8 *= 3;
		if (!rn2(60)) u.freqtraitbonus8 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus8 *= 4;
		if (!rn2(360)) u.freqtraitbonus8 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus8 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus8 *= 5;
		if (!rn2(6360)) u.freqtraitbonus8 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus8 *= 6;
		if (!rn2(36360)) u.freqtraitbonus8 *= (1 + rne(5));
		if (u.freqtraitbonus8 > 100) u.freqtraitbonus8 = 100; /* fail safe */

	}

	if (traitamount >= 9) {

		u.frequenttrait9 = rnd(434);
		u.freqtraitbonus9 = rne(4);
		if (!rn2(5)) u.freqtraitbonus9 += rne(3);
		if (!rn2(3)) u.freqtraitbonus9 *= 2;
		if (!rn2(5)) u.freqtraitbonus9 *= 2;
		if (!rn2(8)) u.freqtraitbonus9 += rne(4);
		if (!rn2(12)) u.freqtraitbonus9 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus9 *= 3;
		if (!rn2(60)) u.freqtraitbonus9 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus9 *= 4;
		if (!rn2(360)) u.freqtraitbonus9 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus9 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus9 *= 5;
		if (!rn2(6360)) u.freqtraitbonus9 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus9 *= 6;
		if (!rn2(36360)) u.freqtraitbonus9 *= (1 + rne(5));
		if (u.freqtraitbonus9 > 100) u.freqtraitbonus9 = 100; /* fail safe */

	}

	if (traitamount >= 10) {

		u.frequenttrait10 = rnd(434);
		u.freqtraitbonus10 = rne(4);
		if (!rn2(5)) u.freqtraitbonus10 += rne(3);
		if (!rn2(3)) u.freqtraitbonus10 *= 2;
		if (!rn2(5)) u.freqtraitbonus10 *= 2;
		if (!rn2(8)) u.freqtraitbonus10 += rne(4);
		if (!rn2(12)) u.freqtraitbonus10 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus10 *= 3;
		if (!rn2(60)) u.freqtraitbonus10 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus10 *= 4;
		if (!rn2(360)) u.freqtraitbonus10 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus10 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus10 *= 5;
		if (!rn2(6360)) u.freqtraitbonus10 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus10 *= 6;
		if (!rn2(36360)) u.freqtraitbonus10 *= (1 + rne(5));
		if (u.freqtraitbonus10 > 100) u.freqtraitbonus10 = 100; /* fail safe */

	}

	u.frequentspecies = -1;  
	u.frequentspecies2 = -1;  
	u.frequentspecies3 = -1;  
	u.frequentspecies4 = -1;  
	u.frequentspecies5 = -1;  
	u.frequentspecies6 = -1;  
	u.frequentspecies7 = -1;  
	u.frequentspecies8 = -1;  
	u.frequentspecies9 = -1;  
	u.frequentspecies10 = -1;  
	u.frequentspecies11 = -1;  
	u.frequentspecies12 = -1;  
	u.frequentspecies13 = -1;  
	u.frequentspecies14 = -1;  
	u.frequentspecies15 = -1;  
	u.frequentspecies16 = -1;  
	u.frequentspecies17 = -1;  
	u.frequentspecies18 = -1;  
	u.frequentspecies19 = -1;  
	u.frequentspecies20 = -1;  

	ptr = &mons[-1];
	while ((u.frequentspecies == 1) || (u.frequentspecies == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies];
	}
	u.freqspeciesbonus = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus += rne(2);
	u.freqspeciesbonus *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus *= 2;
	if (!rn2(7)) u.freqspeciesbonus *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus *= (1 + rne(2));
	if (u.freqspeciesbonus > 10000) u.freqspeciesbonus = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies2 == 1) || (u.frequentspecies2 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies2 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies2];
	}
	u.freqspeciesbonus2 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus2 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus2 += rne(2);
	u.freqspeciesbonus2 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus2 *= 2;
	if (!rn2(7)) u.freqspeciesbonus2 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus2 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus2 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus2 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus2 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus2 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus2 *= (1 + rne(2));
	if (u.freqspeciesbonus2 > 10000) u.freqspeciesbonus2 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies3 == 1) || (u.frequentspecies3 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies3 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies3];
	}
	u.freqspeciesbonus3 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus3 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus3 += rne(2);
	u.freqspeciesbonus3 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus3 *= 2;
	if (!rn2(7)) u.freqspeciesbonus3 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus3 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus3 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus3 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus3 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus3 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus3 *= (1 + rne(2));
	if (u.freqspeciesbonus3 > 10000) u.freqspeciesbonus3 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies4 == 1) || (u.frequentspecies4 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies4 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies4];
	}
	u.freqspeciesbonus4 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus4 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus4 += rne(2);
	u.freqspeciesbonus4 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus4 *= 2;
	if (!rn2(7)) u.freqspeciesbonus4 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus4 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus4 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus4 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus4 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus4 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus4 *= (1 + rne(2));
	if (u.freqspeciesbonus4 > 10000) u.freqspeciesbonus4 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies5 == 1) || (u.frequentspecies5 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies5 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies5];
	}
	u.freqspeciesbonus5 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus5 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus5 += rne(2);
	u.freqspeciesbonus5 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus5 *= 2;
	if (!rn2(7)) u.freqspeciesbonus5 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus5 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus5 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus5 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus5 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus5 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus5 *= (1 + rne(2));
	if (u.freqspeciesbonus5 > 10000) u.freqspeciesbonus5 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies6 == 1) || (u.frequentspecies6 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies6 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies6];
	}
	u.freqspeciesbonus6 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus6 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus6 += rne(2);
	u.freqspeciesbonus6 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus6 *= 2;
	if (!rn2(7)) u.freqspeciesbonus6 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus6 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus6 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus6 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus6 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus6 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus6 *= (1 + rne(2));
	if (u.freqspeciesbonus6 > 10000) u.freqspeciesbonus6 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies7 == 1) || (u.frequentspecies7 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies7 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies7];
	}
	u.freqspeciesbonus7 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus7 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus7 += rne(2);
	u.freqspeciesbonus7 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus7 *= 2;
	if (!rn2(7)) u.freqspeciesbonus7 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus7 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus7 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus7 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus7 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus7 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus7 *= (1 + rne(2));
	if (u.freqspeciesbonus7 > 10000) u.freqspeciesbonus7 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies8 == 1) || (u.frequentspecies8 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies8 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies8];
	}
	u.freqspeciesbonus8 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus8 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus8 += rne(2);
	u.freqspeciesbonus8 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus8 *= 2;
	if (!rn2(7)) u.freqspeciesbonus8 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus8 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus8 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus8 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus8 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus8 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus8 *= (1 + rne(2));
	if (u.freqspeciesbonus8 > 10000) u.freqspeciesbonus8 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies9 == 1) || (u.frequentspecies9 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies9 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies9];
	}
	u.freqspeciesbonus9 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus9 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus9 += rne(2);
	u.freqspeciesbonus9 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus9 *= 2;
	if (!rn2(7)) u.freqspeciesbonus9 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus9 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus9 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus9 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus9 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus9 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus9 *= (1 + rne(2));
	if (u.freqspeciesbonus9 > 10000) u.freqspeciesbonus9 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies10 == 1) || (u.frequentspecies10 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies10 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies10];
	}
	u.freqspeciesbonus10 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus10 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus10 += rne(2);
	u.freqspeciesbonus10 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus10 *= 2;
	if (!rn2(7)) u.freqspeciesbonus10 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus10 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus10 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus10 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus10 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus10 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus10 *= (1 + rne(2));
	if (u.freqspeciesbonus10 > 10000) u.freqspeciesbonus10 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies11 == 1) || (u.frequentspecies11 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies11 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies11];
	}
	u.freqspeciesbonus11 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus11 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus11 += rne(2);
	u.freqspeciesbonus11 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus11 *= 2;
	if (!rn2(7)) u.freqspeciesbonus11 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus11 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus11 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus11 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus11 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus11 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus11 *= (1 + rne(2));
	if (u.freqspeciesbonus11 > 10000) u.freqspeciesbonus11 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies12 == 1) || (u.frequentspecies12 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies12 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies12];
	}
	u.freqspeciesbonus12 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus12 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus12 += rne(2);
	u.freqspeciesbonus12 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus12 *= 2;
	if (!rn2(7)) u.freqspeciesbonus12 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus12 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus12 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus12 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus12 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus12 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus12 *= (1 + rne(2));
	if (u.freqspeciesbonus12 > 10000) u.freqspeciesbonus12 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies13 == 1) || (u.frequentspecies13 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies13 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies13];
	}
	u.freqspeciesbonus13 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus13 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus13 += rne(2);
	u.freqspeciesbonus13 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus13 *= 2;
	if (!rn2(7)) u.freqspeciesbonus13 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus13 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus13 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus13 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus13 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus13 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus13 *= (1 + rne(2));
	if (u.freqspeciesbonus13 > 10000) u.freqspeciesbonus13 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies14 == 1) || (u.frequentspecies14 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies14 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies14];
	}
	u.freqspeciesbonus14 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus14 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus14 += rne(2);
	u.freqspeciesbonus14 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus14 *= 2;
	if (!rn2(7)) u.freqspeciesbonus14 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus14 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus14 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus14 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus14 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus14 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus14 *= (1 + rne(2));
	if (u.freqspeciesbonus14 > 10000) u.freqspeciesbonus14 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies15 == 1) || (u.frequentspecies15 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies15 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies15];
	}
	u.freqspeciesbonus15 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus15 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus15 += rne(2);
	u.freqspeciesbonus15 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus15 *= 2;
	if (!rn2(7)) u.freqspeciesbonus15 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus15 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus15 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus15 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus15 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus15 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus15 *= (1 + rne(2));
	if (u.freqspeciesbonus15 > 10000) u.freqspeciesbonus15 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies16 == 1) || (u.frequentspecies16 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies16 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies16];
	}
	u.freqspeciesbonus16 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus16 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus16 += rne(2);
	u.freqspeciesbonus16 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus16 *= 2;
	if (!rn2(7)) u.freqspeciesbonus16 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus16 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus16 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus16 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus16 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus16 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus16 *= (1 + rne(2));
	if (u.freqspeciesbonus16 > 10000) u.freqspeciesbonus16 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies17 == 1) || (u.frequentspecies17 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies17 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies17];
	}
	u.freqspeciesbonus17 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus17 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus17 += rne(2);
	u.freqspeciesbonus17 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus17 *= 2;
	if (!rn2(7)) u.freqspeciesbonus17 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus17 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus17 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus17 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus17 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus17 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus17 *= (1 + rne(2));
	if (u.freqspeciesbonus17 > 10000) u.freqspeciesbonus17 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies18 == 1) || (u.frequentspecies18 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies18 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies18];
	}
	u.freqspeciesbonus18 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus18 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus18 += rne(2);
	u.freqspeciesbonus18 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus18 *= 2;
	if (!rn2(7)) u.freqspeciesbonus18 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus18 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus18 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus18 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus18 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus18 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus18 *= (1 + rne(2));
	if (u.freqspeciesbonus18 > 10000) u.freqspeciesbonus18 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies19 == 1) || (u.frequentspecies19 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies19 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies19];
	}
	u.freqspeciesbonus19 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus19 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus19 += rne(2);
	u.freqspeciesbonus19 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus19 *= 2;
	if (!rn2(7)) u.freqspeciesbonus19 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus19 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus19 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus19 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus19 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus19 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus19 *= (1 + rne(2));
	if (u.freqspeciesbonus19 > 10000) u.freqspeciesbonus19 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies20 == 1) || (u.frequentspecies20 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies20 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies20];
	}
	u.freqspeciesbonus20 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus20 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus20 += rne(2);
	u.freqspeciesbonus20 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus20 *= 2;
	if (!rn2(7)) u.freqspeciesbonus20 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus20 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus20 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus20 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus20 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus20 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus20 *= (1 + rne(2));
	if (u.freqspeciesbonus20 > 10000) u.freqspeciesbonus20 = 10000; /* fail safe */

	u.nospawnspecies = -1;  
	u.nospawnspecies2 = -1;  
	u.nospawnspecies3 = -1;  
	u.nospawnspecies4 = -1;  
	u.nospawnspecies5 = -1;  
	u.nospawnspecies6 = -1;  
	u.nospawnspecies7 = -1;  
	u.nospawnspecies8 = -1;  
	u.nospawnspecies9 = -1;  
	u.nospawnspecies10 = -1;  

	ptr = &mons[-1];
	while ((u.nospawnspecies == 1) || (u.nospawnspecies == -1) || (u.nospawnspecies == u.frequentspecies) || (u.nospawnspecies == u.frequentspecies2) || (u.nospawnspecies == u.frequentspecies3) || (u.nospawnspecies == u.frequentspecies4) || (u.nospawnspecies == u.frequentspecies5) || (u.nospawnspecies == u.frequentspecies6) || (u.nospawnspecies == u.frequentspecies7) || (u.nospawnspecies == u.frequentspecies8) || (u.nospawnspecies == u.frequentspecies9) || (u.nospawnspecies == u.frequentspecies10) || (u.nospawnspecies == u.frequentspecies11) || (u.nospawnspecies == u.frequentspecies12) || (u.nospawnspecies == u.frequentspecies13) || (u.nospawnspecies == u.frequentspecies14) || (u.nospawnspecies == u.frequentspecies15) || (u.nospawnspecies == u.frequentspecies16) || (u.nospawnspecies == u.frequentspecies17) || (u.nospawnspecies == u.frequentspecies18) || (u.nospawnspecies == u.frequentspecies19) || (u.nospawnspecies == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies2 == 1) || (u.nospawnspecies2 == -1) || (u.nospawnspecies2 == u.frequentspecies) || (u.nospawnspecies2 == u.frequentspecies2) || (u.nospawnspecies2 == u.frequentspecies3) || (u.nospawnspecies2 == u.frequentspecies4) || (u.nospawnspecies2 == u.frequentspecies5) || (u.nospawnspecies2 == u.frequentspecies6) || (u.nospawnspecies2 == u.frequentspecies7) || (u.nospawnspecies2 == u.frequentspecies8) || (u.nospawnspecies2 == u.frequentspecies9) || (u.nospawnspecies2 == u.frequentspecies10) || (u.nospawnspecies2 == u.frequentspecies11) || (u.nospawnspecies2 == u.frequentspecies12) || (u.nospawnspecies2 == u.frequentspecies13) || (u.nospawnspecies2 == u.frequentspecies14) || (u.nospawnspecies2 == u.frequentspecies15) || (u.nospawnspecies2 == u.frequentspecies16) || (u.nospawnspecies2 == u.frequentspecies17) || (u.nospawnspecies2 == u.frequentspecies18) || (u.nospawnspecies2 == u.frequentspecies19) || (u.nospawnspecies2 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies2 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies2];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies3 == 1) || (u.nospawnspecies3 == -1) || (u.nospawnspecies3 == u.frequentspecies) || (u.nospawnspecies3 == u.frequentspecies2) || (u.nospawnspecies3 == u.frequentspecies3) || (u.nospawnspecies3 == u.frequentspecies4) || (u.nospawnspecies3 == u.frequentspecies5) || (u.nospawnspecies3 == u.frequentspecies6) || (u.nospawnspecies3 == u.frequentspecies7) || (u.nospawnspecies3 == u.frequentspecies8) || (u.nospawnspecies3 == u.frequentspecies9) || (u.nospawnspecies3 == u.frequentspecies10) || (u.nospawnspecies3 == u.frequentspecies11) || (u.nospawnspecies3 == u.frequentspecies12) || (u.nospawnspecies3 == u.frequentspecies13) || (u.nospawnspecies3 == u.frequentspecies14) || (u.nospawnspecies3 == u.frequentspecies15) || (u.nospawnspecies3 == u.frequentspecies16) || (u.nospawnspecies3 == u.frequentspecies17) || (u.nospawnspecies3 == u.frequentspecies18) || (u.nospawnspecies3 == u.frequentspecies19) || (u.nospawnspecies3 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies3 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies3];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies4 == 1) || (u.nospawnspecies4 == -1) || (u.nospawnspecies4 == u.frequentspecies) || (u.nospawnspecies4 == u.frequentspecies2) || (u.nospawnspecies4 == u.frequentspecies3) || (u.nospawnspecies4 == u.frequentspecies4) || (u.nospawnspecies4 == u.frequentspecies5) || (u.nospawnspecies4 == u.frequentspecies6) || (u.nospawnspecies4 == u.frequentspecies7) || (u.nospawnspecies4 == u.frequentspecies8) || (u.nospawnspecies4 == u.frequentspecies9) || (u.nospawnspecies4 == u.frequentspecies10) || (u.nospawnspecies4 == u.frequentspecies11) || (u.nospawnspecies4 == u.frequentspecies12) || (u.nospawnspecies4 == u.frequentspecies13) || (u.nospawnspecies4 == u.frequentspecies14) || (u.nospawnspecies4 == u.frequentspecies15) || (u.nospawnspecies4 == u.frequentspecies16) || (u.nospawnspecies4 == u.frequentspecies17) || (u.nospawnspecies4 == u.frequentspecies18) || (u.nospawnspecies4 == u.frequentspecies19) || (u.nospawnspecies4 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies4 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies4];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies5 == 1) || (u.nospawnspecies5 == -1) || (u.nospawnspecies5 == u.frequentspecies) || (u.nospawnspecies5 == u.frequentspecies2) || (u.nospawnspecies5 == u.frequentspecies3) || (u.nospawnspecies5 == u.frequentspecies4) || (u.nospawnspecies5 == u.frequentspecies5) || (u.nospawnspecies5 == u.frequentspecies6) || (u.nospawnspecies5 == u.frequentspecies7) || (u.nospawnspecies5 == u.frequentspecies8) || (u.nospawnspecies5 == u.frequentspecies9) || (u.nospawnspecies5 == u.frequentspecies10) || (u.nospawnspecies5 == u.frequentspecies11) || (u.nospawnspecies5 == u.frequentspecies12) || (u.nospawnspecies5 == u.frequentspecies13) || (u.nospawnspecies5 == u.frequentspecies14) || (u.nospawnspecies5 == u.frequentspecies15) || (u.nospawnspecies5 == u.frequentspecies16) || (u.nospawnspecies5 == u.frequentspecies17) || (u.nospawnspecies5 == u.frequentspecies18) || (u.nospawnspecies5 == u.frequentspecies19) || (u.nospawnspecies5 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies5 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies5];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies6 == 1) || (u.nospawnspecies6 == -1) || (u.nospawnspecies6 == u.frequentspecies) || (u.nospawnspecies6 == u.frequentspecies2) || (u.nospawnspecies6 == u.frequentspecies3) || (u.nospawnspecies6 == u.frequentspecies4) || (u.nospawnspecies6 == u.frequentspecies5) || (u.nospawnspecies6 == u.frequentspecies6) || (u.nospawnspecies6 == u.frequentspecies7) || (u.nospawnspecies6 == u.frequentspecies8) || (u.nospawnspecies6 == u.frequentspecies9) || (u.nospawnspecies6 == u.frequentspecies10) || (u.nospawnspecies6 == u.frequentspecies11) || (u.nospawnspecies6 == u.frequentspecies12) || (u.nospawnspecies6 == u.frequentspecies13) || (u.nospawnspecies6 == u.frequentspecies14) || (u.nospawnspecies6 == u.frequentspecies15) || (u.nospawnspecies6 == u.frequentspecies16) || (u.nospawnspecies6 == u.frequentspecies17) || (u.nospawnspecies6 == u.frequentspecies18) || (u.nospawnspecies6 == u.frequentspecies19) || (u.nospawnspecies6 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies6 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies6];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies7 == 1) || (u.nospawnspecies7 == -1) || (u.nospawnspecies7 == u.frequentspecies) || (u.nospawnspecies7 == u.frequentspecies2) || (u.nospawnspecies7 == u.frequentspecies3) || (u.nospawnspecies7 == u.frequentspecies4) || (u.nospawnspecies7 == u.frequentspecies5) || (u.nospawnspecies7 == u.frequentspecies6) || (u.nospawnspecies7 == u.frequentspecies7) || (u.nospawnspecies7 == u.frequentspecies8) || (u.nospawnspecies7 == u.frequentspecies9) || (u.nospawnspecies7 == u.frequentspecies10) || (u.nospawnspecies7 == u.frequentspecies11) || (u.nospawnspecies7 == u.frequentspecies12) || (u.nospawnspecies7 == u.frequentspecies13) || (u.nospawnspecies7 == u.frequentspecies14) || (u.nospawnspecies7 == u.frequentspecies15) || (u.nospawnspecies7 == u.frequentspecies16) || (u.nospawnspecies7 == u.frequentspecies17) || (u.nospawnspecies7 == u.frequentspecies18) || (u.nospawnspecies7 == u.frequentspecies19) || (u.nospawnspecies7 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies7 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies7];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies8 == 1) || (u.nospawnspecies8 == -1) || (u.nospawnspecies8 == u.frequentspecies) || (u.nospawnspecies8 == u.frequentspecies2) || (u.nospawnspecies8 == u.frequentspecies3) || (u.nospawnspecies8 == u.frequentspecies4) || (u.nospawnspecies8 == u.frequentspecies5) || (u.nospawnspecies8 == u.frequentspecies6) || (u.nospawnspecies8 == u.frequentspecies7) || (u.nospawnspecies8 == u.frequentspecies8) || (u.nospawnspecies8 == u.frequentspecies9) || (u.nospawnspecies8 == u.frequentspecies10) || (u.nospawnspecies8 == u.frequentspecies11) || (u.nospawnspecies8 == u.frequentspecies12) || (u.nospawnspecies8 == u.frequentspecies13) || (u.nospawnspecies8 == u.frequentspecies14) || (u.nospawnspecies8 == u.frequentspecies15) || (u.nospawnspecies8 == u.frequentspecies16) || (u.nospawnspecies8 == u.frequentspecies17) || (u.nospawnspecies8 == u.frequentspecies18) || (u.nospawnspecies8 == u.frequentspecies19) || (u.nospawnspecies8 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies8 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies8];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies9 == 1) || (u.nospawnspecies9 == -1) || (u.nospawnspecies9 == u.frequentspecies) || (u.nospawnspecies9 == u.frequentspecies2) || (u.nospawnspecies9 == u.frequentspecies3) || (u.nospawnspecies9 == u.frequentspecies4) || (u.nospawnspecies9 == u.frequentspecies5) || (u.nospawnspecies9 == u.frequentspecies6) || (u.nospawnspecies9 == u.frequentspecies7) || (u.nospawnspecies9 == u.frequentspecies8) || (u.nospawnspecies9 == u.frequentspecies9) || (u.nospawnspecies9 == u.frequentspecies10) || (u.nospawnspecies9 == u.frequentspecies11) || (u.nospawnspecies9 == u.frequentspecies12) || (u.nospawnspecies9 == u.frequentspecies13) || (u.nospawnspecies9 == u.frequentspecies14) || (u.nospawnspecies9 == u.frequentspecies15) || (u.nospawnspecies9 == u.frequentspecies16) || (u.nospawnspecies9 == u.frequentspecies17) || (u.nospawnspecies9 == u.frequentspecies18) || (u.nospawnspecies9 == u.frequentspecies19) || (u.nospawnspecies9 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies9 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies9];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies10 == 1) || (u.nospawnspecies10 == -1) || (u.nospawnspecies10 == u.frequentspecies) || (u.nospawnspecies10 == u.frequentspecies2) || (u.nospawnspecies10 == u.frequentspecies3) || (u.nospawnspecies10 == u.frequentspecies4) || (u.nospawnspecies10 == u.frequentspecies5) || (u.nospawnspecies10 == u.frequentspecies6) || (u.nospawnspecies10 == u.frequentspecies7) || (u.nospawnspecies10 == u.frequentspecies8) || (u.nospawnspecies10 == u.frequentspecies9) || (u.nospawnspecies10 == u.frequentspecies10) || (u.nospawnspecies10 == u.frequentspecies11) || (u.nospawnspecies10 == u.frequentspecies12) || (u.nospawnspecies10 == u.frequentspecies13) || (u.nospawnspecies10 == u.frequentspecies14) || (u.nospawnspecies10 == u.frequentspecies15) || (u.nospawnspecies10 == u.frequentspecies16) || (u.nospawnspecies10 == u.frequentspecies17) || (u.nospawnspecies10 == u.frequentspecies18) || (u.nospawnspecies10 == u.frequentspecies19) || (u.nospawnspecies10 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies10 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies10];
	}

	u.minimalism = 1 + rnd(4);
	if (!rn2(10)) u.minimalism += rnd(5);
	if (!rn2(100)) u.minimalism += rnz(5);

	u.femauspices4 = rnd(12);
	u.femauspices6 = rnd(12);
	u.femauspices8 = rnd(13);
	u.femauspices11 = rnd(16);
	u.femauspices13 = rnd(10);
	u.femauspices15 = rnd(10);
	u.femauspices17 = rnd(10);
	u.femauspices20 = rnd(10);
	u.femauspices22 = rnd(12);
	u.femauspices25 = rnd(10);
	u.femauspices28 = rnd(9);
	u.femauspices30 = rnd(10);

	u.feminizeffect = rnd(103); /* amount of feminism trap effects; keyword: "marlena" */
	u.contamjeweleffect = rnd(103); /* amount of feminism trap effects; keyword: "marlena" */

	u.climauspices3 = rnd(103);
	u.climauspices6 = rnd(103);
	u.climauspices9 = rnd(103);
	u.climauspices12 = rnd(103);
	u.climauspices15 = rnd(103);
	u.climauspices18 = rnd(103);
	u.climauspices21 = rnd(103);
	u.climauspices24 = rnd(103);
	u.climauspices27 = rnd(103);
	u.climauspices30 = rnd(103);

	u.sjwL1E1 = rnd(275); /* timerun and stuff */
	u.sjwL2E1 = rnd(275);
	u.sjwL3E1 = rnd(275);
	u.sjwL4E1 = rnd(275);
	u.sjwL5E1 = rnd(275);
	u.sjwL5E2 = rnd(275);
	u.sjwL6E1 = rnd(275);
	u.sjwL6E2 = rnd(275);
	u.sjwL7E1 = rnd(275);
	u.sjwL7E2 = rnd(275);
	u.sjwL8E1 = rnd(275);
	u.sjwL8E2 = rnd(275);
	u.sjwL9E1 = rnd(275);
	u.sjwL9E2 = rnd(275);
	u.sjwL10E1 = rnd(275);
	u.sjwL10E2 = rnd(275);
	u.sjwL10E3 = rnd(275);
	u.sjwL11E1 = rnd(275);
	u.sjwL11E2 = rnd(275);
	u.sjwL11E3 = rnd(275);
	u.sjwL12E1 = rnd(275);
	u.sjwL12E2 = rnd(275);
	u.sjwL12E3 = rnd(275);
	u.sjwL13E1 = rnd(275);
	u.sjwL13E2 = rnd(275);
	u.sjwL13E3 = rnd(275);
	u.sjwL14E1 = rnd(275);
	u.sjwL14E2 = rnd(275);
	u.sjwL14E3 = rnd(275);
	u.sjwL15E1 = rnd(275);
	u.sjwL15E2 = rnd(275);
	u.sjwL15E3 = rnd(275);
	u.sjwL15E4 = rnd(275);
	u.sjwL16E1 = rnd(275);
	u.sjwL16E2 = rnd(275);
	u.sjwL16E3 = rnd(275);
	u.sjwL16E4 = rnd(275);
	u.sjwL17E1 = rnd(275);
	u.sjwL17E2 = rnd(275);
	u.sjwL17E3 = rnd(275);
	u.sjwL17E4 = rnd(275);
	u.sjwL18E1 = rnd(275);
	u.sjwL18E2 = rnd(275);
	u.sjwL18E3 = rnd(275);
	u.sjwL18E4 = rnd(275);
	u.sjwL19E1 = rnd(275);
	u.sjwL19E2 = rnd(275);
	u.sjwL19E3 = rnd(275);
	u.sjwL19E4 = rnd(275);
	u.sjwL20E1 = rnd(275);
	u.sjwL20E2 = rnd(275);
	u.sjwL20E3 = rnd(275);
	u.sjwL20E4 = rnd(275);
	u.sjwL20E5 = rnd(275);
	u.sjwL21E1 = rnd(275);
	u.sjwL21E2 = rnd(275);
	u.sjwL21E3 = rnd(275);
	u.sjwL21E4 = rnd(275);
	u.sjwL21E5 = rnd(275);
	u.sjwL22E1 = rnd(275);
	u.sjwL22E2 = rnd(275);
	u.sjwL22E3 = rnd(275);
	u.sjwL22E4 = rnd(275);
	u.sjwL22E5 = rnd(275);
	u.sjwL23E1 = rnd(275);
	u.sjwL23E2 = rnd(275);
	u.sjwL23E3 = rnd(275);
	u.sjwL23E4 = rnd(275);
	u.sjwL23E5 = rnd(275);
	u.sjwL24E1 = rnd(275);
	u.sjwL24E2 = rnd(275);
	u.sjwL24E3 = rnd(275);
	u.sjwL24E4 = rnd(275);
	u.sjwL24E5 = rnd(275);
	u.sjwL25E1 = rnd(275);
	u.sjwL25E2 = rnd(275);
	u.sjwL25E3 = rnd(275);
	u.sjwL25E4 = rnd(275);
	u.sjwL25E5 = rnd(275);
	u.sjwL25E6 = rnd(275);
	u.sjwL26E1 = rnd(275);
	u.sjwL26E2 = rnd(275);
	u.sjwL26E3 = rnd(275);
	u.sjwL26E4 = rnd(275);
	u.sjwL26E5 = rnd(275);
	u.sjwL26E6 = rnd(275);
	u.sjwL27E1 = rnd(275);
	u.sjwL27E2 = rnd(275);
	u.sjwL27E3 = rnd(275);
	u.sjwL27E4 = rnd(275);
	u.sjwL27E5 = rnd(275);
	u.sjwL27E6 = rnd(275);
	u.sjwL28E1 = rnd(275);
	u.sjwL28E2 = rnd(275);
	u.sjwL28E3 = rnd(275);
	u.sjwL28E4 = rnd(275);
	u.sjwL28E5 = rnd(275);
	u.sjwL28E6 = rnd(275);
	u.sjwL29E1 = rnd(275);
	u.sjwL29E2 = rnd(275);
	u.sjwL29E3 = rnd(275);
	u.sjwL29E4 = rnd(275);
	u.sjwL29E5 = rnd(275);
	u.sjwL29E6 = rnd(275);
	u.sjwL30E1 = rnd(275);
	u.sjwL30E2 = rnd(275);
	u.sjwL30E3 = rnd(275);
	u.sjwL30E4 = rnd(275);
	u.sjwL30E5 = rnd(275);
	u.sjwL30E6 = rnd(275);
	u.sjwL30E7 = rnd(275);
	u.sjwL31E1 = rnd(275);
	u.sjwL31E2 = rnd(275);
	u.sjwL31E3 = rnd(275);
	u.sjwL31E4 = rnd(275);
	u.sjwL31E5 = rnd(275);
	u.sjwL31E6 = rnd(275);
	u.sjwL31E7 = rnd(275);
	u.sjwL32E1 = rnd(275);
	u.sjwL32E2 = rnd(275);
	u.sjwL32E3 = rnd(275);
	u.sjwL32E4 = rnd(275);
	u.sjwL32E5 = rnd(275);
	u.sjwL32E6 = rnd(275);
	u.sjwL32E7 = rnd(275);
	u.sjwL33E1 = rnd(275);
	u.sjwL33E2 = rnd(275);
	u.sjwL33E3 = rnd(275);
	u.sjwL33E4 = rnd(275);
	u.sjwL33E5 = rnd(275);
	u.sjwL33E6 = rnd(275);
	u.sjwL33E7 = rnd(275);
	u.sjwL34E1 = rnd(275);
	u.sjwL34E2 = rnd(275);
	u.sjwL34E3 = rnd(275);
	u.sjwL34E4 = rnd(275);
	u.sjwL34E5 = rnd(275);
	u.sjwL34E6 = rnd(275);
	u.sjwL34E7 = rnd(275);
	u.sjwL35E1 = rnd(275);
	u.sjwL35E2 = rnd(275);
	u.sjwL35E3 = rnd(275);
	u.sjwL35E4 = rnd(275);
	u.sjwL35E5 = rnd(275);
	u.sjwL35E6 = rnd(275);
	u.sjwL35E7 = rnd(275);
	u.sjwL36E1 = rnd(275);
	u.sjwL36E2 = rnd(275);
	u.sjwL36E3 = rnd(275);
	u.sjwL36E4 = rnd(275);
	u.sjwL36E5 = rnd(275);
	u.sjwL36E6 = rnd(275);
	u.sjwL36E7 = rnd(275);
	u.sjwL37E1 = rnd(275);
	u.sjwL37E2 = rnd(275);
	u.sjwL37E3 = rnd(275);
	u.sjwL37E4 = rnd(275);
	u.sjwL37E5 = rnd(275);
	u.sjwL37E6 = rnd(275);
	u.sjwL37E7 = rnd(275);
	u.sjwL38E1 = rnd(275);
	u.sjwL38E2 = rnd(275);
	u.sjwL38E3 = rnd(275);
	u.sjwL38E4 = rnd(275);
	u.sjwL38E5 = rnd(275);
	u.sjwL38E6 = rnd(275);
	u.sjwL38E7 = rnd(275);
	u.sjwL39E1 = rnd(275);
	u.sjwL39E2 = rnd(275);
	u.sjwL39E3 = rnd(275);
	u.sjwL39E4 = rnd(275);
	u.sjwL39E5 = rnd(275);
	u.sjwL39E6 = rnd(275);
	u.sjwL39E7 = rnd(275);
	u.sjwL40E1 = rnd(275);
	u.sjwL40E2 = rnd(275);
	u.sjwL40E3 = rnd(275);
	u.sjwL40E4 = rnd(275);
	u.sjwL40E5 = rnd(275);
	u.sjwL40E6 = rnd(275);
	u.sjwL40E7 = rnd(275);
	u.sjwL41E1 = rnd(275);
	u.sjwL41E2 = rnd(275);
	u.sjwL41E3 = rnd(275);
	u.sjwL41E4 = rnd(275);
	u.sjwL41E5 = rnd(275);
	u.sjwL41E6 = rnd(275);
	u.sjwL41E7 = rnd(275);
	u.sjwL42E1 = rnd(275);
	u.sjwL42E2 = rnd(275);
	u.sjwL42E3 = rnd(275);
	u.sjwL42E4 = rnd(275);
	u.sjwL42E5 = rnd(275);
	u.sjwL42E6 = rnd(275);
	u.sjwL42E7 = rnd(275);
	u.sjwL43E1 = rnd(275);
	u.sjwL43E2 = rnd(275);
	u.sjwL43E3 = rnd(275);
	u.sjwL43E4 = rnd(275);
	u.sjwL43E5 = rnd(275);
	u.sjwL43E6 = rnd(275);
	u.sjwL43E7 = rnd(275);
	u.sjwL44E1 = rnd(275);
	u.sjwL44E2 = rnd(275);
	u.sjwL44E3 = rnd(275);
	u.sjwL44E4 = rnd(275);
	u.sjwL44E5 = rnd(275);
	u.sjwL44E6 = rnd(275);
	u.sjwL44E7 = rnd(275);
	u.sjwL45E1 = rnd(275);
	u.sjwL45E2 = rnd(275);
	u.sjwL45E3 = rnd(275);
	u.sjwL45E4 = rnd(275);
	u.sjwL45E5 = rnd(275);
	u.sjwL45E6 = rnd(275);
	u.sjwL45E7 = rnd(275);
	u.sjwL46E1 = rnd(275);
	u.sjwL46E2 = rnd(275);
	u.sjwL46E3 = rnd(275);
	u.sjwL46E4 = rnd(275);
	u.sjwL46E5 = rnd(275);
	u.sjwL46E6 = rnd(275);
	u.sjwL46E7 = rnd(275);
	u.sjwL47E1 = rnd(275);
	u.sjwL47E2 = rnd(275);
	u.sjwL47E3 = rnd(275);
	u.sjwL47E4 = rnd(275);
	u.sjwL47E5 = rnd(275);
	u.sjwL47E6 = rnd(275);
	u.sjwL47E7 = rnd(275);
	u.sjwL48E1 = rnd(275);
	u.sjwL48E2 = rnd(275);
	u.sjwL48E3 = rnd(275);
	u.sjwL48E4 = rnd(275);
	u.sjwL48E5 = rnd(275);
	u.sjwL48E6 = rnd(275);
	u.sjwL48E7 = rnd(275);
	u.sjwL49E1 = rnd(275);
	u.sjwL49E2 = rnd(275);
	u.sjwL49E3 = rnd(275);
	u.sjwL49E4 = rnd(275);
	u.sjwL49E5 = rnd(275);
	u.sjwL49E6 = rnd(275);
	u.sjwL49E7 = rnd(275);
	u.sjwL50E1 = rnd(275);
	u.sjwL50E2 = rnd(275);
	u.sjwL50E3 = rnd(275);
	u.sjwL50E4 = rnd(275);
	u.sjwL50E5 = rnd(275);
	u.sjwL50E6 = rnd(275);
	u.sjwL50E7 = rnd(275);
	u.sjwL51E1 = rnd(275);
	u.sjwL51E2 = rnd(275);
	u.sjwL51E3 = rnd(275);
	u.sjwL51E4 = rnd(275);
	u.sjwL51E5 = rnd(275);
	u.sjwL51E6 = rnd(275);
	u.sjwL51E7 = rnd(275);
	u.sjwL52E1 = rnd(275);
	u.sjwL52E2 = rnd(275);
	u.sjwL52E3 = rnd(275);
	u.sjwL52E4 = rnd(275);
	u.sjwL52E5 = rnd(275);
	u.sjwL52E6 = rnd(275);
	u.sjwL52E7 = rnd(275);
	u.sjwL53E1 = rnd(275);
	u.sjwL53E2 = rnd(275);
	u.sjwL53E3 = rnd(275);
	u.sjwL53E4 = rnd(275);
	u.sjwL53E5 = rnd(275);
	u.sjwL53E6 = rnd(275);
	u.sjwL53E7 = rnd(275);
	u.sjwL54E1 = rnd(275);
	u.sjwL54E2 = rnd(275);
	u.sjwL54E3 = rnd(275);
	u.sjwL54E4 = rnd(275);
	u.sjwL54E5 = rnd(275);
	u.sjwL54E6 = rnd(275);
	u.sjwL54E7 = rnd(275);
	u.sjwL55E1 = rnd(275);
	u.sjwL55E2 = rnd(275);
	u.sjwL55E3 = rnd(275);
	u.sjwL55E4 = rnd(275);
	u.sjwL55E5 = rnd(275);
	u.sjwL55E6 = rnd(275);
	u.sjwL55E7 = rnd(275);
	u.sjwL56E1 = rnd(275);
	u.sjwL56E2 = rnd(275);
	u.sjwL56E3 = rnd(275);
	u.sjwL56E4 = rnd(275);
	u.sjwL56E5 = rnd(275);
	u.sjwL56E6 = rnd(275);
	u.sjwL56E7 = rnd(275);
	u.sjwL57E1 = rnd(275);
	u.sjwL57E2 = rnd(275);
	u.sjwL57E3 = rnd(275);
	u.sjwL57E4 = rnd(275);
	u.sjwL57E5 = rnd(275);
	u.sjwL57E6 = rnd(275);
	u.sjwL57E7 = rnd(275);
	u.sjwL58E1 = rnd(275);
	u.sjwL58E2 = rnd(275);
	u.sjwL58E3 = rnd(275);
	u.sjwL58E4 = rnd(275);
	u.sjwL58E5 = rnd(275);
	u.sjwL58E6 = rnd(275);
	u.sjwL58E7 = rnd(275);
	u.sjwL59E1 = rnd(275);
	u.sjwL59E2 = rnd(275);
	u.sjwL59E3 = rnd(275);
	u.sjwL59E4 = rnd(275);
	u.sjwL59E5 = rnd(275);
	u.sjwL59E6 = rnd(275);
	u.sjwL59E7 = rnd(275);

	u.dorian4 = rnd(275);
	u.dorian8 = rnd(275);
	u.dorian12 = rnd(275);
	u.dorian16 = rnd(275);
	u.dorian20 = rnd(275);
	u.dorian24 = rnd(275);
	u.dorian28 = rnd(275);

	u.startscummereffect = rnd(275);

	u.adpartattack = rn2(AD_ENDS);
	while (u.adpartattack == AD_ENDS || u.adpartattack == AD_WERE) u.adpartattack = rn2(AD_ENDS);
	u.adrunsattack = rnd(275); /* timerun etc. */

	u.scholarturns = 0;

	u.unobtainablegeno = -1;

	register int unobtitemamount = rnd(10); /* pick an # of items that are unobtainable --Amy */

	u.unobtainable = -1;
	while ( (u.unobtainable == -1) || (u.unobtainable == GOLD_PIECE) || (u.unobtainable == STRANGE_OBJECT) || (u.unobtainable == AMULET_OF_YENDOR) || (u.unobtainable == CANDELABRUM_OF_INVOCATION) || (u.unobtainable == BELL_OF_OPENING) || (u.unobtainable == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable].oc_prob < 1) ) u.unobtainable = rn2(NUM_OBJECTS);

	u.unobtainable2 = -1;
	if (unobtitemamount >= 2) {
	while ( (u.unobtainable2 == -1) || (u.unobtainable2 == GOLD_PIECE) || (u.unobtainable2 == STRANGE_OBJECT) || (u.unobtainable2 == AMULET_OF_YENDOR) || (u.unobtainable2 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable2 == BELL_OF_OPENING) || (u.unobtainable2 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable2].oc_prob < 1) ) u.unobtainable2 = rn2(NUM_OBJECTS);
	}

	u.unobtainable3 = -1;
	if (unobtitemamount >= 3) {
	while ( (u.unobtainable3 == -1) || (u.unobtainable3 == GOLD_PIECE) || (u.unobtainable3 == STRANGE_OBJECT) || (u.unobtainable3 == AMULET_OF_YENDOR) || (u.unobtainable3 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable3 == BELL_OF_OPENING) || (u.unobtainable3 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable3].oc_prob < 1) ) u.unobtainable3 = rn2(NUM_OBJECTS);
	}

	u.unobtainable4 = -1;
	if (unobtitemamount >= 4) {
	while ( (u.unobtainable4 == -1) || (u.unobtainable4 == GOLD_PIECE) || (u.unobtainable4 == STRANGE_OBJECT) || (u.unobtainable4 == AMULET_OF_YENDOR) || (u.unobtainable4 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable4 == BELL_OF_OPENING) || (u.unobtainable4 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable4].oc_prob < 1) ) u.unobtainable4 = rn2(NUM_OBJECTS);
	}

	u.unobtainable5 = -1;
	if (unobtitemamount >= 5) {
	while ( (u.unobtainable5 == -1) || (u.unobtainable5 == GOLD_PIECE) || (u.unobtainable5 == STRANGE_OBJECT) || (u.unobtainable5 == AMULET_OF_YENDOR) || (u.unobtainable5 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable5 == BELL_OF_OPENING) || (u.unobtainable5 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable5].oc_prob < 1) ) u.unobtainable5 = rn2(NUM_OBJECTS);
	}

	u.unobtainable6 = -1;
	if (unobtitemamount >= 6) {
	while ( (u.unobtainable6 == -1) || (u.unobtainable6 == GOLD_PIECE) || (u.unobtainable6 == STRANGE_OBJECT) || (u.unobtainable6 == AMULET_OF_YENDOR) || (u.unobtainable6 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable6 == BELL_OF_OPENING) || (u.unobtainable6 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable6].oc_prob < 1) ) u.unobtainable6 = rn2(NUM_OBJECTS);
	}

	u.unobtainable7 = -1;
	if (unobtitemamount >= 7) {
	while ( (u.unobtainable7 == -1) || (u.unobtainable7 == GOLD_PIECE) || (u.unobtainable7 == STRANGE_OBJECT) || (u.unobtainable7 == AMULET_OF_YENDOR) || (u.unobtainable7 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable7 == BELL_OF_OPENING) || (u.unobtainable7 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable7].oc_prob < 1) ) u.unobtainable7 = rn2(NUM_OBJECTS);
	}

	u.unobtainable8 = -1;
	if (unobtitemamount >= 8) {
	while ( (u.unobtainable8 == -1) || (u.unobtainable8 == GOLD_PIECE) || (u.unobtainable8 == STRANGE_OBJECT) || (u.unobtainable8 == AMULET_OF_YENDOR) || (u.unobtainable8 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable8 == BELL_OF_OPENING) || (u.unobtainable8 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable8].oc_prob < 1) ) u.unobtainable8 = rn2(NUM_OBJECTS);
	}

	u.unobtainable9 = -1;
	if (unobtitemamount >= 9) {
	while ( (u.unobtainable9 == -1) || (u.unobtainable9 == GOLD_PIECE) || (u.unobtainable9 == STRANGE_OBJECT) || (u.unobtainable9 == AMULET_OF_YENDOR) || (u.unobtainable9 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable9 == BELL_OF_OPENING) || (u.unobtainable9 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable9].oc_prob < 1) ) u.unobtainable9 = rn2(NUM_OBJECTS);
	}

	u.unobtainable10 = -1;
	if (unobtitemamount >= 10) {
	while ( (u.unobtainable10 == -1) || (u.unobtainable10 == GOLD_PIECE) || (u.unobtainable10 == STRANGE_OBJECT) || (u.unobtainable10 == AMULET_OF_YENDOR) || (u.unobtainable10 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable10 == BELL_OF_OPENING) || (u.unobtainable10 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable10].oc_prob < 1) ) u.unobtainable10 = rn2(NUM_OBJECTS);
	}

	register int curseitemamount = rnd(10); /* pick an # of items that are always cursed --Amy */

	u.alwayscurseditem = -1;
	while ( (u.alwayscurseditem == -1) || (u.alwayscurseditem == u.unobtainable) || (u.alwayscurseditem == u.unobtainable2) || (u.alwayscurseditem == u.unobtainable3) || (u.alwayscurseditem == u.unobtainable4) || (u.alwayscurseditem == u.unobtainable5) || (u.alwayscurseditem == u.unobtainable6) || (u.alwayscurseditem == u.unobtainable7) || (u.alwayscurseditem == u.unobtainable8) || (u.alwayscurseditem == u.unobtainable9) || (u.alwayscurseditem == u.unobtainable10) || (u.alwayscurseditem == GOLD_PIECE) || (u.alwayscurseditem == STRANGE_OBJECT) || (u.alwayscurseditem == AMULET_OF_YENDOR) || (u.alwayscurseditem == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem == BELL_OF_OPENING) || (u.alwayscurseditem == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem].oc_prob < 1) ) u.alwayscurseditem = rn2(NUM_OBJECTS);

	u.alwayscurseditem2 = -1;
	if (curseitemamount >= 2) {
	while ( (u.alwayscurseditem2 == -1) || (u.alwayscurseditem2 == u.unobtainable) || (u.alwayscurseditem2 == u.unobtainable2) || (u.alwayscurseditem2 == u.unobtainable3) || (u.alwayscurseditem2 == u.unobtainable4) || (u.alwayscurseditem2 == u.unobtainable5) || (u.alwayscurseditem2 == u.unobtainable6) || (u.alwayscurseditem2 == u.unobtainable7) || (u.alwayscurseditem2 == u.unobtainable8) || (u.alwayscurseditem2 == u.unobtainable9) || (u.alwayscurseditem2 == u.unobtainable10) || (u.alwayscurseditem2 == GOLD_PIECE) || (u.alwayscurseditem2 == STRANGE_OBJECT) || (u.alwayscurseditem2 == AMULET_OF_YENDOR) || (u.alwayscurseditem2 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem2 == BELL_OF_OPENING) || (u.alwayscurseditem2 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem2].oc_prob < 1) ) u.alwayscurseditem2 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem3 = -1;
	if (curseitemamount >= 3) {
	while ( (u.alwayscurseditem3 == -1) || (u.alwayscurseditem3 == u.unobtainable) || (u.alwayscurseditem3 == u.unobtainable2) || (u.alwayscurseditem3 == u.unobtainable3) || (u.alwayscurseditem3 == u.unobtainable4) || (u.alwayscurseditem3 == u.unobtainable5) || (u.alwayscurseditem3 == u.unobtainable6) || (u.alwayscurseditem3 == u.unobtainable7) || (u.alwayscurseditem3 == u.unobtainable8) || (u.alwayscurseditem3 == u.unobtainable9) || (u.alwayscurseditem3 == u.unobtainable10) || (u.alwayscurseditem3 == GOLD_PIECE) || (u.alwayscurseditem3 == STRANGE_OBJECT) || (u.alwayscurseditem3 == AMULET_OF_YENDOR) || (u.alwayscurseditem3 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem3 == BELL_OF_OPENING) || (u.alwayscurseditem3 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem3].oc_prob < 1) ) u.alwayscurseditem3 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem4 = -1;
	if (curseitemamount >= 4) {
	while ( (u.alwayscurseditem4 == -1) || (u.alwayscurseditem4 == u.unobtainable) || (u.alwayscurseditem4 == u.unobtainable2) || (u.alwayscurseditem4 == u.unobtainable3) || (u.alwayscurseditem4 == u.unobtainable4) || (u.alwayscurseditem4 == u.unobtainable5) || (u.alwayscurseditem4 == u.unobtainable6) || (u.alwayscurseditem4 == u.unobtainable7) || (u.alwayscurseditem4 == u.unobtainable8) || (u.alwayscurseditem4 == u.unobtainable9) || (u.alwayscurseditem4 == u.unobtainable10) || (u.alwayscurseditem4 == GOLD_PIECE) || (u.alwayscurseditem4 == STRANGE_OBJECT) || (u.alwayscurseditem4 == AMULET_OF_YENDOR) || (u.alwayscurseditem4 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem4 == BELL_OF_OPENING) || (u.alwayscurseditem4 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem4].oc_prob < 1) ) u.alwayscurseditem4 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem5 = -1;
	if (curseitemamount >= 5) {
	while ( (u.alwayscurseditem5 == -1) || (u.alwayscurseditem5 == u.unobtainable) || (u.alwayscurseditem5 == u.unobtainable2) || (u.alwayscurseditem5 == u.unobtainable3) || (u.alwayscurseditem5 == u.unobtainable4) || (u.alwayscurseditem5 == u.unobtainable5) || (u.alwayscurseditem5 == u.unobtainable6) || (u.alwayscurseditem5 == u.unobtainable7) || (u.alwayscurseditem5 == u.unobtainable8) || (u.alwayscurseditem5 == u.unobtainable9) || (u.alwayscurseditem5 == u.unobtainable10) || (u.alwayscurseditem5 == GOLD_PIECE) || (u.alwayscurseditem5 == STRANGE_OBJECT) || (u.alwayscurseditem5 == AMULET_OF_YENDOR) || (u.alwayscurseditem5 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem5 == BELL_OF_OPENING) || (u.alwayscurseditem5 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem5].oc_prob < 1) ) u.alwayscurseditem5 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem6 = -1;
	if (curseitemamount >= 6) {
	while ( (u.alwayscurseditem6 == -1) || (u.alwayscurseditem6 == u.unobtainable) || (u.alwayscurseditem6 == u.unobtainable2) || (u.alwayscurseditem6 == u.unobtainable3) || (u.alwayscurseditem6 == u.unobtainable4) || (u.alwayscurseditem6 == u.unobtainable5) || (u.alwayscurseditem6 == u.unobtainable6) || (u.alwayscurseditem6 == u.unobtainable7) || (u.alwayscurseditem6 == u.unobtainable8) || (u.alwayscurseditem6 == u.unobtainable9) || (u.alwayscurseditem6 == u.unobtainable10) || (u.alwayscurseditem6 == GOLD_PIECE) || (u.alwayscurseditem6 == STRANGE_OBJECT) || (u.alwayscurseditem6 == AMULET_OF_YENDOR) || (u.alwayscurseditem6 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem6 == BELL_OF_OPENING) || (u.alwayscurseditem6 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem6].oc_prob < 1) ) u.alwayscurseditem6 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem7 = -1;
	if (curseitemamount >= 7) {
	while ( (u.alwayscurseditem7 == -1) || (u.alwayscurseditem7 == u.unobtainable) || (u.alwayscurseditem7 == u.unobtainable2) || (u.alwayscurseditem7 == u.unobtainable3) || (u.alwayscurseditem7 == u.unobtainable4) || (u.alwayscurseditem7 == u.unobtainable5) || (u.alwayscurseditem7 == u.unobtainable6) || (u.alwayscurseditem7 == u.unobtainable7) || (u.alwayscurseditem7 == u.unobtainable8) || (u.alwayscurseditem7 == u.unobtainable9) || (u.alwayscurseditem7 == u.unobtainable10) || (u.alwayscurseditem7 == GOLD_PIECE) || (u.alwayscurseditem7 == STRANGE_OBJECT) || (u.alwayscurseditem7 == AMULET_OF_YENDOR) || (u.alwayscurseditem7 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem7 == BELL_OF_OPENING) || (u.alwayscurseditem7 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem7].oc_prob < 1) ) u.alwayscurseditem7 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem8 = -1;
	if (curseitemamount >= 8) {
	while ( (u.alwayscurseditem8 == -1) || (u.alwayscurseditem8 == u.unobtainable) || (u.alwayscurseditem8 == u.unobtainable2) || (u.alwayscurseditem8 == u.unobtainable3) || (u.alwayscurseditem8 == u.unobtainable4) || (u.alwayscurseditem8 == u.unobtainable5) || (u.alwayscurseditem8 == u.unobtainable6) || (u.alwayscurseditem8 == u.unobtainable7) || (u.alwayscurseditem8 == u.unobtainable8) || (u.alwayscurseditem8 == u.unobtainable9) || (u.alwayscurseditem8 == u.unobtainable10) || (u.alwayscurseditem8 == GOLD_PIECE) || (u.alwayscurseditem8 == STRANGE_OBJECT) || (u.alwayscurseditem8 == AMULET_OF_YENDOR) || (u.alwayscurseditem8 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem8 == BELL_OF_OPENING) || (u.alwayscurseditem8 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem8].oc_prob < 1) ) u.alwayscurseditem8 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem9 = -1;
	if (curseitemamount >= 9) {
	while ( (u.alwayscurseditem9 == -1) || (u.alwayscurseditem9 == u.unobtainable) || (u.alwayscurseditem9 == u.unobtainable2) || (u.alwayscurseditem9 == u.unobtainable3) || (u.alwayscurseditem9 == u.unobtainable4) || (u.alwayscurseditem9 == u.unobtainable5) || (u.alwayscurseditem9 == u.unobtainable6) || (u.alwayscurseditem9 == u.unobtainable7) || (u.alwayscurseditem9 == u.unobtainable8) || (u.alwayscurseditem9 == u.unobtainable9) || (u.alwayscurseditem9 == u.unobtainable10) || (u.alwayscurseditem9 == GOLD_PIECE) || (u.alwayscurseditem9 == STRANGE_OBJECT) || (u.alwayscurseditem9 == AMULET_OF_YENDOR) || (u.alwayscurseditem9 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem9 == BELL_OF_OPENING) || (u.alwayscurseditem9 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem9].oc_prob < 1) ) u.alwayscurseditem9 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem10 = -1;
	if (curseitemamount >= 10) {
	while ( (u.alwayscurseditem10 == -1) || (u.alwayscurseditem10 == u.unobtainable) || (u.alwayscurseditem10 == u.unobtainable2) || (u.alwayscurseditem10 == u.unobtainable3) || (u.alwayscurseditem10 == u.unobtainable4) || (u.alwayscurseditem10 == u.unobtainable5) || (u.alwayscurseditem10 == u.unobtainable6) || (u.alwayscurseditem10 == u.unobtainable7) || (u.alwayscurseditem10 == u.unobtainable8) || (u.alwayscurseditem10 == u.unobtainable9) || (u.alwayscurseditem10 == u.unobtainable10) || (u.alwayscurseditem10 == GOLD_PIECE) || (u.alwayscurseditem10 == STRANGE_OBJECT) || (u.alwayscurseditem10 == AMULET_OF_YENDOR) || (u.alwayscurseditem10 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem10 == BELL_OF_OPENING) || (u.alwayscurseditem10 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem10].oc_prob < 1) ) u.alwayscurseditem10 = rn2(NUM_OBJECTS);
	}

	u.veryobtainable = -1;
	while ( (u.veryobtainable == -1) || (u.veryobtainable == GOLD_PIECE) || (u.veryobtainable == STRANGE_OBJECT) || (u.veryobtainable == AMULET_OF_YENDOR) || (u.veryobtainable == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable == BELL_OF_OPENING) || (u.veryobtainable == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable == SCR_WISHING) || (u.veryobtainable == SCR_RESURRECTION) || (u.veryobtainable == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable == SCR_WORLD_FALL) || (u.veryobtainable == SCR_ASTRALCENSION) || (u.veryobtainable == TREASURE_CHEST) || (u.veryobtainable == SCR_RAGNAROK) || (u.veryobtainable == SCR_ARTIFACT_CREATION) || (u.veryobtainable == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable == WAN_WISHING) || (u.veryobtainable == u.unobtainable) || (u.veryobtainable == u.unobtainable2) || (u.veryobtainable == u.unobtainable3) || (u.veryobtainable == u.unobtainable4) || (u.veryobtainable == u.unobtainable5) || (u.veryobtainable == u.unobtainable6) || (u.veryobtainable == u.unobtainable7) || (u.veryobtainable == u.unobtainable8) || (u.veryobtainable == u.unobtainable9) || (u.veryobtainable == u.unobtainable10) || (objects[u.veryobtainable].oc_prob < 1) ) u.veryobtainable = rn2(NUM_OBJECTS);
	u.veryobtainableboost = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost += rnz(10);
	if (!rn2(25)) u.veryobtainableboost += rnz(100);
	if (u.veryobtainableboost > 1000) u.veryobtainableboost = 1000; /* sanity check */

	u.veryobtainable2 = -1;
	while ( (u.veryobtainable2 == -1) || (u.veryobtainable2 == GOLD_PIECE) || (u.veryobtainable2 == STRANGE_OBJECT) || (u.veryobtainable2 == AMULET_OF_YENDOR) || (u.veryobtainable2 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable2 == BELL_OF_OPENING) || (u.veryobtainable2 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable2 == SCR_WISHING) || (u.veryobtainable2 == SCR_RESURRECTION) || (u.veryobtainable2 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable2 == SCR_WORLD_FALL) || (u.veryobtainable2 == SCR_ASTRALCENSION) || (u.veryobtainable2 == TREASURE_CHEST) || (u.veryobtainable2 == SCR_RAGNAROK) || (u.veryobtainable2 == SCR_ARTIFACT_CREATION) || (u.veryobtainable2 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable2 == WAN_WISHING) || (u.veryobtainable2 == u.unobtainable) || (u.veryobtainable2 == u.unobtainable2) || (u.veryobtainable2 == u.unobtainable3) || (u.veryobtainable2 == u.unobtainable4) || (u.veryobtainable2 == u.unobtainable5) || (u.veryobtainable2 == u.unobtainable6) || (u.veryobtainable2 == u.unobtainable7) || (u.veryobtainable2 == u.unobtainable8) || (u.veryobtainable2 == u.unobtainable9) || (u.veryobtainable2 == u.unobtainable10) || (objects[u.veryobtainable2].oc_prob < 1) ) u.veryobtainable2 = rn2(NUM_OBJECTS);
	u.veryobtainableboost2 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost2 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost2 += rnz(100);
	if (u.veryobtainableboost2 > 1000) u.veryobtainableboost2 = 1000; /* sanity check */

	u.veryobtainable3 = -1;
	while ( (u.veryobtainable3 == -1) || (u.veryobtainable3 == GOLD_PIECE) || (u.veryobtainable3 == STRANGE_OBJECT) || (u.veryobtainable3 == AMULET_OF_YENDOR) || (u.veryobtainable3 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable3 == BELL_OF_OPENING) || (u.veryobtainable3 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable3 == SCR_WISHING) || (u.veryobtainable3 == SCR_RESURRECTION) || (u.veryobtainable3 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable3 == SCR_WORLD_FALL) || (u.veryobtainable3 == SCR_ASTRALCENSION) || (u.veryobtainable3 == TREASURE_CHEST) || (u.veryobtainable3 == SCR_RAGNAROK) || (u.veryobtainable3 == SCR_ARTIFACT_CREATION) || (u.veryobtainable3 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable3 == WAN_WISHING) || (u.veryobtainable3 == u.unobtainable) || (u.veryobtainable3 == u.unobtainable2) || (u.veryobtainable3 == u.unobtainable3) || (u.veryobtainable3 == u.unobtainable4) || (u.veryobtainable3 == u.unobtainable5) || (u.veryobtainable3 == u.unobtainable6) || (u.veryobtainable3 == u.unobtainable7) || (u.veryobtainable3 == u.unobtainable8) || (u.veryobtainable3 == u.unobtainable9) || (u.veryobtainable3 == u.unobtainable10) || (objects[u.veryobtainable3].oc_prob < 1) ) u.veryobtainable3 = rn2(NUM_OBJECTS);
	u.veryobtainableboost3 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost3 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost3 += rnz(100);
	if (u.veryobtainableboost3 > 1000) u.veryobtainableboost3 = 1000; /* sanity check */

	u.veryobtainable4 = -1;
	while ( (u.veryobtainable4 == -1) || (u.veryobtainable4 == GOLD_PIECE) || (u.veryobtainable4 == STRANGE_OBJECT) || (u.veryobtainable4 == AMULET_OF_YENDOR) || (u.veryobtainable4 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable4 == BELL_OF_OPENING) || (u.veryobtainable4 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable4 == SCR_WISHING) || (u.veryobtainable4 == SCR_RESURRECTION) || (u.veryobtainable4 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable4 == SCR_WORLD_FALL) || (u.veryobtainable4 == SCR_ASTRALCENSION) || (u.veryobtainable4 == TREASURE_CHEST) || (u.veryobtainable4 == SCR_RAGNAROK) || (u.veryobtainable4 == SCR_ARTIFACT_CREATION) || (u.veryobtainable4 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable4 == WAN_WISHING) || (u.veryobtainable4 == u.unobtainable) || (u.veryobtainable4 == u.unobtainable2) || (u.veryobtainable4 == u.unobtainable3) || (u.veryobtainable4 == u.unobtainable4) || (u.veryobtainable4 == u.unobtainable5) || (u.veryobtainable4 == u.unobtainable6) || (u.veryobtainable4 == u.unobtainable7) || (u.veryobtainable4 == u.unobtainable8) || (u.veryobtainable4 == u.unobtainable9) || (u.veryobtainable4 == u.unobtainable10) || (objects[u.veryobtainable4].oc_prob < 1) ) u.veryobtainable4 = rn2(NUM_OBJECTS);
	u.veryobtainableboost4 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost4 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost4 += rnz(100);
	if (u.veryobtainableboost4 > 1000) u.veryobtainableboost4 = 1000; /* sanity check */

	u.veryobtainable5 = -1;
	while ( (u.veryobtainable5 == -1) || (u.veryobtainable5 == GOLD_PIECE) || (u.veryobtainable5 == STRANGE_OBJECT) || (u.veryobtainable5 == AMULET_OF_YENDOR) || (u.veryobtainable5 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable5 == BELL_OF_OPENING) || (u.veryobtainable5 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable5 == SCR_WISHING) || (u.veryobtainable5 == SCR_RESURRECTION) || (u.veryobtainable5 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable5 == SCR_WORLD_FALL) || (u.veryobtainable5 == SCR_ASTRALCENSION) || (u.veryobtainable5 == TREASURE_CHEST) || (u.veryobtainable5 == SCR_RAGNAROK) || (u.veryobtainable5 == SCR_ARTIFACT_CREATION) || (u.veryobtainable5 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable5 == WAN_WISHING) || (u.veryobtainable5 == u.unobtainable) || (u.veryobtainable5 == u.unobtainable2) || (u.veryobtainable5 == u.unobtainable3) || (u.veryobtainable5 == u.unobtainable4) || (u.veryobtainable5 == u.unobtainable5) || (u.veryobtainable5 == u.unobtainable6) || (u.veryobtainable5 == u.unobtainable7) || (u.veryobtainable5 == u.unobtainable8) || (u.veryobtainable5 == u.unobtainable9) || (u.veryobtainable5 == u.unobtainable10) || (objects[u.veryobtainable5].oc_prob < 1) ) u.veryobtainable5 = rn2(NUM_OBJECTS);
	u.veryobtainableboost5 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost5 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost5 += rnz(100);
	if (u.veryobtainableboost5 > 1000) u.veryobtainableboost5 = 1000; /* sanity check */

	u.veryobtainable6 = -1;
	while ( (u.veryobtainable6 == -1) || (u.veryobtainable6 == GOLD_PIECE) || (u.veryobtainable6 == STRANGE_OBJECT) || (u.veryobtainable6 == AMULET_OF_YENDOR) || (u.veryobtainable6 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable6 == BELL_OF_OPENING) || (u.veryobtainable6 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable6 == SCR_WISHING) || (u.veryobtainable6 == SCR_RESURRECTION) || (u.veryobtainable6 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable6 == SCR_WORLD_FALL) || (u.veryobtainable6 == SCR_ASTRALCENSION) || (u.veryobtainable6 == TREASURE_CHEST) || (u.veryobtainable6 == SCR_RAGNAROK) || (u.veryobtainable6 == SCR_ARTIFACT_CREATION) || (u.veryobtainable6 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable6 == WAN_WISHING) || (u.veryobtainable6 == u.unobtainable) || (u.veryobtainable6 == u.unobtainable2) || (u.veryobtainable6 == u.unobtainable3) || (u.veryobtainable6 == u.unobtainable4) || (u.veryobtainable6 == u.unobtainable5) || (u.veryobtainable6 == u.unobtainable6) || (u.veryobtainable6 == u.unobtainable7) || (u.veryobtainable6 == u.unobtainable8) || (u.veryobtainable6 == u.unobtainable9) || (u.veryobtainable6 == u.unobtainable10) || (objects[u.veryobtainable6].oc_prob < 1) ) u.veryobtainable6 = rn2(NUM_OBJECTS);
	u.veryobtainableboost6 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost6 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost6 += rnz(100);
	if (u.veryobtainableboost6 > 1000) u.veryobtainableboost6 = 1000; /* sanity check */

	u.veryobtainable7 = -1;
	while ( (u.veryobtainable7 == -1) || (u.veryobtainable7 == GOLD_PIECE) || (u.veryobtainable7 == STRANGE_OBJECT) || (u.veryobtainable7 == AMULET_OF_YENDOR) || (u.veryobtainable7 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable7 == BELL_OF_OPENING) || (u.veryobtainable7 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable7 == SCR_WISHING) || (u.veryobtainable7 == SCR_RESURRECTION) || (u.veryobtainable7 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable7 == SCR_WORLD_FALL) || (u.veryobtainable7 == SCR_ASTRALCENSION) || (u.veryobtainable7 == TREASURE_CHEST) || (u.veryobtainable7 == SCR_RAGNAROK) || (u.veryobtainable7 == SCR_ARTIFACT_CREATION) || (u.veryobtainable7 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable7 == WAN_WISHING) || (u.veryobtainable7 == u.unobtainable) || (u.veryobtainable7 == u.unobtainable2) || (u.veryobtainable7 == u.unobtainable3) || (u.veryobtainable7 == u.unobtainable4) || (u.veryobtainable7 == u.unobtainable5) || (u.veryobtainable7 == u.unobtainable6) || (u.veryobtainable7 == u.unobtainable7) || (u.veryobtainable7 == u.unobtainable8) || (u.veryobtainable7 == u.unobtainable9) || (u.veryobtainable7 == u.unobtainable10) || (objects[u.veryobtainable7].oc_prob < 1) ) u.veryobtainable7 = rn2(NUM_OBJECTS);
	u.veryobtainableboost7 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost7 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost7 += rnz(100);
	if (u.veryobtainableboost7 > 1000) u.veryobtainableboost7 = 1000; /* sanity check */

	u.veryobtainable8 = -1;
	while ( (u.veryobtainable8 == -1) || (u.veryobtainable8 == GOLD_PIECE) || (u.veryobtainable8 == STRANGE_OBJECT) || (u.veryobtainable8 == AMULET_OF_YENDOR) || (u.veryobtainable8 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable8 == BELL_OF_OPENING) || (u.veryobtainable8 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable8 == SCR_WISHING) || (u.veryobtainable8 == SCR_RESURRECTION) || (u.veryobtainable8 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable8 == SCR_WORLD_FALL) || (u.veryobtainable8 == SCR_ASTRALCENSION) || (u.veryobtainable8 == TREASURE_CHEST) || (u.veryobtainable8 == SCR_RAGNAROK) || (u.veryobtainable8 == SCR_ARTIFACT_CREATION) || (u.veryobtainable8 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable8 == WAN_WISHING) || (u.veryobtainable8 == u.unobtainable) || (u.veryobtainable8 == u.unobtainable2) || (u.veryobtainable8 == u.unobtainable3) || (u.veryobtainable8 == u.unobtainable4) || (u.veryobtainable8 == u.unobtainable5) || (u.veryobtainable8 == u.unobtainable6) || (u.veryobtainable8 == u.unobtainable7) || (u.veryobtainable8 == u.unobtainable8) || (u.veryobtainable8 == u.unobtainable9) || (u.veryobtainable8 == u.unobtainable10) || (objects[u.veryobtainable8].oc_prob < 1) ) u.veryobtainable8 = rn2(NUM_OBJECTS);
	u.veryobtainableboost8 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost8 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost8 += rnz(100);
	if (u.veryobtainableboost8 > 1000) u.veryobtainableboost8 = 1000; /* sanity check */

	u.veryobtainable9 = -1;
	while ( (u.veryobtainable9 == -1) || (u.veryobtainable9 == GOLD_PIECE) || (u.veryobtainable9 == STRANGE_OBJECT) || (u.veryobtainable9 == AMULET_OF_YENDOR) || (u.veryobtainable9 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable9 == BELL_OF_OPENING) || (u.veryobtainable9 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable9 == SCR_WISHING) || (u.veryobtainable9 == SCR_RESURRECTION) || (u.veryobtainable9 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable9 == SCR_WORLD_FALL) || (u.veryobtainable9 == SCR_ASTRALCENSION) || (u.veryobtainable9 == TREASURE_CHEST) || (u.veryobtainable9 == SCR_RAGNAROK) || (u.veryobtainable9 == SCR_ARTIFACT_CREATION) || (u.veryobtainable9 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable9 == WAN_WISHING) || (u.veryobtainable9 == u.unobtainable) || (u.veryobtainable9 == u.unobtainable2) || (u.veryobtainable9 == u.unobtainable3) || (u.veryobtainable9 == u.unobtainable4) || (u.veryobtainable9 == u.unobtainable5) || (u.veryobtainable9 == u.unobtainable6) || (u.veryobtainable9 == u.unobtainable7) || (u.veryobtainable9 == u.unobtainable8) || (u.veryobtainable9 == u.unobtainable9) || (u.veryobtainable9 == u.unobtainable10) || (objects[u.veryobtainable9].oc_prob < 1) ) u.veryobtainable9 = rn2(NUM_OBJECTS);
	u.veryobtainableboost9 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost9 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost9 += rnz(100);
	if (u.veryobtainableboost9 > 1000) u.veryobtainableboost9 = 1000; /* sanity check */

	u.veryobtainable10 = -1;
	while ( (u.veryobtainable10 == -1) || (u.veryobtainable10 == GOLD_PIECE) || (u.veryobtainable10 == STRANGE_OBJECT) || (u.veryobtainable10 == AMULET_OF_YENDOR) || (u.veryobtainable10 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable10 == BELL_OF_OPENING) || (u.veryobtainable10 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable10 == SCR_WISHING) || (u.veryobtainable10 == SCR_RESURRECTION) || (u.veryobtainable10 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable10 == SCR_WORLD_FALL) || (u.veryobtainable10 == SCR_ASTRALCENSION) || (u.veryobtainable10 == TREASURE_CHEST) || (u.veryobtainable10 == SCR_RAGNAROK) || (u.veryobtainable10 == SCR_ARTIFACT_CREATION) || (u.veryobtainable10 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable10 == WAN_WISHING) || (u.veryobtainable10 == u.unobtainable) || (u.veryobtainable10 == u.unobtainable2) || (u.veryobtainable10 == u.unobtainable3) || (u.veryobtainable10 == u.unobtainable4) || (u.veryobtainable10 == u.unobtainable5) || (u.veryobtainable10 == u.unobtainable6) || (u.veryobtainable10 == u.unobtainable7) || (u.veryobtainable10 == u.unobtainable8) || (u.veryobtainable10 == u.unobtainable9) || (u.veryobtainable10 == u.unobtainable10) || (objects[u.veryobtainable10].oc_prob < 1) ) u.veryobtainable10 = rn2(NUM_OBJECTS);
	u.veryobtainableboost10 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost10 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost10 += rnz(100);
	if (u.veryobtainableboost10 > 1000) u.veryobtainableboost10 = 1000; /* sanity check */

	u.veryobtainable11 = -1;
	while ( (u.veryobtainable11 == -1) || (u.veryobtainable11 == GOLD_PIECE) || (u.veryobtainable11 == STRANGE_OBJECT) || (u.veryobtainable11 == AMULET_OF_YENDOR) || (u.veryobtainable11 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable11 == BELL_OF_OPENING) || (u.veryobtainable11 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable11 == SCR_WISHING) || (u.veryobtainable11 == SCR_RESURRECTION) || (u.veryobtainable11 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable11 == SCR_WORLD_FALL) || (u.veryobtainable11 == SCR_ASTRALCENSION) || (u.veryobtainable11 == TREASURE_CHEST) || (u.veryobtainable11 == SCR_RAGNAROK) || (u.veryobtainable11 == SCR_ARTIFACT_CREATION) || (u.veryobtainable11 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable11 == WAN_WISHING) || (u.veryobtainable11 == u.unobtainable) || (u.veryobtainable11 == u.unobtainable2) || (u.veryobtainable11 == u.unobtainable3) || (u.veryobtainable11 == u.unobtainable4) || (u.veryobtainable11 == u.unobtainable5) || (u.veryobtainable11 == u.unobtainable6) || (u.veryobtainable11 == u.unobtainable7) || (u.veryobtainable11 == u.unobtainable8) || (u.veryobtainable11 == u.unobtainable9) || (u.veryobtainable11 == u.unobtainable10) || (objects[u.veryobtainable11].oc_prob < 1) ) u.veryobtainable11 = rn2(NUM_OBJECTS);
	u.veryobtainableboost11 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost11 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost11 += rnd(100);
	if (u.veryobtainableboost11 > 1000) u.veryobtainableboost11 = 1000; /* sanity check */

	u.veryobtainable12 = -1;
	while ( (u.veryobtainable12 == -1) || (u.veryobtainable12 == GOLD_PIECE) || (u.veryobtainable12 == STRANGE_OBJECT) || (u.veryobtainable12 == AMULET_OF_YENDOR) || (u.veryobtainable12 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable12 == BELL_OF_OPENING) || (u.veryobtainable12 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable12 == SCR_WISHING) || (u.veryobtainable12 == SCR_RESURRECTION) || (u.veryobtainable12 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable12 == SCR_WORLD_FALL) || (u.veryobtainable12 == SCR_ASTRALCENSION) || (u.veryobtainable12 == TREASURE_CHEST) || (u.veryobtainable12 == SCR_RAGNAROK) || (u.veryobtainable12 == SCR_ARTIFACT_CREATION) || (u.veryobtainable12 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable12 == WAN_WISHING) || (u.veryobtainable12 == u.unobtainable) || (u.veryobtainable12 == u.unobtainable2) || (u.veryobtainable12 == u.unobtainable3) || (u.veryobtainable12 == u.unobtainable4) || (u.veryobtainable12 == u.unobtainable5) || (u.veryobtainable12 == u.unobtainable6) || (u.veryobtainable12 == u.unobtainable7) || (u.veryobtainable12 == u.unobtainable8) || (u.veryobtainable12 == u.unobtainable9) || (u.veryobtainable12 == u.unobtainable10) || (objects[u.veryobtainable12].oc_prob < 1) ) u.veryobtainable12 = rn2(NUM_OBJECTS);
	u.veryobtainableboost12 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost12 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost12 += rnd(100);
	if (u.veryobtainableboost12 > 1000) u.veryobtainableboost12 = 1000; /* sanity check */

	u.veryobtainable13 = -1;
	while ( (u.veryobtainable13 == -1) || (u.veryobtainable13 == GOLD_PIECE) || (u.veryobtainable13 == STRANGE_OBJECT) || (u.veryobtainable13 == AMULET_OF_YENDOR) || (u.veryobtainable13 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable13 == BELL_OF_OPENING) || (u.veryobtainable13 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable13 == SCR_WISHING) || (u.veryobtainable13 == SCR_RESURRECTION) || (u.veryobtainable13 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable13 == SCR_WORLD_FALL) || (u.veryobtainable13 == SCR_ASTRALCENSION) || (u.veryobtainable13 == TREASURE_CHEST) || (u.veryobtainable13 == SCR_RAGNAROK) || (u.veryobtainable13 == SCR_ARTIFACT_CREATION) || (u.veryobtainable13 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable13 == WAN_WISHING) || (u.veryobtainable13 == u.unobtainable) || (u.veryobtainable13 == u.unobtainable2) || (u.veryobtainable13 == u.unobtainable3) || (u.veryobtainable13 == u.unobtainable4) || (u.veryobtainable13 == u.unobtainable5) || (u.veryobtainable13 == u.unobtainable6) || (u.veryobtainable13 == u.unobtainable7) || (u.veryobtainable13 == u.unobtainable8) || (u.veryobtainable13 == u.unobtainable9) || (u.veryobtainable13 == u.unobtainable10) || (objects[u.veryobtainable13].oc_prob < 1) ) u.veryobtainable13 = rn2(NUM_OBJECTS);
	u.veryobtainableboost13 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost13 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost13 += rnd(100);
	if (u.veryobtainableboost13 > 1000) u.veryobtainableboost13 = 1000; /* sanity check */

	u.veryobtainable14 = -1;
	while ( (u.veryobtainable14 == -1) || (u.veryobtainable14 == GOLD_PIECE) || (u.veryobtainable14 == STRANGE_OBJECT) || (u.veryobtainable14 == AMULET_OF_YENDOR) || (u.veryobtainable14 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable14 == BELL_OF_OPENING) || (u.veryobtainable14 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable14 == SCR_WISHING) || (u.veryobtainable14 == SCR_RESURRECTION) || (u.veryobtainable14 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable14 == SCR_WORLD_FALL) || (u.veryobtainable14 == SCR_ASTRALCENSION) || (u.veryobtainable14 == TREASURE_CHEST) || (u.veryobtainable14 == SCR_RAGNAROK) || (u.veryobtainable14 == SCR_ARTIFACT_CREATION) || (u.veryobtainable14 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable14 == WAN_WISHING) || (u.veryobtainable14 == u.unobtainable) || (u.veryobtainable14 == u.unobtainable2) || (u.veryobtainable14 == u.unobtainable3) || (u.veryobtainable14 == u.unobtainable4) || (u.veryobtainable14 == u.unobtainable5) || (u.veryobtainable14 == u.unobtainable6) || (u.veryobtainable14 == u.unobtainable7) || (u.veryobtainable14 == u.unobtainable8) || (u.veryobtainable14 == u.unobtainable9) || (u.veryobtainable14 == u.unobtainable10) || (objects[u.veryobtainable14].oc_prob < 1) ) u.veryobtainable14 = rn2(NUM_OBJECTS);
	u.veryobtainableboost14 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost14 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost14 += rnd(100);
	if (u.veryobtainableboost14 > 1000) u.veryobtainableboost14 = 1000; /* sanity check */

	u.veryobtainable15 = -1;
	while ( (u.veryobtainable15 == -1) || (u.veryobtainable15 == GOLD_PIECE) || (u.veryobtainable15 == STRANGE_OBJECT) || (u.veryobtainable15 == AMULET_OF_YENDOR) || (u.veryobtainable15 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable15 == BELL_OF_OPENING) || (u.veryobtainable15 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable15 == SCR_WISHING) || (u.veryobtainable15 == SCR_RESURRECTION) || (u.veryobtainable15 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable15 == SCR_WORLD_FALL) || (u.veryobtainable15 == SCR_ASTRALCENSION) || (u.veryobtainable15 == TREASURE_CHEST) || (u.veryobtainable15 == SCR_RAGNAROK) || (u.veryobtainable15 == SCR_ARTIFACT_CREATION) || (u.veryobtainable15 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable15 == WAN_WISHING) || (u.veryobtainable15 == u.unobtainable) || (u.veryobtainable15 == u.unobtainable2) || (u.veryobtainable15 == u.unobtainable3) || (u.veryobtainable15 == u.unobtainable4) || (u.veryobtainable15 == u.unobtainable5) || (u.veryobtainable15 == u.unobtainable6) || (u.veryobtainable15 == u.unobtainable7) || (u.veryobtainable15 == u.unobtainable8) || (u.veryobtainable15 == u.unobtainable9) || (u.veryobtainable15 == u.unobtainable10) || (objects[u.veryobtainable15].oc_prob < 1) ) u.veryobtainable15 = rn2(NUM_OBJECTS);
	u.veryobtainableboost15 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost15 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost15 += rnd(100);
	if (u.veryobtainableboost15 > 1000) u.veryobtainableboost15 = 1000; /* sanity check */

	u.veryobtainable16 = -1;
	while ( (u.veryobtainable16 == -1) || (u.veryobtainable16 == GOLD_PIECE) || (u.veryobtainable16 == STRANGE_OBJECT) || (u.veryobtainable16 == AMULET_OF_YENDOR) || (u.veryobtainable16 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable16 == BELL_OF_OPENING) || (u.veryobtainable16 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable16 == SCR_WISHING) || (u.veryobtainable16 == SCR_RESURRECTION) || (u.veryobtainable16 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable16 == SCR_WORLD_FALL) || (u.veryobtainable16 == SCR_ASTRALCENSION) || (u.veryobtainable16 == TREASURE_CHEST) || (u.veryobtainable16 == SCR_RAGNAROK) || (u.veryobtainable16 == SCR_ARTIFACT_CREATION) || (u.veryobtainable16 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable16 == WAN_WISHING) || (u.veryobtainable16 == u.unobtainable) || (u.veryobtainable16 == u.unobtainable2) || (u.veryobtainable16 == u.unobtainable3) || (u.veryobtainable16 == u.unobtainable4) || (u.veryobtainable16 == u.unobtainable5) || (u.veryobtainable16 == u.unobtainable6) || (u.veryobtainable16 == u.unobtainable7) || (u.veryobtainable16 == u.unobtainable8) || (u.veryobtainable16 == u.unobtainable9) || (u.veryobtainable16 == u.unobtainable10) || (objects[u.veryobtainable16].oc_prob < 1) ) u.veryobtainable16 = rn2(NUM_OBJECTS);
	u.veryobtainableboost16 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost16 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost16 += rnd(100);
	if (u.veryobtainableboost16 > 1000) u.veryobtainableboost16 = 1000; /* sanity check */

	u.veryobtainable17 = -1;
	while ( (u.veryobtainable17 == -1) || (u.veryobtainable17 == GOLD_PIECE) || (u.veryobtainable17 == STRANGE_OBJECT) || (u.veryobtainable17 == AMULET_OF_YENDOR) || (u.veryobtainable17 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable17 == BELL_OF_OPENING) || (u.veryobtainable17 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable17 == SCR_WISHING) || (u.veryobtainable17 == SCR_RESURRECTION) || (u.veryobtainable17 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable17 == SCR_WORLD_FALL) || (u.veryobtainable17 == SCR_ASTRALCENSION) || (u.veryobtainable17 == TREASURE_CHEST) || (u.veryobtainable17 == SCR_RAGNAROK) || (u.veryobtainable17 == SCR_ARTIFACT_CREATION) || (u.veryobtainable17 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable17 == WAN_WISHING) || (u.veryobtainable17 == u.unobtainable) || (u.veryobtainable17 == u.unobtainable2) || (u.veryobtainable17 == u.unobtainable3) || (u.veryobtainable17 == u.unobtainable4) || (u.veryobtainable17 == u.unobtainable5) || (u.veryobtainable17 == u.unobtainable6) || (u.veryobtainable17 == u.unobtainable7) || (u.veryobtainable17 == u.unobtainable8) || (u.veryobtainable17 == u.unobtainable9) || (u.veryobtainable17 == u.unobtainable10) || (objects[u.veryobtainable17].oc_prob < 1) ) u.veryobtainable17 = rn2(NUM_OBJECTS);
	u.veryobtainableboost17 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost17 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost17 += rnd(100);
	if (u.veryobtainableboost17 > 1000) u.veryobtainableboost17 = 1000; /* sanity check */

	u.veryobtainable18 = -1;
	while ( (u.veryobtainable18 == -1) || (u.veryobtainable18 == GOLD_PIECE) || (u.veryobtainable18 == STRANGE_OBJECT) || (u.veryobtainable18 == AMULET_OF_YENDOR) || (u.veryobtainable18 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable18 == BELL_OF_OPENING) || (u.veryobtainable18 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable18 == SCR_WISHING) || (u.veryobtainable18 == SCR_RESURRECTION) || (u.veryobtainable18 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable18 == SCR_WORLD_FALL) || (u.veryobtainable18 == SCR_ASTRALCENSION) || (u.veryobtainable18 == TREASURE_CHEST) || (u.veryobtainable18 == SCR_RAGNAROK) || (u.veryobtainable18 == SCR_ARTIFACT_CREATION) || (u.veryobtainable18 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable18 == WAN_WISHING) || (u.veryobtainable18 == u.unobtainable) || (u.veryobtainable18 == u.unobtainable2) || (u.veryobtainable18 == u.unobtainable3) || (u.veryobtainable18 == u.unobtainable4) || (u.veryobtainable18 == u.unobtainable5) || (u.veryobtainable18 == u.unobtainable6) || (u.veryobtainable18 == u.unobtainable7) || (u.veryobtainable18 == u.unobtainable8) || (u.veryobtainable18 == u.unobtainable9) || (u.veryobtainable18 == u.unobtainable10) || (objects[u.veryobtainable18].oc_prob < 1) ) u.veryobtainable18 = rn2(NUM_OBJECTS);
	u.veryobtainableboost18 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost18 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost18 += rnd(100);
	if (u.veryobtainableboost18 > 1000) u.veryobtainableboost18 = 1000; /* sanity check */

	u.veryobtainable19 = -1;
	while ( (u.veryobtainable19 == -1) || (u.veryobtainable19 == GOLD_PIECE) || (u.veryobtainable19 == STRANGE_OBJECT) || (u.veryobtainable19 == AMULET_OF_YENDOR) || (u.veryobtainable19 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable19 == BELL_OF_OPENING) || (u.veryobtainable19 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable19 == SCR_WISHING) || (u.veryobtainable19 == SCR_RESURRECTION) || (u.veryobtainable19 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable19 == SCR_WORLD_FALL) || (u.veryobtainable19 == SCR_ASTRALCENSION) || (u.veryobtainable19 == TREASURE_CHEST) || (u.veryobtainable19 == SCR_RAGNAROK) || (u.veryobtainable19 == SCR_ARTIFACT_CREATION) || (u.veryobtainable19 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable19 == WAN_WISHING) || (u.veryobtainable19 == u.unobtainable) || (u.veryobtainable19 == u.unobtainable2) || (u.veryobtainable19 == u.unobtainable3) || (u.veryobtainable19 == u.unobtainable4) || (u.veryobtainable19 == u.unobtainable5) || (u.veryobtainable19 == u.unobtainable6) || (u.veryobtainable19 == u.unobtainable7) || (u.veryobtainable19 == u.unobtainable8) || (u.veryobtainable19 == u.unobtainable9) || (u.veryobtainable19 == u.unobtainable10) || (objects[u.veryobtainable19].oc_prob < 1) ) u.veryobtainable19 = rn2(NUM_OBJECTS);
	u.veryobtainableboost19 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost19 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost19 += rnd(100);
	if (u.veryobtainableboost19 > 1000) u.veryobtainableboost19 = 1000; /* sanity check */

	u.veryobtainable20 = -1;
	while ( (u.veryobtainable20 == -1) || (u.veryobtainable20 == GOLD_PIECE) || (u.veryobtainable20 == STRANGE_OBJECT) || (u.veryobtainable20 == AMULET_OF_YENDOR) || (u.veryobtainable20 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable20 == BELL_OF_OPENING) || (u.veryobtainable20 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable20 == SCR_WISHING) || (u.veryobtainable20 == SCR_RESURRECTION) || (u.veryobtainable20 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable20 == SCR_WORLD_FALL) || (u.veryobtainable20 == SCR_ASTRALCENSION) || (u.veryobtainable20 == TREASURE_CHEST) || (u.veryobtainable20 == SCR_RAGNAROK) || (u.veryobtainable20 == SCR_ARTIFACT_CREATION) || (u.veryobtainable20 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable20 == WAN_WISHING) || (u.veryobtainable20 == u.unobtainable) || (u.veryobtainable20 == u.unobtainable2) || (u.veryobtainable20 == u.unobtainable3) || (u.veryobtainable20 == u.unobtainable4) || (u.veryobtainable20 == u.unobtainable5) || (u.veryobtainable20 == u.unobtainable6) || (u.veryobtainable20 == u.unobtainable7) || (u.veryobtainable20 == u.unobtainable8) || (u.veryobtainable20 == u.unobtainable9) || (u.veryobtainable20 == u.unobtainable10) || (objects[u.veryobtainable20].oc_prob < 1) ) u.veryobtainable20 = rn2(NUM_OBJECTS);
	u.veryobtainableboost20 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost20 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost20 += rnd(100);
	if (u.veryobtainableboost20 > 1000) u.veryobtainableboost20 = 1000; /* sanity check */

	u.veryobtainclass1 = -1;
	if (!rn2(2)) {
		if (!rn2(1000)) u.veryobtainclass1 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass1 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass1 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass1 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass1 = RING_CLASS; break;
			case 4: u.veryobtainclass1 = AMULET_CLASS; break;
			case 5: u.veryobtainclass1 = WAND_CLASS; break;
			case 6: u.veryobtainclass1 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass1 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass1 = POTION_CLASS; break;
			case 9: u.veryobtainclass1 = TOOL_CLASS; break;
			case 10: u.veryobtainclass1 = FOOD_CLASS; break;
			case 11: u.veryobtainclass1 = GEM_CLASS; break;
		}
		u.veryobtainclass1boost = rnd(100);
	}

	u.veryobtainclass2 = -1;
	if (!rn2(5)) {
		if (!rn2(1000)) u.veryobtainclass2 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass2 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass2 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass2 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass2 = RING_CLASS; break;
			case 4: u.veryobtainclass2 = AMULET_CLASS; break;
			case 5: u.veryobtainclass2 = WAND_CLASS; break;
			case 6: u.veryobtainclass2 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass2 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass2 = POTION_CLASS; break;
			case 9: u.veryobtainclass2 = TOOL_CLASS; break;
			case 10: u.veryobtainclass2 = FOOD_CLASS; break;
			case 11: u.veryobtainclass2 = GEM_CLASS; break;
		}
		u.veryobtainclass2boost = rnd(100);
	}

	u.veryobtainclass3 = -1;
	if (!rn2(10)) {
		if (!rn2(1000)) u.veryobtainclass3 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass3 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass3 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass3 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass3 = RING_CLASS; break;
			case 4: u.veryobtainclass3 = AMULET_CLASS; break;
			case 5: u.veryobtainclass3 = WAND_CLASS; break;
			case 6: u.veryobtainclass3 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass3 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass3 = POTION_CLASS; break;
			case 9: u.veryobtainclass3 = TOOL_CLASS; break;
			case 10: u.veryobtainclass3 = FOOD_CLASS; break;
			case 11: u.veryobtainclass3 = GEM_CLASS; break;
		}
		u.veryobtainclass3boost = rnd(100);
	}

	u.spellbookbias1 = -1;
	u.spellbookbias2 = -1;
	u.spellbookbias3 = -1;

	if (!rn2(5)) {
		u.spellbookbias1 = P_FIRST_SPELL + rn2(10);
		u.spellbookchance1 = rnd(20);
		if (!rn2(4)) {
			u.spellbookbias2 = P_FIRST_SPELL + rn2(10);
			u.spellbookchance2 = rnd(20);
			if (!rn2(5)) {
				u.spellbookbias3 = P_FIRST_SPELL + rn2(10);
				u.spellbookchance3 = rnd(20);
			}
		}
	}

	u.invisotrap = rnd(TRAPNUM-1);

	u.frequenttrap = rnd(TRAPNUM-1);
	while (u.frequenttrap == MAGIC_PORTAL || u.frequenttrap == ACTIVE_SUPERSCROLLER_TRAP || u.frequenttrap == WISHING_TRAP || u.frequenttrap == PENTAGRAM_TRAP || u.frequenttrap == THRONE_TRAP || u.frequenttrap == S_PRESSING_TRAP || u.frequenttrap == DATA_DELETE_TRAP || u.frequenttrap == ELDER_TENTACLING_TRAP || u.frequenttrap == ARTIFACT_JACKPOT_TRAP || u.frequenttrap == GOOD_ARTIFACT_TRAP || u.frequenttrap == BOON_TRAP) u.frequenttrap = rnd(TRAPNUM-1);
	u.freqtrapbonus = rnz(2) * rne(2);
	if (!rn2(5)) u.freqtrapbonus = rnz(3) * rne(3);

	u.traprandomizing = rnd(1000);

	u.trapxtradiff = 0;
	if (!rn2(10)) {
		if (rn2(5)) u.trapxtradiff = rno(20);
		else if (rn2(3)) u.trapxtradiff = rno(50);
		else u.trapxtradiff = rno(100);
	}

	u.invistrapchance = 80 + rn2(21);
	if (!rn2(5)) u.invistrapchance = 20 + rn2(81);
	u.xdifftrapchance = rno(15);
	if (!rn2(5)) u.xdifftrapchance = rno(50);
	if (!rn2(25)) u.xdifftrapchance = rno(100);
	if (u.xdifftrapchance < 1) u.xdifftrapchance = 1;
	if (u.xdifftrapchance > 100) u.xdifftrapchance = 100;

	if (Race_if(PM_WARPER)) u.youpolyamount = 5;
	else if (Race_if(PM_DOPPELGANGER)) u.youpolyamount = 10;
	else if (Race_if(PM_HEMI_DOPPELGANGER)) u.youpolyamount = 20;
	else if (Race_if(PM_DEATHMOLD)) u.youpolyamount = 50;
	else if (Race_if(PM_UNGENOMOLD)) u.youpolyamount = 100;
	else if (Race_if(PM_MOULD)) u.youpolyamount = 250;

	if (Role_if(PM_SHAPESHIFTER)) u.youpolyamount += 10;

	u.gottenbones = 0;

	u.negativeprotection = 0;
	u.tremblingamount = 0;
	u.extralives = 0;
	u.chokhmahdamage = 0;
	u.banishmentbeam = 0;
	u.levelporting = 0;
	u.inertia = 0;
	u.egglayingtimeout = 0;
	u.dragonpolymorphtime = 0;
	u.werepolymorphtime = 0;

	u.usanity = 0;

	u.impossibleproperty = -1;
	u.nonextrinsicproperty = -1;
	u.nonintrinsicproperty = -1;
	u.nondoubleproperty = -1;

	if (!rn2(2)) u.impossibleproperty = randomdisableproperty();
	if (!rn2(2)) u.nonextrinsicproperty = randomdisableproperty();
	if (!rn2(2)) u.nonintrinsicproperty = randomdisableproperty();
	if (!rn2(2)) u.nondoubleproperty = randomdisableproperty();

	u.idscrollpenalty = rnd(200); /* if rnd(this) is greater than 100, the scroll isn't ided */
	if (!rn2(7)) u.idscrollpenalty += rnz(100);
	if (!rn2(50)) u.idscrollpenalty += rnz(200);
	u.idpotionpenalty = rnd(10); /* if rnd(this) is greater than 3, the potion isn't ided */
	if (!rn2(7)) u.idpotionpenalty += rnz(5);
	if (!rn2(50)) u.idpotionpenalty += rnz(10);
	u.idringpenalty = rnd(20); /* if rnd(this) is greater than 4, the ring isn't ided */
	if (!rn2(7)) u.idringpenalty += rnz(10);
	if (!rn2(50)) u.idringpenalty += rnz(20);
	u.idamuletpenalty = rnd(20); /* if rnd(this) is greater than 15, the amulet isn't ided */
	if (!rn2(7)) u.idamuletpenalty += rnz(10);
	if (!rn2(50)) u.idamuletpenalty += rnz(20);
	u.idimplantpenalty = rnd(50); /* if rnd(this) is greater than 1, the implant isn't ided */
	if (!rn2(7)) u.idimplantpenalty += rnz(25);
	if (!rn2(50)) u.idimplantpenalty += rnz(50);
	u.idwandpenalty = rnd(12); /* if rnd(this) is greater than 3, the wand isn't ided */
	if (!rn2(7)) u.idwandpenalty += rnz(6);
	if (!rn2(50)) u.idwandpenalty += rnz(12);
	u.idarmorpenalty = rnd(30); /* if rnd(this) is greater than 15, the armor isn't ided */
	if (!rn2(7)) u.idarmorpenalty += rnz(15);
	if (!rn2(50)) u.idarmorpenalty += rnz(30);
	u.idspellbookpenalty = rnd(16); /* if rnd(this) is greater than 2, the spellbook isn't ided */
	if (!rn2(7)) u.idspellbookpenalty += rnz(8);
	if (!rn2(50)) u.idspellbookpenalty += rnz(16);
	u.idgempenalty = rnd(200); /* if rnd(this) is greater than 100, the gem isn't ided */
	if (!rn2(7)) u.idgempenalty += rnz(100);
	if (!rn2(50)) u.idgempenalty += rnz(200);
	u.idtoolpenalty = rnd(12); /* if rnd(this) is greater than 5, the tool isn't ided */
	if (!rn2(7)) u.idtoolpenalty += rnz(6);
	if (!rn2(50)) u.idtoolpenalty += rnz(12);

	u.musableremovechance = 0;
	if (!rn2(3)) u.musableremovechance += rnd(20);
	if (!rn2(5)) u.musableremovechance += rnd(20);
	if (!rn2(25)) u.musableremovechance += rnd(25);
	if (!rn2(125)) u.musableremovechance += rnd(25);
	if (!rn2(125)) u.musableremovechance += rnd(100);
	if (u.musableremovechance > 90) u.musableremovechance = 90;
	if (u.musableremovechance < 0) u.musableremovechance = 0;

	u.equipmentremovechance = 0;
	if (!rn2(3)) u.equipmentremovechance += rnd(10);
	if (!rn2(6)) u.equipmentremovechance += rnd(20);
	if (!rn2(15)) u.equipmentremovechance += rnd(20);
	if (!rn2(120)) u.equipmentremovechance += rnd(20);
	if (!rn2(120)) u.equipmentremovechance += rnd(100);
	if (u.equipmentremovechance > 90) u.equipmentremovechance = 90;
	if (u.equipmentremovechance < 0) u.equipmentremovechance = 0;

	u.bookspawnchance = 0;
	if (!rn2(20)) u.bookspawnchance += rnd(10);
	if (!rn2(200)) u.bookspawnchance += rnd(20);
	if (!rn2(2000)) u.bookspawnchance += rnd(50);
	if (!rn2(20000)) u.bookspawnchance += rnd(70);
	if (!rn2(20000)) u.bookspawnchance += rnd(100);
	if (u.bookspawnchance > 90) u.bookspawnchance = 90;
	if (u.bookspawnchance < 0) u.bookspawnchance = 0;

	u.ringspawnchance = 0;
	if (!rn2(3)) u.ringspawnchance += rnd(15);
	if (!rn2(6)) u.ringspawnchance += rnd(30);
	if (!rn2(30)) u.ringspawnchance += rnd(50);
	if (!rn2(30)) u.ringspawnchance += rnd(100);
	if (u.ringspawnchance > 90) u.ringspawnchance = 90;
	if (u.ringspawnchance < 0) u.ringspawnchance = 0;

	u.amuletspawnchance = 0;
	if (!rn2(3)) u.amuletspawnchance += rnd(20);
	if (!rn2(6)) u.amuletspawnchance += rnd(20);
	if (!rn2(15)) u.amuletspawnchance += rnd(25);
	if (!rn2(60)) u.amuletspawnchance += rnd(25);
	if (!rn2(60)) u.amuletspawnchance += rnd(100);
	if (u.amuletspawnchance > 90) u.amuletspawnchance = 90;
	if (u.amuletspawnchance < 0) u.amuletspawnchance = 0;

	u.implantspawnchance = 0;
	if (!rn2(10)) u.implantspawnchance += rnd(10);
	if (!rn2(25)) u.implantspawnchance += rnd(15);
	if (!rn2(200)) u.implantspawnchance += rnd(25);
	if (!rn2(2000)) u.implantspawnchance += rnd(40);
	if (!rn2(2000)) u.implantspawnchance += rnd(100);
	if (u.implantspawnchance > 90) u.implantspawnchance = 90;
	if (u.implantspawnchance < 0) u.implantspawnchance = 0;

	u.weaponspawnchance = 0;
	if (!rn2(3)) u.weaponspawnchance += rnd(10);
	if (!rn2(6)) u.weaponspawnchance += rnd(15);
	if (!rn2(15)) u.weaponspawnchance += rnd(15);
	if (!rn2(60)) u.weaponspawnchance += rnd(20);
	if (!rn2(250)) u.weaponspawnchance += rnd(30);
	if (!rn2(250)) u.weaponspawnchance += rnd(100);
	if (u.weaponspawnchance > 90) u.weaponspawnchance = 90;
	if (u.weaponspawnchance < 0) u.weaponspawnchance = 0;

	u.armorspawnchance = 0;
	if (!rn2(3)) u.armorspawnchance += rnd(15);
	if (!rn2(6)) u.armorspawnchance += rnd(15);
	if (!rn2(12)) u.armorspawnchance += rnd(15);
	if (!rn2(40)) u.armorspawnchance += rnd(15);
	if (!rn2(120)) u.armorspawnchance += rnd(30);
	if (!rn2(120)) u.armorspawnchance += rnd(100);
	if (u.armorspawnchance > 90) u.armorspawnchance = 90;
	if (u.armorspawnchance < 0) u.armorspawnchance = 0;

	u.toolspawnchance = 0;
	if (!rn2(3)) u.toolspawnchance += rnd(10);
	if (!rn2(6)) u.toolspawnchance += rnd(10);
	if (!rn2(15)) u.toolspawnchance += rnd(20);
	if (!rn2(60)) u.toolspawnchance += rnd(20);
	if (!rn2(250)) u.toolspawnchance += rnd(30);
	if (!rn2(250)) u.toolspawnchance += rnd(100);
	if (u.toolspawnchance > 90) u.toolspawnchance = 90;
	if (u.toolspawnchance < 0) u.toolspawnchance = 0;

	u.foodspawnchance = 0;
	if (!rn2(2)) u.foodspawnchance += rnd(5);
	if (!rn2(4)) u.foodspawnchance += rnd(5);
	if (!rn2(8)) u.foodspawnchance += rnd(10);
	if (!rn2(25)) u.foodspawnchance += rnd(20);
	if (!rn2(100)) u.foodspawnchance += rnd(20);
	if (!rn2(500)) u.foodspawnchance += rnd(30);
	if (!rn2(500)) u.foodspawnchance += rnd(100);
	if (u.foodspawnchance > 90) u.foodspawnchance = 90;
	if (u.foodspawnchance < 0) u.foodspawnchance = 0;

	u.shopitemreduction = 0;
	if (rn2(5)) u.shopitemreduction += rnd(15);
	if (!rn2(3)) u.shopitemreduction += rnd(15);
	if (!rn2(6)) u.shopitemreduction += rnd(20);
	if (!rn2(25)) u.shopitemreduction += rnd(20);
	if (!rn2(125)) u.shopitemreduction += rnd(20);
	if (!rn2(125)) u.shopitemreduction += rnd(100);
	if (u.shopitemreduction > 90) u.shopitemreduction = 90;
	if (u.shopitemreduction < 0) u.shopitemreduction = 0;

	u.potionspawnchance = 0;
	if (!rn2(2)) u.potionspawnchance += rnd(10);
	if (!rn2(4)) u.potionspawnchance += rnd(10);
	if (!rn2(8)) u.potionspawnchance += rnd(15);
	if (!rn2(25)) u.potionspawnchance += rnd(15);
	if (!rn2(100)) u.potionspawnchance += rnd(20);
	if (!rn2(500)) u.potionspawnchance += rnd(20);
	if (!rn2(500)) u.potionspawnchance += rnd(100);
	if (u.potionspawnchance > 90) u.potionspawnchance = 90;
	if (u.potionspawnchance < 0) u.potionspawnchance = 0;

	u.scrollspawnchance = 0;
	if (!rn2(2)) u.scrollspawnchance += rnd(10);
	if (!rn2(4)) u.scrollspawnchance += rnd(10);
	if (!rn2(8)) u.scrollspawnchance += rnd(10);
	if (!rn2(16)) u.scrollspawnchance += rnd(10);
	if (!rn2(35)) u.scrollspawnchance += rnd(10);
	if (!rn2(90)) u.scrollspawnchance += rnd(10);
	if (!rn2(200)) u.scrollspawnchance += rnd(15);
	if (!rn2(900)) u.scrollspawnchance += rnd(15);
	if (!rn2(900)) u.scrollspawnchance += rnd(100);
	if (u.scrollspawnchance > 90) u.scrollspawnchance = 90;
	if (u.scrollspawnchance < 0) u.scrollspawnchance = 0;

	u.wandspawnchance = 0;
	if (!rn2(3)) u.wandspawnchance += rnd(10);
	if (!rn2(6)) u.wandspawnchance += rnd(15);
	if (!rn2(15)) u.wandspawnchance += rnd(15);
	if (!rn2(60)) u.wandspawnchance += rnd(15);
	if (!rn2(240)) u.wandspawnchance += rnd(15);
	if (!rn2(600)) u.wandspawnchance += rnd(20);
	if (!rn2(600)) u.wandspawnchance += rnd(100);
	if (u.wandspawnchance > 90) u.wandspawnchance = 90;
	if (u.wandspawnchance < 0) u.wandspawnchance = 0;

	u.antimusablebias = 0;
	if (!rn2(3)) u.antimusablebias = rno(100);

	u.concealitemchance = 0;
	if (!rn2(3)) u.concealitemchance += rnd(20);
	if (!rn2(5)) u.concealitemchance += rnd(20);
	if (!rn2(7)) u.concealitemchance += rnd(25);
	if (!rn2(9)) u.concealitemchance += rnd(25);
	if (!rn2(9)) u.concealitemchance += rnd(100);
	if (u.concealitemchance > 90) u.concealitemchance = 90;
	if (u.concealitemchance < 0) u.concealitemchance = 0;

	u.usefulitemchance = 0;
	if (!rn2(2)) u.usefulitemchance += rnd(10);
	if (!rn2(5)) u.usefulitemchance += rnd(10);
	if (!rn2(25)) u.usefulitemchance += rnd(10);
	if (!rn2(100)) u.usefulitemchance += rnd(15);
	if (!rn2(250)) u.usefulitemchance += rnd(15);
	if (!rn2(750)) u.usefulitemchance += rnd(15);
	if (!rn2(3250)) u.usefulitemchance += rnd(15);
	if (!rn2(3250)) u.usefulitemchance += rnd(100);
	if (u.usefulitemchance > 90) u.usefulitemchance = 90;
	if (u.usefulitemchance < 0) u.usefulitemchance = 0;

	u.eeveelution = PM_VAPOREON; /* failsafe */
	if (u.monstertimefinish % 42 == 0) u.eeveelution = PM_VOLAREON;
	else if (u.monstertimefinish % 29 == 0) u.eeveelution = PM_SPIRITEON;
	else if (u.monstertimefinish % 23 == 0) u.eeveelution = PM_INSECTEON;
	else if (u.monstertimefinish % 19 == 0) u.eeveelution = PM_VENOMEON;
	else if (u.monstertimefinish % 15 == 0) u.eeveelution = PM_SYLVEON;
	else if (u.monstertimefinish % 13 == 0) u.eeveelution = PM_GLACEON;
	else if (u.monstertimefinish % 11 == 0) u.eeveelution = PM_LEAFEON;
	else if (u.monstertimefinish % 10 == 0) u.eeveelution = PM_UMBREON;
	else if (u.monstertimefinish % 9 == 0) u.eeveelution = PM_ESPEON;
	else if (u.monstertimefinish % 7 == 0) u.eeveelution = PM_JOLTEON;
	else if (u.monstertimefinish % 3 == 0) u.eeveelution = PM_FLAREON;
	else u.eeveelution = PM_VAPOREON;

	u.greencrossopen = FALSE; /* initialized at game start only */
	u.prematuresubquest = FALSE;
	u.prematureyendortower = FALSE;
	u.arstechnicadone = FALSE;

	u.greencrosschance = rnd(20);

	u.untrainableskill = 0;
	u.halfspeedskill = 0;
	u.fifthspeedskill = 0;
	u.basiclimitskill = 0;
	u.skilledlimitskill = 0;
	u.expertlimitskill = 0;
	u.earlytrainingskill = 0;
	u.earlytrainingtimer = 9999999;
	u.frtrainingskill = 0;
	u.frtrainingtimer = 9999999;
	u.latetrainingskill = 0;
	u.latetrainingtimer = 9999999;
	u.lavtrainingskill = 0;
	u.lavtrainingtimer = 0;
	u.slowtrainingskill = 0;

	u.hiddenpowerskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();

	if (!rn2(2)) u.untrainableskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.halfspeedskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.fifthspeedskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.basiclimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.skilledlimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.expertlimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) {
		u.earlytrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.earlytrainingtimer = rnz(50);
		u.earlytrainingtimer = rnd(u.earlytrainingtimer);
		u.earlytrainingtimer = rnz(u.earlytrainingtimer); /* calculations by jonadab */
	}
	u.earlytrainingblown = FALSE;

	if (!rn2(3)) {
		u.frtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.frtrainingtimer = rnz(50);
		u.frtrainingtimer = rnd(u.frtrainingtimer);
		u.frtrainingtimer = rnz(u.frtrainingtimer);
		u.frtrainingtimer *= rnz(20);
	}
	u.frtrainingblown = FALSE;

	if (!rn2(2)) {
		u.latetrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.latetrainingtimer = rnz(10000) + rnd(50000);
	}

	if (!rn2(2)) {
		u.lavtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.lavtrainingtimer = rnz(10000) + rnd(50000);
	}
	if (!rn2(2)) u.slowtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();

	u.stickycursechance = 0;
	if (!rn2(10)) {
		u.stickycursechance = rnd(10);
		if (!rn2(5)) u.stickycursechance += rnd(15);
		if (!rn2(25)) u.stickycursechance += rnd(15);
		if (!rn2(125)) u.stickycursechance += rnd(20);
		if (!rn2(625)) u.stickycursechance += rnd(20);
		if (!rn2(3225)) u.stickycursechance += rnd(20);
		if (u.stickycursechance > 100) u.stickycursechance = 100;
	}

	u.heavycursechance = 0;
	u.primecursechance = 0;
	if (!rn2(25)) {
		u.heavycursechance = rnd(25);
		if (!rn2(5)) u.heavycursechance += rnd(25);
		if (!rn2(15)) u.heavycursechance += rnd(25);
		if (!rn2(75)) u.heavycursechance += rnd(25);
		if (u.heavycursechance > 100) u.heavycursechance = 100;

		if (!rn2(100)) {
			u.primecursechance = rnd(10);
			if (!rn2(5)) u.primecursechance += rnd(15);
			if (!rn2(25)) u.primecursechance += rnd(15);
			if (!rn2(125)) u.primecursechance += rnd(20);
			if (!rn2(750)) u.primecursechance += rnd(20);
			if (!rn2(2500)) u.primecursechance += rnd(20);
			if (u.primecursechance > 100) u.primecursechance = 100;
		}
	}

	u.genericcursechance = 0;
	if (!rn2(10)) {
		u.genericcursechance = rnd(5);
		if (!rn2(5)) u.genericcursechance = rnd(15);
		if (!rn2(25)) u.genericcursechance = rnd(33);
	}

	u.pract_procrastinatetimer = rn1(500000, 500000);

	u.monstermultiplier = 100;
	if (rn2(3)) {
		if (rn2(2)) {
			while (rn2(6)) u.monstermultiplier--;
		} else {
			while (rn2(6)) u.monstermultiplier++;
		}
	}
	if (u.monstermultiplier < 10) u.monstermultiplier = 10; /* sanity check */
	if (u.monstermultiplier > 190) u.monstermultiplier = 190;

	u.drippingtread = 0;
	u.drippingtreadtype = 0;
	u.geolysis = 0;
	u.disruptionshield = 0;
	u.spellbinder = 0;
	u.spellbinder1 = -1;
	u.spellbinder2 = -1;
	u.spellbinder3 = -1;
	u.spellbinder4 = -1;
	u.spellbinder5 = -1;
	u.spellbinder6 = -1;
	u.spellbinder7 = -1;
	u.inertiacontrol = 0;
	u.inertiacontrolspell = -1;
	u.inertiacontrolspellno = -1;
	u.sterilized = 0;
	u.halresdeactivated = 0;

	u.nailpolish = 0;
	u.berserktime = 0;
	u.magicshield = 0;
	u.burrowed = 0;
	u.stasistime = 0;
	u.powerfailure = 0;
	u.tunnelized = 0;
	u.enchantspell = 0;
	u.thornspell = 0;

	u.polyformed = 0;

	u.boomshined = 0;
	u.kyliemode = 0;
	u.pinkspelldirection = -1;
	u.trontrapdirection = -1;
	u.trontrapturn = 1;

	u.miscolornumber = 0;
	u.onerainbownumber = 0;

	u.hangupamount = 0;

	u.bellimbued = 0;
	u.amuletimbued1 = 0;
	u.amuletimbued2 = 0;
	u.amuletimbued3 = 0;
	u.amuletcompletelyimbued = 0;

	u.vibratingsquarefind = 0;

	u.wonderlandescape = 0;
	u.zapemescape = 0;
	u.preversionescape = 0;

	u.felidlives = 9;

	u.homosexual = 0;

	u.dungeongrowthhack = 0;

	rivalrolerestore();

	u.katitrapocc = 0;
	u.singtrapocc = 0;
	u.singtraptreaded = FALSE;
	u.singtraphighheel = FALSE;
	u.singtrapcowdung = FALSE;

	u.cellargravate = 0;

	u.walscholarpass = 0;
	u.symbiotedmghack = FALSE;
	u.lamefarmer = FALSE;

	u.goodoffercount = 10;
	u.dirtifiedexcalibur = FALSE;
	u.antjetwotriggered = FALSE;
	u.pervertsex = 0;
	u.pervertpray = 0;
	u.mushroompoles = 0;
	u.grenadoninlauncher = 0;
	u.nataljetrapturns = 0;
	u.capoeiraturns = 0;
	u.sabrinaturns = 0;
	u.sabrinaactive = FALSE;
	u.rangedreload = 0;
	u.repunishcounter = 0;
	u.laratraptimer = 0;
	u.knowofthecursetimer = 0;
	u.missingstaircase = 0;
	u.mondiffhack = 0;
	u.levelmarked = FALSE;
	u.sweatyshoetimer = 0;
	u.stonedchilltimer = 0;
	u.moneydebt = 0;
	u.havebeeninludios = 0;
	u.maxrndmonstchoicecount = 0;

	u.martialstyle = MARTIALSTYLE_BRAWLING; /* can be changed with martial style tech */
	if (Race_if(PM_SAMEDI)) u.martialstyle = MARTIALSTYLE_CAPOEIRA; /* sons of samedi always use capoeira */

	u.coronations = 0;
	u.inasuppression = 0;
	u.conclusiocount = 0;
	u.elberethcheese = 0;
	u.pompejiwantedlevel = 0;
	u.pompejipermanentrecord = 0;
	u.fluidatorwantedlevel = 0;
	u.fluidatorwarning = 0;
	u.bulletatorwantedlevel = 0;
	u.bulletatortimer = 0;
	u.bulletatorgun = 0;
	u.bulletatorbow = 0;
	u.bulletatorxbow = 0;
	u.bulletatorsling = 0;
	u.bulletatorjavelin = 0;
	u.lifesavepenalty = 0;
	u.lifesavepenallevel = 0;
	u.itemcleanupneeded = 0;
	u.casinochips = 0;
	if (Role_if(PM_COURIER)) u.casinochips++; /* keyword "newroles", "newraces" */
	if (Role_if(PM_WEIRDBOY)) u.casinochips++;
	if (Role_if(PM_GANGSTER)) u.casinochips += 2;

	u.tumblrerpersist = 0;
	if (Race_if(PM_TUMBLRER)) u.tumblrerpersist = 100000;
	u.addictpersist = 0;
	if (Race_if(PM_ADDICT)) u.addictpersist = 100000;
	u.startscummerpersist = 0;
	if (Race_if(PM_STARTSCUMMER)) u.startscummerpersist = 200000;
	u.deenergiserpersist = 0;
	if (Race_if(PM_DE_ENERGISER)) u.deenergiserpersist = 100000;

	u.demagoguepersist = 0;
	if (Role_if(PM_DEMAGOGUE)) u.demagoguepersist = 100000;
	u.spellmasterpersist = 0;
	if (Role_if(PM_SPELLMASTER)) u.spellmasterpersist = 100000;
	u.alltecherpersist = 0;
	if (Role_if(PM_ALLTECHER)) u.alltecherpersist = 200000;

	u.superspecialspell = -1;

	/* set player's haircut to a random value at game start --Amy */
	u.femalehaircut = rnd(55);
	u.malehaircut = rnd(18);
	u.malebeard = rnd(48);
	/* ...it is not a bug that we set this stuff for both genders, because we want you to have something randomized
	 * in case you e.g. use an amulet of change */

	u.barbertimer = 5000; /* TODO make this different depending on starting role/race? */
	u.barberamount = 0;

	/* set player's areola diameter (from FATAL, sue me) to a random value at game start --Amy */
	u.areoladiameter = 20;
	if (rn2(10)) {
		if (rn2(2)) {
			u.areoladiameter += rnd(10);
			while (!rn2(2)) {
				u.areoladiameter++;
			}
		}
		else {
			u.areoladiameter -= rnd(10);
			while (!rn2(2)) {
				u.areoladiameter--;
			}
		}
	}
	if (u.areoladiameter < 1) u.areoladiameter = 1; /* fail safe */
	if (u.areoladiameter > 40) u.areoladiameter = 40; /* fail safe */

	u.secretcodenumber = rn2(10000);

	u.bucskill = 0;
	u.enchantrecskill = 0;
	u.weapchantrecskill = 0;

	if (Race_if(PM_KNOWLEDGABLE)) {
		u.bucskill += 50;
		u.enchantrecskill += 50;
		u.weapchantrecskill += 50;
	}

	u.alla = 1000;
	u.juyofleeing = 1;
	u.controlmiguc = 1;
	u.riderhack = 0;
	u.bodyfluideffect = 0;
	u.garbagecleaned = 0;
	u.garbagetrucktime = 0;
	u.antitelespelltimeout = 0;
	u.breathenhancetimer = 0;
	u.mushroompoleused = 0;
	u.automorefuckthisshit = 0;
	u.nataljetrapx = 0;
	u.nataljetrapy = 0;
	u.riennevaplus = 0;
	u.stairscumslowing = 0;
	u.swappositioncount = 0;
	u.contingencyturns = 0;
	u.horsehopturns = 0;
	u.ragnarokspelltimeout = 0;
	u.freeplaymode = 0;
	u.howtoenhanceskills = 0;

	u.nataliacyclestart = rn2(2800);
	u.nataliacycletimer = u.nataliacyclestart;
	u.nataliafollicularend = 1200 + rn2(401);
	u.natalialutealstart = 200 + rn2(401);

	u.usymbiote.active = 0;
	u.usymbiote.mnum = PM_PLAYERMON;
	u.usymbiote.mhp = 0;
	u.usymbiote.mhpmax = 0;
	u.usymbiote.cursed = u.usymbiote.hvycurse = u.usymbiote.prmcurse = u.usymbiote.bbcurse = u.usymbiote.morgcurse = u.usymbiote.evilcurse = u.usymbiote.stckcurse = 0;

	u.stoogedepth = 0;
	if (!rn2(10)) {
		u.stoogedepth = 6 + rn2(5);
		if (!rn2(20)) u.stoogedepth = rnd(100);
	}

	u.copwantedlevel = 0;
	u.treesquadwantedlevel = 0;

	u.gmmailsreceived = 0;

	u.bedsleeping = 0;
	u.shiftingsandsinking = 0;

	u.contamination = 0;

	u.aggravation = 0;
	u.heavyaggravation = 0;
	u.outtadepthtrap = 0;

	u.petcollectitems = 1;
	u.petattackenemies = 2; /* -1 = passive, 0 = don't attack anything, 1 = only attack hostiles, 2 = attack everything */
	u.petcaneat = 1;
	u.petcanfollow = 1;

	u.segfaultpanic = 0;

	u.combostrike = 0;
	u.bizarrotries = 0;
	u.comboactive = 0;

	u.femcombostrike = 0;
	u.femcomboactive = 0;

	u.dancercombostrike = 0;
	u.dancercomboactive = 0;

	u.steedhitchance = 25;
	u.symbioteaggressivity = 25;

	u.urmaxlvl = 1; /* will go up if an rodneyan race player levels up */
	u.urmaxlvlB = 1; /* will go up if a cyborg role player levels up */
	u.urmaxlvlC = 1; /* will go up if a binder role player levels up */
	u.urmaxlvlD = 1; /* will go up if a bard role player levels up */
	u.urmaxlvlE = 1; /* will go up if an american gladiator player levels up */
	u.urmaxlvlF = 1; /* will go up if a wild talent role player levels up */
	u.urmaxlvlG = 1; /* will go up if a wild talent role player levels up */
	u.urmaxlvlH = 1; /* will go up if a mystic role player levels up */
	u.urmaxlvlI = 1; /* will go up if a DQ Slime with green slime race levels up */
	u.urmaxlvlJ = 1; /* will go up if an anachronounbinder role player levels up */
	u.urmaxlvlK = 1; /* will go up if a SJW role player levels up */
	u.urmaxlvlL = 1; /* will go up if an asgardian race player levels up */
	u.urmaxlvlM = 1; /* will go up if an missingno race player levels up */
	u.urmaxlvlN = 1; /* will go up whenever any player levels up */
	u.urmaxlvlUP = 1; /* will go up whenever any player levels up */
	u.xtralevelmult = 1; /* will go up if you level up from EXP points while already XL30 */

	/* sanity check for the gods --Amy */
	if (SIZE(lawfulgods) != SIZE(neutralgods)) impossible("ERROR! lawful and neutral gods arrays do not match (%d, %d)", SIZE(lawfulgods), SIZE(neutralgods));
	if (SIZE(lawfulgods) != SIZE(chaoticgods)) impossible("ERROR! lawful and chaotic gods arrays do not match (%d, %d)", SIZE(lawfulgods), SIZE(chaoticgods));

	u.uhereticgodinit = 0; /* for heretic race */
	if (isheretic) {
		u.uhereticgodlawful = rn2(SIZE(lawfulgods));
		u.uhereticgodneutral = rn2(SIZE(neutralgods));
		u.uhereticgodchaotic = rn2(SIZE(chaoticgods));
		u.hereticlgod = lawfulgods[u.uhereticgodlawful];
		u.hereticngod = neutralgods[u.uhereticgodneutral];
		u.hereticcgod = chaoticgods[u.uhereticgodchaotic];

		if (!rn2(3)) {
			u.uhereticgodlawful = rn2(SIZE(hereticgods));
			u.hereticlgod = hereticgods[u.uhereticgodlawful];
			u.uhereticgodinit += 1;

		}
		if (!rn2(3)) {
			u.uhereticgodneutral = rn2(SIZE(hereticgods));
			u.hereticngod = hereticgods[u.uhereticgodneutral];
			u.uhereticgodinit += 2;

		}
		if (!rn2(3)) {
			u.uhereticgodchaotic = rn2(SIZE(hereticgods));
			u.hereticcgod = hereticgods[u.uhereticgodchaotic];
			u.uhereticgodinit += 4;

		}
	}

	if (!isheretic && (Role_if(PM_GUNNER) || Role_if(PM_ANACHRONIST) || Role_if(PM_PRIEST) || Role_if(PM_MYSTIC) || Role_if(PM_SHAPESHIFTER) || Role_if(PM_ERDRICK) || Role_if(PM_WILD_TALENT) )) {

		u.uhereticgodlawful = rn2(SIZE(lawfulgods));
		u.uhereticgodneutral = u.uhereticgodlawful;
		u.uhereticgodchaotic = u.uhereticgodlawful;
		u.hereticlgod = lawfulgods[u.uhereticgodlawful];
		u.hereticngod = neutralgods[u.uhereticgodneutral];
		u.hereticcgod = chaoticgods[u.uhereticgodchaotic];

	}

	if (Role_if(PM_FAILED_EXISTENCE) || Role_if(PM_TRANSSYLVANIAN) ) {
		u.uhereticgodlawful = rn2(SIZE(hereticgods));
		u.uhereticgodneutral = rn2(SIZE(hereticgods));
		u.uhereticgodchaotic = rn2(SIZE(hereticgods));
		u.hereticlgod = hereticgods[u.uhereticgodlawful];
		u.hereticngod = hereticgods[u.uhereticgodneutral];
		u.hereticcgod = hereticgods[u.uhereticgodchaotic];
	}

	/* fail safe - this will be essential for the recursion trap that changes the player's role or race --Amy */
	if (!isheretic && !Role_if(PM_GUNNER) && !Role_if(PM_WILD_TALENT) && !Role_if(PM_ANACHRONIST) && !Role_if(PM_PRIEST) && !Role_if(PM_MYSTIC) && !Role_if(PM_SHAPESHIFTER) && !Role_if(PM_FAILED_EXISTENCE) && !Role_if(PM_TRANSSYLVANIAN) && !Role_if(PM_ERDRICK)) {
		u.uhereticgodlawful = rn2(SIZE(hereticgods));
		u.uhereticgodneutral = rn2(SIZE(hereticgods));
		u.uhereticgodchaotic = rn2(SIZE(hereticgods));
		u.hereticlgod = hereticgods[u.uhereticgodlawful];
		u.hereticngod = hereticgods[u.uhereticgodneutral];
		u.hereticcgod = hereticgods[u.uhereticgodchaotic];
	}


/* In order to make the game even more interesting for lost souls, they cannot level teleport or branchport at all. */

	u.ualignbase[A_CURRENT] = u.ualignbase[A_ORIGINAL] = u.ualign.type =
			aligns[flags.initalign].value;
	u.ulycn = NON_PM;
#if defined(BSD) && !defined(POSIX_TYPES)
	(void) time((long *)&u.ubirthday);
#else
	(void) time(&u.ubirthday);
#endif
	/*
	 *  For now, everyone but elves, cavemen and lycanthropes starts
	 *  out with a night vision range of 1 and their xray range disabled.
	 */
	u.nv_range   =  1;
	u.xray_range = -1; /* set in allmain.c if applicable --Amy */
	u.artifactprotection = 0;
	u.fumbleduration = 0;
	u.antimagicshell = 0;

	reset_nastinator();

	if (isnastinator) { /* harder than hard race - starts with uncurable nasty trap effects --Amy */

		gain_nastinator();

		while ((rnd(7)) < 3) {

			gain_nastinator();

		}
	}

	if (iswindinhabitant) { /* similar to nastinator, but they will be re-initialized sometimes --Amy */

		gain_nastinator();

		while (!rn2(3)) {

			gain_nastinator();

		}
	}

	/* Role-specific initializations */

	if (!israndomizer && !isnullrace) {

	switch (Role_switch) {
	case PM_ARCHEOLOGIST:
		switch (rnd(5)) {   
		    case 1: Archeologist[A_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Archeologist[A_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Archeologist[A_BOOK].trotyp = SPE_LIGHT; break;
		    case 4: Archeologist[A_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Archeologist[A_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Archeologist);
		if(!rn2(4)) ini_inv(Blindfold);
		else if(!rn2(4)) ini_inv(Towel);
		if(!rn2(4)) ini_inv(Leash);
		if(!rn2(4)) ini_inv(Tinopener);
		else if(!rn2(4))
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		if(!rn2(8)) ini_inv(Magicmarker);
		knows_object(TOUCHSTONE);
		knows_object(SACK);
		skill_init(Skill_A);
		break;

	case PM_AUGURER:
		switch (rnd(5)) {   
		    case 1: Augurer[AUG_BOOK].trotyp = SPE_CAUSE_FEAR; break;
		    case 2: Augurer[AUG_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Augurer[AUG_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 4: Augurer[AUG_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Augurer[AUG_BOOK].trotyp = (!rn2(3) ? SPE_SLEEP : !rn2(2) ? SPE_IDENTIFY : SPE_MAGIC_MAPPING); break;
		    default: break;
		}
		ini_inv(Augurer);
		if(!rn2(4)) ini_inv(Candle);
		else if(!rn2(4)) ini_inv(Touchstone);
		else if(!rn2(4)) ini_inv(Magicmarker);

		skill_init(Skill_Aug);
		break;

	case PM_ANACHRONIST:

		ini_inv(Anachronist);

		skill_init(Skill_Ana);
		break;

	case PM_BARBARIAN:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    Barbarian[B_MAJOR].trotyp = BATTLE_AXE;
		    Barbarian[B_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(Barbarian);
		if(!rn2(6)) ini_inv(Torch);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_B);
		break;
	case PM_NOOB_MODE_BARB:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    NoobModeBarb[N_MAJOR].trotyp = BATTLE_AXE;
		    NoobModeBarb[N_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(NoobModeBarb);
		skill_init(Skill_Noo);
		break;
	case PM_BINDER:
		ini_inv(Binder);
		skill_init(Skill_Bin);
	  increasesincounter(16); /*One transgression is all it takes*/
	  u.alignlim -= 16;
	    change_luck(-1); /*One resurection or two rehumanizations is all it takes*/
		break;

	case PM_POLITICIAN:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = (3000 + rnd(2000));
#else
		u.umoney0 = (3000 + rnd(2000));
#endif
		ini_inv(Politician);
		skill_init(Skill_Pol);


		break;

	case PM_DQ_SLIME:

		ini_inv(DQSlime);
		skill_init(Skill_Sli);

		break;

	case PM_ALLTECHER:

		ini_inv(Alltecher);
		skill_init(Skill_All);

		break;

	case PM_SPELLMASTER:

		ini_inv(Spellmaster);
		skill_init(Skill_Spe);

		break;

	case PM_ERDRICK:

		ini_inv(Erdrick);
		skill_init(Skill_Erd);
		if (!rn2(4)) ini_inv(ErdrickKey);

		break;

	case PM_BLEEDER:
		ini_inv(Bleeder);
		skill_init(Skill_Ble);
		break;
	case PM_LIBRARIAN:
		ini_inv(Librarian);
		skill_init(Skill_Lib);
		break;
	case PM_SUPERMARKET_CASHIER:

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 500;
#else
		u.umoney0 = 500;
#endif

		ini_inv(Supermarket);
		if ((rnd(5)) > 2) ini_inv(SupermarketB);
		if (!rn2(5)) ini_inv(SupermarketA);
		skill_init(Skill_Sup);
		break;
	case PM_INTEL_SCRIBE:
		ini_inv(Scribe);
		skill_init(Skill_Scr);
		break;
	case PM_GAMER:
		ini_inv(Gamer);
		skill_init(Skill_Gam);
		break;
	case PM_ARTIST:
		ini_inv(Artist);
		skill_init(Skill_Art);
		break;
	case PM_COOK:
		ini_inv(Cook);
		skill_init(Skill_Coo);
		break;
	case PM_BARD:
		if (rn2(100) >= 50) Bard[BARD_INSTR].trotyp = WOODEN_FLUTE;
		if (rn2(100) >= 85) Bard[BARD_WHISTLE].trotyp = BELL;
		Bard[BARD_BOOZE].trquan = rn1(2, 5);
		ini_inv(Bard);
		/* This depends on the order in objects.c */
		for (i = TIN_WHISTLE; i <= DRUM_OF_EARTHQUAKE; i++)
			knows_object(i);
		/* Bards know about the enchantment spellbooks, though they don't know
		   the spells */
		knows_object(SPE_SLEEP);
		knows_object(SPE_CONFUSE_MONSTER);
		knows_object(SPE_SLOW_MONSTER);
		knows_object(SPE_CAUSE_FEAR);
		knows_object(SPE_CHARM_MONSTER);
		/* Bards also know a lot about legendary & magical stuff. */
		know_random_obj();
		skill_init(Skill_Bard);
		break;
	case PM_CAVEMAN:
		u.nv_range = 2;
		Cave_man[C_AMMO].trquan = rn1(11, 10);	/* 10..20 */
		ini_inv(Cave_man);
		skill_init(Skill_C);
		break;
	case PM_GANGSTER:
		ini_inv(Gangster);
		skill_init(Skill_Gan);
		break;
	case PM_GUNNER:
		ini_inv(Gunner);
		skill_init(Skill_Gun);
		break;
	case PM_DOOM_MARINE:
		ini_inv(DoomMarine);
		skill_init(Skill_Mar);
		break;
	case PM_DEATH_EATER:
		ini_inv(Death_Eater);
		skill_init(Skill_Dea);
		break;
	case PM_POKEMON:
		ini_inv(Pokemon);
		skill_init(Skill_Pok);
		break;
	case PM_FLAME_MAGE:
		switch (rnd(2)) {                
			case 1: Flame_Mage[F_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
			case 2: Flame_Mage[F_BOOK].trotyp = SPE_LIGHT; break;
			default: break;
		}
		ini_inv(Flame_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		skill_init(Skill_F);
		break;
	case PM_COURIER:
        ini_inv(Courier);
        skill_init(Skill_Cou);
		break;

	case PM_CAMPERSTRIKER:
        ini_inv(Camperstriker);
        skill_init(Skill_Cam);
		break;

	case PM_SPACEWARS_FIGHTER:
        ini_inv(Spacewars_Fighter);
        skill_init(Skill_Spa);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 1500;
#else
		u.umoney0 = 1500;
#endif
		break;

	case PM_ROCKER:
        ini_inv(Rocker);
        skill_init(Skill_Roc);
		break;

	case PM_ZYBORG:
        ini_inv(Zyborg);
        skill_init(Skill_Zyb);
		break;

	case PM_LUNATIC:
        ini_inv(Lunatic);
        skill_init(Skill_Lun);

		if (!Race_if(PM_AK_THIEF_IS_DEAD_)) {
		switch (rnd(7)) {
		case 1: 	    u.ulycn = PM_WEREWOLF; break;
		case 2: 	    u.ulycn = PM_WEREJACKAL; break;
		case 3: 	    u.ulycn = PM_WERERAT; break;
		case 4: 	    u.ulycn = PM_WEREPANTHER; break;
		case 5: 	    u.ulycn = PM_WERETIGER; break;
		case 6: 	    u.ulycn = PM_WERESNAKE; break;
		case 7: 	    u.ulycn = PM_WERESPIDER; break;
		default: 	    u.ulycn = PM_WEREWOLF; break;

		}
		}

		break;

	case PM_CONVICT:
        ini_inv(Convict);
        knows_object(SKELETON_KEY);
        knows_object(GRAPPLING_HOOK);
        skill_init(Skill_Con);
	  increasesincounter(16); /* You have sinned */
	  u.alignlim -= 16;
        u.uhunger = 550;  /* On the verge of hungry */
    	/* u.ualignbase[A_CURRENT] = u.ualignbase[A_ORIGINAL] =
        u.ualign.type = A_CHAOTIC; Override racial alignment */
        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
        urace.lovemask = 0; /* Convicts are pariahs of their race */
	    change_luck(-1); /* both their alignment and luck start out negative */
        break;

	case PM_MURDERER:

		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_ONE].trotyp = HELM_OF_THIRST; Murderer[M_ITEM_ONE].trspe = 3; break;
			case 2: Murderer[M_ITEM_ONE].trotyp = HELM_OF_BAD_ALIGNMENT; Murderer[M_ITEM_ONE].trspe = 0; break;
			default: break;
		}

		switch (rnd(5)) {                
			case 1: Murderer[M_ITEM_TWO].trotyp = GAUNTLETS_OF_TRAP_CREATION; Murderer[M_ITEM_TWO].trspe = 0; break;
			case 2: 
			case 3:
			case 4:
			case 5: Murderer[M_ITEM_TWO].trotyp = UNDROPPABLE_GLOVES; Murderer[M_ITEM_TWO].trspe = 2; break;
			default: break;
		}

		switch (rnd(11)) {                
			case 1: Murderer[M_ITEM_THREE].trotyp = STONE_OF_MAGIC_RESISTANCE; break;
			case 2: Murderer[M_ITEM_THREE].trotyp = SHADES_OF_GREY_STONE; break;
			case 3: Murderer[M_ITEM_THREE].trotyp = DSTW_STONE; break;
			case 4: Murderer[M_ITEM_THREE].trotyp = CONFUSION_STONE; break;
			case 5: Murderer[M_ITEM_THREE].trotyp = STONE_OF_INTRINSIC_LOSS; break;
			case 6: Murderer[M_ITEM_THREE].trotyp = ALIGNMENT_STONE; break;
			case 7: Murderer[M_ITEM_THREE].trotyp = TRAP_CREATION_STONE; break;
			case 8: Murderer[M_ITEM_THREE].trotyp = STONE_OF_VULNERABILITY; break;
			case 9: Murderer[M_ITEM_THREE].trotyp = STONE_OF_CURSING; break;
			case 10: Murderer[M_ITEM_THREE].trotyp = STATUS_STONE; break;
			case 11: Murderer[M_ITEM_THREE].trotyp = DEAFNESS_STONE; break;
			default: break;
		}

		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_FOUR].trotyp = TINNING_KIT; break;
			case 2: Murderer[M_ITEM_FOUR].trotyp = CAN_OF_GREASE; break;
			default: break;
		}

        ini_inv(Murderer);
        skill_init(Skill_Mur);
	  increasesincounter(16); /* You have sinned */
	  u.alignlim -= 16;
        u.uhunger = 550;  /* On the verge of hungry */
        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
        urace.lovemask = 0; /* Murderers are pariahs of their race */
	    change_luck(-1); /* both their alignment and luck start out negative */
        break;

	case PM_HEALER:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(1000, 1001);
#else
		u.umoney0 = rn1(1000, 1001);
#endif
		ini_inv(Healer);
		knows_classX(POTION_CLASS); /* WAC - remove? */ /* edit by Amy - nope, but change to include magic ones */
		knows_object(POT_SICKNESS);
		knows_object(POT_BLINDNESS);
		knows_object(POT_HALLUCINATION);
		knows_object(POT_RESTORE_ABILITY);
		knows_object(POT_FULL_HEALING);
		knows_object(HEALTHSTONE);	/* KMH */
		if(!rn2(5)) ini_inv(Lamp);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		skill_init(Skill_H);
		break;
	case PM_ICE_MAGE:
		switch (rnd(2)) {                
			case 1: Ice_Mage[I_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
			case 2: Ice_Mage[I_BOOK].trotyp = SPE_SLOW_MONSTER; break;
			default: break;
		}
		ini_inv(Ice_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		skill_init(Skill_I);
		break;

	case PM_ELECTRIC_MAGE:
		ini_inv(Electric_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		skill_init(Skill_Ele);
		break;

	case PM_POISON_MAGE:
		ini_inv(Poison_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		skill_init(Skill_Poi);
		break;

	case PM_CRUEL_ABUSER:
		ini_inv(Abuser);
		skill_init(Skill_Abu);
		break;

	case PM_MYSTIC:
		ini_inv(Mystic);
		skill_init(Skill_Mys);
		break;

	case PM_JESTER:
		ini_inv(Jester);
		skill_init(Skill_Jes);
		break;

	case PM_LADIESMAN:
		ini_inv(Ladiesman);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 300;
#else
		u.umoney0 = 300;
#endif
		skill_init(Skill_Lad);
		break;

	case PM_FIGHTER:
		ini_inv(Fighter);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);

		skill_init(Skill_Fig);
		break;

	case PM_FENCER:
		ini_inv(Fencer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);

		skill_init(Skill_Fen);
		break;

	case PM_MEDIUM:
		Medium[MED_TWO_ARROWS].trquan = rn1(10, 50);
		Medium[MED_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Medium);

		skill_init(Skill_Med);
		break;

	case PM_SEXYMATE:
		ini_inv(Sexymate);

		skill_init(Skill_Sex);
		break;

	case PM_STAND_USER:
		ini_inv(StandUser);

		skill_init(Skill_Sta);
		break;

	case PM_JUSTICE_KEEPER:
		ini_inv(JusticeKeeper);

		skill_init(Skill_Jus);
		break;

	case PM_BLOODSEEKER:
		ini_inv(Bloodseeker);
		if ((rnd(10)) > 3) ini_inv(BloodseekerA);
		skill_init(Skill_Blo);
		break;

	case PM_SLAVE_MASTER:
		ini_inv(SlaveMaster);
		if ((rnd(10)) > 3) ini_inv(SlaveMasterA);
		if (!rn2(2)) ini_inv(SlaveMasterB);
		if ((rnd(100)) > 92) ini_inv(SlaveMasterC);
		skill_init(Skill_Sla);
		break;

	case PM_ACID_MAGE:
		ini_inv(Acid_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		skill_init(Skill_Aci);
		break;

	case PM_GEEK:
		Geek[G_IC].trquan = rn2(7) + 1;
		ini_inv(Geek);
		skill_init(Skill_G);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(PACK_OF_FLOPPIES);
		knows_object(POT_JOLT_COLA);
		knows_object(DIODE);
		knows_object(TRANSISTOR);
		knows_object(IC);
		break;

	case PM_GRADUATE:
		ini_inv(Graduate);
		skill_init(Skill_Gra);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case PM_SCIENTIST:
		ini_inv(Scientist);
		skill_init(Skill_Sci);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(CHEMISTRY_SET);
		knows_classX(POTION_CLASS);
		break;

	case PM_JEDI:
		ini_inv(Jedi);
		switch(rnd(9)) {
			case 1: ini_inv(RedSaber); break;
			case 2: ini_inv(BlueSaber); break;
			case 3: ini_inv(GreenSaber); break;
			case 4: ini_inv(VioletSaber); break;
			case 5: ini_inv(WhiteSaber); break;
			case 6: ini_inv(YellowSaber); break;
			case 7: ini_inv(RedDoubleSaber); break;
			case 8: ini_inv(WhiteDoubleSaber); break;
			case 9: ini_inv(MysterySaber); break;
			default: break;
		}
		if(!rn2(2)) ini_inv(Blindfold);
		skill_init(Skill_J);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case PM_SHADOW_JEDI:
		ini_inv(ShadowJedi);
		if(!rn2(2)) ini_inv(Blindfold);
		skill_init(Skill_Sdw);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case PM_HEDDERJEDI:
		ini_inv(Jedi);
		ini_inv(GreenSaber);
		ini_inv(YellowSaber);
		ini_inv(WhiteDoubleSaber);
		skill_init(Skill_Hed);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case PM_KNIGHT:
		ini_inv(Knight);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		/* give knights chess-like mobility
		 * -- idea from wooledge@skybridge.scl.cwru.edu */
		HJumping |= FROMOUTSIDE;
		skill_init(Skill_K);
		break;

	case PM_WANDKEEPER:
		ini_inv(Wandkeeper);
		knows_classX(WAND_CLASS);
		skill_init(Skill_Wan);
		break;

	case PM_FEAT_MASTER:
		ini_inv(StuntMaster);

		HJumping |= FROMOUTSIDE;
		skill_init(Skill_Stu);
		break;

	case PM_FOXHOUND_AGENT:
		ini_inv(FoxhoundAgent);

		skill_init(Skill_Fox);
		break;

	case PM_PALADIN:
		ini_inv(Paladin);

		skill_init(Skill_Pal);
		break;

	case PM_MONK:
		switch (rn2(90) / 30) {
		case 0: Monk[M_BOOK].trotyp = SPE_HEALING; break;
		case 1: Monk[M_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: Monk[M_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(Monk);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_Mon);
		break;

	case PM_HALF_BAKED:
		switch (rn2(90) / 30) {
		case 0: HalfBaked[HBA_BOOK].trotyp = SPE_HEALING; break;
		case 1: HalfBaked[HBA_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: HalfBaked[HBA_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(HalfBaked);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_Hba);
		break;

	case PM_SAIYAN:
		ini_inv(Saiyan);
		skill_init(Skill_Sai);
		break;

	case PM_PSION:
		switch (rn2(90) / 30) {
		case 0: Psion[M_BOOK].trotyp = SPE_KNOCK; break;
		case 1: Psion[M_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		case 2: Psion[M_BOOK].trotyp = SPE_CHARM_MONSTER; break;
		}
		ini_inv(Psion);
		if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(10)) ini_inv(Magicmarker);
		knows_classX(SPBOOK_CLASS);
		knows_classX(ARMOR_CLASS);
		skill_init(Skill_Psi);
		break;
	case PM_NOBLEMAN:
		if(flags.female){
			Noble[NOB_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Noble);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_Nob);
		break;
	case PM_ACTIVISTOR:
		if(flags.female){
			Activistor[ACT_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Activistor);
		skill_init(Skill_Act);
		break;
	case PM_PIRATE:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		Pirate[PIR_KNIVES].trquan = rn1(2, 2);
		if(!rn2(4)) Pirate[PIR_SNACK].trotyp = KELP_FROND;
		Pirate[PIR_SNACK].trquan += rn2(4);
		if(rn2(100)<50)	Pirate[PIR_JEWELRY].trotyp = RIN_ADORNMENT;
		if(rn2(100)<50)	Pirate[PIR_TOOL].trotyp = GRAPPLING_HOOK;
		ini_inv(Pirate);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		skill_init(Skill_Pir);
		break;
	case PM_KORSAIR:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		ini_inv(Korsair);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		skill_init(Skill_Kor);
		break;
	case PM_GLADIATOR:
		ini_inv(Gladiator);
		skill_init(Skill_Gla);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case PM_GOFF:
		ini_inv(Goff);
		skill_init(Skill_Gof);
		break;
	case PM_AMAZON:
		ini_inv(Amazon);
		skill_init(Skill_Ama);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case PM_DRUID:
		ini_inv(Druid);
		skill_init(Skill_Drd);
		break;
	case PM_ORDINATOR:
		ini_inv(Ordinator);
		skill_init(Skill_Ord);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case PM_THALMOR:
		ini_inv(Thalmor);
		skill_init(Skill_Tha);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case PM_ALTMER:
		ini_inv(Altmer);
		skill_init(Skill_Alt);
		knows_classX(SPBOOK_CLASS);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case PM_BOSMER:
		ini_inv(Bosmer);
		skill_init(Skill_Bos);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case PM_DUNMER:
		ini_inv(Dunmer);
		skill_init(Skill_Dun);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case PM_DIVER:
		ini_inv(Diver);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		skill_init(Skill_Div);
		break;
	case PM_NECROMANCER:
		switch (rnd(5)) {   
                    case 1: Necromancer[N_BOOK].trotyp = SPE_MAGIC_BOLT; break;
                    case 2: Necromancer[N_BOOK].trotyp = SPE_KNOCK; break;
                    case 3: Necromancer[N_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
                    case 4: Necromancer[N_BOOK].trotyp = SPE_CREATE_MONSTER; break;
                    case 5: Necromancer[N_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Necromancer);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		skill_init(Skill_N);
		break;
	case PM_WARRIOR:
		switch (rnd(21)) {   
                    case 1: ini_inv(WarXtrA); break;
                    case 2: ini_inv(WarXtrB); break;
                    case 3: ini_inv(WarXtrC); break;
                    case 4: ini_inv(WarXtrD); break;
                    case 5: ini_inv(WarXtrE); break;
                    case 6: ini_inv(WarXtrF); break;
                    case 7: ini_inv(WarXtrG); break;
                    case 8: ini_inv(WarXtrH); break;
                    case 9: ini_inv(WarXtrI); break;
                    case 10: ini_inv(WarXtrJ); break;
                    case 11: ini_inv(WarXtrK); break;
                    case 12: ini_inv(WarXtrL); break;
                    case 13: ini_inv(WarXtrM); break;
                    case 14: ini_inv(WarXtrN); break;
                    case 15: ini_inv(WarXtrO); break;
                    case 16: ini_inv(WarXtrP); break;
                    case 17: ini_inv(WarXtrQ); break;
                    case 18: ini_inv(WarXtrR); break;
                    case 19: ini_inv(WarXtrS); break;
                    case 20: ini_inv(WarXtrT); break;
                    case 21: ini_inv(WarXtrU); break;
		    default: break;
		}
		ini_inv(Warrior);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_War);
		break;

	case PM_DOLL_MISTRESS:
		ini_inv(DollMistress);

		skill_init(Skill_Dol);
		break;

	case PM_MAHOU_SHOUJO:
		ini_inv(MahouShoujo);

		skill_init(Skill_Mah);
		break;

	case PM_FEMINIST:
		ini_inv(Feminist);

		skill_init(Skill_Fem);
		break;

	case PM_TRACER:
		ini_inv(Tracer);

		skill_init(Skill_Trc);
		break;

	case PM_NUCLEAR_PHYSICIST:
		ini_inv(NuclearPhysicist);

		skill_init(Skill_Nuc);
		break;

	case PM_FORM_CHANGER:
		ini_inv(FormChanger);

		skill_init(Skill_For);
		break;

	case PM_GANG_SCHOLAR:

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_WEAPON].trotyp = DAGGER; break;
		    case 2: GangScholar[GSC_WEAPON].trotyp = MACE; break;
		    case 3: GangScholar[GSC_WEAPON].trotyp = MORNING_STAR; break;
		    case 4: GangScholar[GSC_WEAPON].trotyp = SHORT_SWORD; break;
		    case 5: GangScholar[GSC_WEAPON].trotyp = FLAIL; break;
		    case 6: GangScholar[GSC_WEAPON].trotyp = TWO_HANDED_SWORD; break;
		    case 7: GangScholar[GSC_WEAPON].trotyp = SPEAR; break;
		    case 8: GangScholar[GSC_WEAPON].trotyp = QUARTERSTAFF; break;
		    case 9: GangScholar[GSC_WEAPON].trotyp = LONG_SWORD; break;
		    case 10: GangScholar[GSC_WEAPON].trotyp = BROADSWORD; break;
		    case 11: GangScholar[GSC_WEAPON].trotyp = CLUB; break;
		    default: break;
		}

		switch (rnd(9)) {
		    case 1: GangScholar[GSC_ARMOR].trotyp = LEATHER_ARMOR; break;
		    case 2: GangScholar[GSC_ARMOR].trotyp = YELLOW_DRAGON_SCALES; break;
		    case 3: GangScholar[GSC_ARMOR].trotyp = RING_MAIL; break;
		    case 4: GangScholar[GSC_ARMOR].trotyp = SCALE_MAIL; break;
		    case 5: GangScholar[GSC_ARMOR].trotyp = CHAIN_MAIL; break;
		    case 6: GangScholar[GSC_ARMOR].trotyp = SPLINT_MAIL; break;
		    case 7: GangScholar[GSC_ARMOR].trotyp = PLATE_MAIL; break;
		    case 8: GangScholar[GSC_ARMOR].trotyp = STUDDED_LEATHER_ARMOR; break;
		    case 9: GangScholar[GSC_ARMOR].trotyp = ELVEN_MITHRIL_COAT; break;
		}

		switch (rnd(8)) {
		    case 1: GangScholar[GSC_RING].trotyp = RIN_ADORNMENT; break;
		    case 2: GangScholar[GSC_RING].trotyp = RIN_PROTECTION; break;
		    case 3: GangScholar[GSC_RING].trotyp = RIN_GAIN_CONSTITUTION; break;
		    case 4: GangScholar[GSC_RING].trotyp = RIN_GAIN_DEXTERITY; break;
		    case 5: GangScholar[GSC_RING].trotyp = RIN_GAIN_INTELLIGENCE; break;
		    case 6: GangScholar[GSC_RING].trotyp = RIN_GAIN_STRENGTH; break;
		    case 7: GangScholar[GSC_RING].trotyp = RIN_INCREASE_ACCURACY; break;
		    case 8: GangScholar[GSC_RING].trotyp = RIN_INCREASE_DAMAGE; break;
		}

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_POTION].trotyp = POT_HEALING; break;
		    case 2: GangScholar[GSC_POTION].trotyp = POT_EXTRA_HEALING; break;
		    case 3: GangScholar[GSC_POTION].trotyp = POT_GAIN_ENERGY; break;
		    case 4: GangScholar[GSC_POTION].trotyp = POT_BANISHING_FEAR; break;
		    case 5: GangScholar[GSC_POTION].trotyp = POT_MONSTER_DETECTION; break;
		    case 6: GangScholar[GSC_POTION].trotyp = POT_OBJECT_DETECTION; break;
		    case 7: GangScholar[GSC_POTION].trotyp = POT_LEVITATION; break;
		    case 8: GangScholar[GSC_POTION].trotyp = POT_SPEED; break;
		    case 9: GangScholar[GSC_POTION].trotyp = POT_GAIN_ABILITY; break;
		    case 10: GangScholar[GSC_POTION].trotyp = POT_GAIN_LEVEL; break;
		    case 11: GangScholar[GSC_POTION].trotyp = POT_WATER; break;
		}

		switch (rnd(13)) {
		    case 1: GangScholar[GSC_SCROLL].trotyp = SCR_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_SCROLL].trotyp = SCR_SUMMON_UNDEAD; break;
		    case 3: GangScholar[GSC_SCROLL].trotyp = SCR_LIGHT; break;
		    case 4: GangScholar[GSC_SCROLL].trotyp = SCR_IDENTIFY; break;
		    case 5: GangScholar[GSC_SCROLL].trotyp = SCR_MAGIC_MAPPING; break;
		    case 6: GangScholar[GSC_SCROLL].trotyp = SCR_REMOVE_CURSE; break;
		    case 7: GangScholar[GSC_SCROLL].trotyp = SCR_TELEPORTATION; break;
		    case 8: GangScholar[GSC_SCROLL].trotyp = SCR_HEALING; break;
		    case 9: GangScholar[GSC_SCROLL].trotyp = SCR_PHASE_DOOR; break;
		    case 10: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_DETECTION; break;
		    case 11: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_CREATION; break;
		    case 12: GangScholar[GSC_SCROLL].trotyp = SCR_SLEEP; break;
		    case 13: GangScholar[GSC_SCROLL].trotyp = SCR_BLANK_PAPER; break;
		}

		switch (rnd(26)) {
		    case 1: GangScholar[GSC_WAND].trotyp = WAN_LIGHT; break;
		    case 2: GangScholar[GSC_WAND].trotyp = WAN_NOTHING; break;
		    case 3: GangScholar[GSC_WAND].trotyp = WAN_HEALING; break;
		    case 4: GangScholar[GSC_WAND].trotyp = WAN_IDENTIFY; break;
		    case 5: GangScholar[GSC_WAND].trotyp = WAN_REMOVE_CURSE; break;
		    case 6: GangScholar[GSC_WAND].trotyp = WAN_ENTRAPPING; break;
		    case 7: GangScholar[GSC_WAND].trotyp = WAN_TRAP_CREATION; break;
		    case 8: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MAPPING; break;
		    case 9: GangScholar[GSC_WAND].trotyp = WAN_DETECT_MONSTERS; break;
		    case 10: GangScholar[GSC_WAND].trotyp = WAN_OBJECTION; break;
		    case 11: GangScholar[GSC_WAND].trotyp = WAN_SLOW_MONSTER; break;
		    case 12: GangScholar[GSC_WAND].trotyp = WAN_SPEED_MONSTER; break;
		    case 13: GangScholar[GSC_WAND].trotyp = WAN_HASTE_MONSTER; break;
		    case 14: GangScholar[GSC_WAND].trotyp = WAN_CREATE_MONSTER; break;
		    case 15: GangScholar[GSC_WAND].trotyp = WAN_SUMMON_UNDEAD; break;
		    case 16: GangScholar[GSC_WAND].trotyp = WAN_POLYMORPH; break;
		    case 17: GangScholar[GSC_WAND].trotyp = WAN_TELEPORTATION; break;
		    case 18: GangScholar[GSC_WAND].trotyp = WAN_BANISHMENT; break;
		    case 19: GangScholar[GSC_WAND].trotyp = WAN_EXTRA_HEALING; break;
		    case 20: GangScholar[GSC_WAND].trotyp = WAN_FULL_HEALING; break;
		    case 21: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_WAND].trotyp = WAN_FIRE; break;
		    case 23: GangScholar[GSC_WAND].trotyp = WAN_COLD; break;
		    case 24: GangScholar[GSC_WAND].trotyp = WAN_SLEEP; break;
		    case 25: GangScholar[GSC_WAND].trotyp = WAN_LIGHTNING; break;
		    case 26: GangScholar[GSC_WAND].trotyp = WAN_FIREBALL; break;
		}

		switch (rnd(25)) {
		    case 1: GangScholar[GSC_BOOK].trotyp = SPE_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_BOOK].trotyp = SPE_HEALING; break;
		    case 3: GangScholar[GSC_BOOK].trotyp = SPE_EXTRA_HEALING; break;
		    case 4: GangScholar[GSC_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 5: GangScholar[GSC_BOOK].trotyp = SPE_CLAIRVOYANCE; break;
		    case 6: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_TREASURE; break;
		    case 8: GangScholar[GSC_BOOK].trotyp = SPE_IDENTIFY; break;
		    case 9: GangScholar[GSC_BOOK].trotyp = SPE_ENTRAPPING; break;
		    case 10: GangScholar[GSC_BOOK].trotyp = SPE_SLOW_MONSTER; break;
		    case 11: GangScholar[GSC_BOOK].trotyp = SPE_PROTECTION; break;
		    case 12: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_COLD; break;
		    case 13: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_HEAT; break;
		    case 14: GangScholar[GSC_BOOK].trotyp = SPE_INSULATE; break;
		    case 15: GangScholar[GSC_BOOK].trotyp = SPE_REMOVE_CURSE; break;
		    case 16: GangScholar[GSC_BOOK].trotyp = SPE_LEVITATION; break;
		    case 17: GangScholar[GSC_BOOK].trotyp = SPE_TELEPORT_AWAY; break;
		    case 18: GangScholar[GSC_BOOK].trotyp = SPE_POLYMORPH; break;
		    case 19: GangScholar[GSC_BOOK].trotyp = SPE_FIRE_BOLT; break;
		    case 20: GangScholar[GSC_BOOK].trotyp = SPE_PHASE_DOOR; break;
		    case 21: GangScholar[GSC_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_BOOK].trotyp = SPE_FIREBALL; break;
		    case 23: GangScholar[GSC_BOOK].trotyp = SPE_CONE_OF_COLD; break;
		    case 24: GangScholar[GSC_BOOK].trotyp = SPE_SLEEP; break;
		    case 25: GangScholar[GSC_BOOK].trotyp = SPE_LIGHTNING; break;
		}

		ini_inv(GangScholar);

		skill_init(Skill_Sco);
		break;

	case PM_PRIEST:
		switch (rnd(9)) {
		    case 1: Priest[P_BOOK].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Priest[P_BOOK].trotyp = SPE_SLEEP; break;
		    case 3: Priest[P_BOOK].trotyp = SPE_RESIST_POISON; break;
		    case 4: Priest[P_BOOK].trotyp = SPE_RESIST_SLEEP; break;
		    case 5: Priest[P_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 6: Priest[P_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: Priest[P_BOOK].trotyp = SPE_LIGHT; break;
		    case 8: Priest[P_BOOK].trotyp = SPE_KNOCK; break;
		    case 9: Priest[P_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Priest);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		spellbook_skill_raise(Skill_P, Priest[P_BOOK].trotyp);
		skill_init(Skill_P);
		/* KMH, conduct --
		 * Some may claim that this isn't agnostic, since they
		 * are literally "priests" and they have holy water.
		 * But we don't count it as such.  Purists can always
		 * avoid playing priests and/or confirm another player's
		 * role in their YAAP.
		 */
		break;
	case PM_CHEVALIER:
		ini_inv(Chevalier);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		skill_init(Skill_Che);
		break;
	case PM_RANGER:
		Ranger[RAN_TWO_ARROWS].trquan = rn1(10, 50);
		Ranger[RAN_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Ranger);
		skill_init(Skill_Ran);
		break;
	case PM_ELPH:
		Elph[ELP_TWO_ARROWS].trquan = rn1(10, 50);
		Elph[ELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Elph);
		skill_init(Skill_Elp);

	    /* Elves can recognize all elvish objects */
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);

		break;

	case PM_TWELPH:
		Twelph[TWELP_TWO_ARROWS].trquan = rn1(10, 50);
		Twelph[TWELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Twelph);
		skill_init(Skill_Elp);

	    /* Elves can recognize all elvish objects */
	    knows_object(DARK_ELVEN_SHORT_SWORD);
	    knows_object(DARK_ELVEN_ARROW);
	    knows_object(DARK_ELVEN_BOW);
	    knows_object(DARK_ELVEN_DAGGER);
	    knows_object(DARK_ELVEN_MITHRIL_COAT);

		break;

	case PM_GOLDMINER:

		ini_inv(Golddigger);
		skill_init(Skill_Gol);

		 knows_object(GNOMISH_HELM);
		 knows_object(GNOMISH_BOOTS);
		 knows_object(GNOMISH_SUIT);
		 knows_object(AKLYS);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(1000);
#else
		u.umoney0 = rnd(1000);
#endif

		break;

	case PM_RINGSEEKER:

		ini_inv(Ringseeker);
		skill_init(Skill_Rin);

		break;

	case PM_MIDGET:

		ini_inv(Midget);
		skill_init(Skill_Mid);
	    knows_object(DWARVISH_SPEAR);
	    knows_object(DWARVISH_SHORT_SWORD);
	    knows_object(DWARVISH_MATTOCK);
	    knows_object(DWARVISH_IRON_HELM);
	    knows_object(DWARVISH_MITHRIL_COAT);
	    knows_object(DWARVISH_CLOAK);
	    knows_object(DWARVISH_ROUNDSHIELD);

		break;

	case PM_SHAPESHIFTER:

		ini_inv(Shapeshifter);
		skill_init(Skill_Sha);

		break;

	case PM_TRANSVESTITE:
		ini_inv(Transvestite);
		skill_init(Skill_Tra);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case PM_PROSTITUTE:
		ini_inv(Prostitute);
		if(!rn2(10)) ini_inv(Condome);
		skill_init(Skill_Pro);
		break;

	case PM_HUSSY:
		ini_inv(Hussy);
		skill_init(Skill_Hus);
		break;

	case PM_MASON:
		ini_inv(Mason);
		skill_init(Skill_Mas);
		break;

	case PM_ANACHRONOUNBINDER:

		switch (rnd(20)) {
		    case 1: Acu[ACUWEAPON].trotyp = DAGGER; break;
		    case 2: Acu[ACUWEAPON].trotyp = KNIFE; break;
		    case 3: Acu[ACUWEAPON].trotyp = AXE; break;
		    case 4: Acu[ACUWEAPON].trotyp = SHORT_SWORD; break;
		    case 5: Acu[ACUWEAPON].trotyp = PAPER_SWORD; break;
		    case 6: Acu[ACUWEAPON].trotyp = SUGUHANOKEN; break;
		    case 7: Acu[ACUWEAPON].trotyp = SCIMITAR; break;
		    case 8: Acu[ACUWEAPON].trotyp = RAPIER; break;
		    case 9: Acu[ACUWEAPON].trotyp = CLUB; break;
		    case 10: Acu[ACUWEAPON].trotyp = FLY_SWATTER; break;
		    case 11: Acu[ACUWEAPON].trotyp = MACE; break;
		    case 12: Acu[ACUWEAPON].trotyp = MORNING_STAR; break;
		    case 13: Acu[ACUWEAPON].trotyp = FLAIL; break;
		    case 14: Acu[ACUWEAPON].trotyp = WAR_HAMMER; break;
		    case 15: Acu[ACUWEAPON].trotyp = SICKLE; break;
		    case 16: Acu[ACUWEAPON].trotyp = SPEAR; break;
		    case 17: Acu[ACUWEAPON].trotyp = JAVELIN; break;
		    case 18: Acu[ACUWEAPON].trotyp = TRIDENT; break;
		    case 19: Acu[ACUWEAPON].trotyp = LANCE; break;
		    case 20: Acu[ACUWEAPON].trotyp = BULLWHIP; break;
		}

		ini_inv(Acu);
		skill_init(Skill_Acu);
		break;

	case PM_KURWA:
		ini_inv(Kurwa);
		skill_init(Skill_Kur);
		break;

	case PM_SOFTWARE_ENGINEER:
		ini_inv(SoftwareEngineer);
		skill_init(Skill_Sof);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(200);
#else
		u.umoney0 = rnd(200);
#endif

		break;

	case PM_CRACKER:
		ini_inv(Cracker);
		skill_init(Skill_Cra);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case PM_JANITOR:
		ini_inv(Janitor);
		skill_init(Skill_Jan);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case PM_SPACE_MARINE:
		ini_inv(SpaceMarine);
		skill_init(Skill_Sma);
		break;

	case PM_STORMBOY:
		ini_inv(Stormboy);
		skill_init(Skill_Sto);
		break;

	case PM_YAUTJA:
		ini_inv(Yautja);
		skill_init(Skill_Yau);
		break;

	case PM_JOCKEY:
		ini_inv(Jockey);
		skill_init(Skill_Joc);
		break;

	case PM_QUARTERBACK:
		ini_inv(Quarterback);
		skill_init(Skill_Qua);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		break;

	case PM_PSYKER:
		ini_inv(Psyker);
		skill_init(Skill_Psy);
		break;

	case PM_EMPATH:
		ini_inv(Empath);
		skill_init(Skill_Emp);
		break;

	case PM_MASTERMIND:
		ini_inv(Mastermind);
		skill_init(Skill_Mam);
		break;

	case PM_WEIRDBOY:
		ini_inv(Weirdboy);
		skill_init(Skill_Wei);
		break;

	case PM_ASTRONAUT:
		ini_inv(Astronaut);
		skill_init(Skill_Ast);
		break;

	case PM_CYBERNINJA:
		ini_inv(Cyberninja);
		skill_init(Skill_Cyb);
		break;

	case PM_DISSIDENT:
		ini_inv(Dissident);
		skill_init(Skill_Dis);
		break;

	case PM_XELNAGA:
		ini_inv(XelNaga);
		skill_init(Skill_Xel);
		break;

	case PM_TRANSSYLVANIAN:
		ini_inv(Transsylvanian);
		skill_init(Skill_Trs);
		break;

	case PM_UNBELIEVER:
		ini_inv(Unbeliever);
		skill_init(Skill_Unb);
		break;

	case PM_TOPMODEL:
		ini_inv(Topmodel);
		skill_init(Skill_Top);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;
	case PM_FAILED_EXISTENCE:
		ini_inv(Failed_Existence);
		skill_init(Skill_Fai);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;

	case PM_BULLY:
		ini_inv(Bully);

		if (rn2(5)) ini_inv(BullyA);
		if (rn2(2)) ini_inv(BullyB);
		if (!rn2(20)) ini_inv(Candle);
		if (!rn2(20)) ini_inv(BullyD);
		if (!rn2(20)) ini_inv(BullyE);
		skill_init(Skill_Bul);

		break;

	case PM_PICKPOCKET:

		ini_inv(Pickpocket);
		skill_init(Skill_Pic);
		knows_classX(GEM_CLASS);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 200;
#else
		u.umoney0 = 200;
#endif

		break;

	case PM_ROGUE:
		Rogue[R_DAGGERS].trquan = rn1(10, 6);
		Rogue[R_DARTS].trquan = rn1(10, 25);
		if (rn2(100) < 30) {
			Rogue[R_DAGGERS].trotyp = PISTOL;
			Rogue[R_DAGGERS].trquan = 1;
			Rogue[R_DARTS].trotyp = PISTOL_BULLET;
		}
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500 ,1500);
#else
		u.umoney0 = rn1(500 ,1500);
#endif
		ini_inv(Rogue);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_object(OILSKIN_SACK);
		skill_init(Skill_R);
		break;

	case PM_ASSASSIN:

		if (!rn2(20)) ini_inv(InvisibilityRing);
		ini_inv(Assassin);
		skill_init(Skill_Ass);
		break;

	case PM_NINJA:
		knows_class(WEAPON_CLASS);
		ini_inv(Ninja);
		skill_init(Skill_Nin);
		break;

	case PM_DRUNK:
		ini_inv(Drunk);
		skill_init(Skill_Dru);
		break;

	case PM_OFFICER:
		ini_inv(Officer);
		skill_init(Skill_Off);
		break;

	case PM_UNDERTAKER:
		ini_inv(Undertaker);
		skill_init(Skill_Unt);
		break;

	case PM_MUSICIAN:
		ini_inv(Musician);
		skill_init(Skill_Mus);
		break;

	case PM_ZOOKEEPER:
		ini_inv(Zookeeper);
		skill_init(Skill_Zoo);
		break;

	case PM_CLIMACTERIAL:
		ini_inv(Climacterial);
		skill_init(Skill_Cli);
		break;

	case PM_WOMANIZER:
		Womanizer[WOMGEM].trotyp = rnd_class(ELIF_S_JEWEL, DORA_S_JEWEL);
		ini_inv(Womanizer);
		skill_init(Skill_Wom);
		break;

	case PM_FIREFIGHTER:
		ini_inv(Firefighter);
		skill_init(Skill_Fir);
		break;

	case PM_LOCKSMITH:
		ini_inv(Locksmith);
		skill_init(Skill_Loc);
		break;

	case PM_GRENADONIN:
		ini_inv(Grenadonin);
		skill_init(Skill_Gre);
		break;

	case PM_DEMAGOGUE:
		ini_inv(Demagogue);
		skill_init(Skill_Dem);
		break;

	case PM_WALSCHOLAR:
		ini_inv(Walscholar);
		skill_init(Skill_Wal);
		break;

	case PM_SINGSLAVE:
		ini_inv(Singslave);
		skill_init(Skill_Sin);
		break;

	case PM_SOCIAL_JUSTICE_WARRIOR:
		ini_inv(SocialJusticeWarrior);
		skill_init(Skill_Soc);
		break;

	case PM_CELLAR_CHILD:
		ini_inv(CellarChild);
		skill_init(Skill_Cel);
		break;

	case PM_SAMURAI:
		Samurai[S_ARROWS].trquan = rn1(20, 26);
		ini_inv(Samurai);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_S);
		break;

	case PM_OTAKU:
		ini_inv(Otaku);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(500);
#else
		u.umoney0 = rnd(500);
#endif

		skill_init(Skill_Ota);
		break;

	case PM_TOURIST:
		Tourist[T_DARTS].trquan = rn1(20, 21);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500,1000);
#else
		u.umoney0 = rn1(500,1000);
#endif
		ini_inv(Tourist);
		if(!rn2(25)) ini_inv(Tinopener);
		else if(!rn2(25)) ini_inv(Leash);
		else if(!rn2(25)) ini_inv(Towel);
		else if(!rn2(25)) ini_inv(Magicmarker);
		skill_init(Skill_T);
		break;

	case PM_CARTOMANCER:
		ini_inv(Cartomancer);
		skill_init(Skill_Car);
		break;

	case PM_DRAGONMASTER:
		ini_inv(Dragonmaster);
		skill_init(Skill_Dra);
		break;

	case PM_COMBATANT:
		ini_inv(Combatant);
		skill_init(Skill_Com);
		break;

	case PM_FJORDE:
		ini_inv(Fjorde);
		skill_init(Skill_Fjo);
		break;

	case PM_PRACTICANT:
		ini_inv(Practicant);
		skill_init(Skill_Pra);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case PM_EMERA:
		Emera[EMERA_FLINT].trquan = 50 + rnd(50);
		ini_inv(Emera);
		skill_init(Skill_Eme);
		break;

	case PM_TOSSER:
		ini_inv(Tosser);
		skill_init(Skill_Tos);
		break;

	case PM_AKLYST:
		ini_inv(Aklyst);
		skill_init(Skill_Akl);
		break;

	case PM_MILL_SWALLOWER:
		MillSwallower[MS_BOLTS].trquan = 20 + rnd(40);
		ini_inv(MillSwallower);
		skill_init(Skill_Mil);
		break;

	case PM_SYMBIANT:
		ini_inv(Symbiant);
		skill_init(Skill_Sym);
		break;

	case PM_GENDERSTARIST:
		ini_inv(Genderstarist);
		skill_init(Skill_Gen);
		break;

	case PM_BUTT_LOVER:
		ini_inv(ButtLover);
		skill_init(Skill_But);
		break;

	case PM_DANCER:
		ini_inv(Dancer);
		skill_init(Skill_Dan);
		break;

	case PM_DIABLIST:
		ini_inv(Diablist);
		skill_init(Skill_Dia);
		break;

	case PM_PREVERSIONER:
		ini_inv(Preversioner);
		skill_init(Skill_Pre);
		break;

	case PM_SECRET_ADVICE_MEMBER:
		ini_inv(SecretAdviceMember);
		skill_init(Skill_Sec);
		break;

	case PM_SHOE_FETISHIST:
		ini_inv(ShoeFetishist);
		skill_init(Skill_Sho);
		break;

	case PM_UNDEAD_SLAYER:
		switch (rn2(100) / 25) {
		    case 0:	/* Pistol and silver bullets */
			UndeadSlayer[U_MINOR].trotyp = PISTOL;
			UndeadSlayer[U_RANGE].trotyp = SILVER_PISTOL_BULLET;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			break;
		    case 1:	/* Crossbow and bolts */
			UndeadSlayer[U_MINOR].trotyp = CROSSBOW;
			UndeadSlayer[U_RANGE].trotyp = CROSSBOW_BOLT;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			UndeadSlayer[U_MISC].trotyp = LOW_BOOTS;
			UndeadSlayer[U_MISC].trspe = 1;
			UndeadSlayer[U_ARMOR].trotyp = LEATHER_JACKET;
			UndeadSlayer[U_ARMOR].trspe = 1;
			/* helmet & armour are no longer candidates for
			 * substitution for orcish versions so no extra
			 * food should be given in compensation.
			 */
			if (Race_if(PM_ORC))
			    no_extra_food = TRUE;
		        break;
		    case 2:	/* Whip and daggers */
		        UndeadSlayer[U_MINOR].trotyp = BULLWHIP;
		        UndeadSlayer[U_MINOR].trspe = 2;
		        break;
		    case 3:	/* Silver spear and daggers */
			break;
		}
		ini_inv(UndeadSlayer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		if(!rn2(6)) ini_inv(Lamp);
		skill_init(Skill_U);
		break;
	case PM_VALKYRIE:
		ini_inv(Valkyrie);
		if(!rn2(6)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_V);
		break;
	case PM_VANILLA_VALK:
		ini_inv(VanillaValk);
		if(!rn2(6)) ini_inv(Lamp);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_Van);
		break;
	case PM_WIZARD:
		switch (rnd(2)) {                
		    case 1: Wizard[W_BOOK1].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Wizard[W_BOOK1].trotyp = SPE_SLEEP; break;
		    default: break;
		}
		switch (rnd(2)) {
		    case 1: Wizard[W_BOOK2].trotyp = SPE_RESIST_POISON; break;
		    case 2: Wizard[W_BOOK2].trotyp = SPE_RESIST_SLEEP; break;
		    default: break;
		}
		switch (rnd(5)) {   
		    case 1: Wizard[W_BOOK3].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Wizard[W_BOOK3].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Wizard[W_BOOK3].trotyp = SPE_LIGHT; break;
		    case 4: Wizard[W_BOOK3].trotyp = SPE_KNOCK; break;
		    case 5: Wizard[W_BOOK3].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		switch (rnd(9)) {
		    case 1: Wizard[W_BOOK4].trotyp = SPE_MAGIC_MISSILE; break;
		    case 2: Wizard[W_BOOK4].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Wizard[W_BOOK4].trotyp = SPE_SLOW_MONSTER; break;
		    case 4: Wizard[W_BOOK4].trotyp = SPE_CURE_BLINDNESS; break;
		    case 5: Wizard[W_BOOK4].trotyp = SPE_ENDURE_HEAT; break;
		    case 6: Wizard[W_BOOK4].trotyp = SPE_ENDURE_COLD; break;
		    case 7: Wizard[W_BOOK4].trotyp = SPE_INSULATE; break;
		    case 8: Wizard[W_BOOK4].trotyp = SPE_CREATE_MONSTER; break;
		    case 9: Wizard[W_BOOK4].trotyp = SPE_HEALING; break;
		    default: break;
		}
		ini_inv(Wizard);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		skill_init(Skill_W);
		break;

	case PM_OCCULT_MASTER:

		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK1].trotyp = SPE_PREACHING; break;
		    case 2: OccultMaster[O_BOOK1].trotyp = SPE_STRANGLING; break;
		    case 3: OccultMaster[O_BOOK1].trotyp = SPE_MIMICRY; break;
		    case 4: OccultMaster[O_BOOK1].trotyp = SPE_MANA_BATTERY; break;
		    case 5: OccultMaster[O_BOOK1].trotyp = SPE_RESIST_PARALYSIS; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK2].trotyp = SPE_SPELLBINDER; break;
		    case 2: OccultMaster[O_BOOK2].trotyp = SPE_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_BOOK2].trotyp = SPE_TRACKER; break;
		    case 4: OccultMaster[O_BOOK2].trotyp = SPE_TOTEM_SUMMONING; break;
		    case 5: OccultMaster[O_BOOK2].trotyp = SPE_POSSESSION; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK3].trotyp = SPE_CODE_EDITING; break;
		    case 2: OccultMaster[O_BOOK3].trotyp = SPE_SATISFY_HUNGER; break;
		    case 3: OccultMaster[O_BOOK3].trotyp = SPE_FIRE_GOLEM; break;
		    case 4: OccultMaster[O_BOOK3].trotyp = SPE_DISRUPTION_SHIELD; break;
		    case 5: OccultMaster[O_BOOK3].trotyp = SPE_BLINDING_RAY; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK4].trotyp = SPE_COMMAND_DEMON; break;
		    case 2: OccultMaster[O_BOOK4].trotyp = SPE_REDEMPTION; break;
		    case 3: OccultMaster[O_BOOK4].trotyp = SPE_NEXUS_FIELD; break;
		    case 4: OccultMaster[O_BOOK4].trotyp = SPE_PHASE_DOOR; break;
		    case 5: OccultMaster[O_BOOK4].trotyp = SPE_HORRIFY; break;
		    default: break;
		}
		switch (rnd(3)) {                
		    case 1: OccultMaster[O_WAND].trotyp = WAN_SPELLBINDER; break;
		    case 2: OccultMaster[O_WAND].trotyp = WAN_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_WAND].trotyp = WAN_STERILIZE; break;
		    default: break;
		}

		ini_inv(OccultMaster);
		skill_init(Skill_Occ);

		break;

	case PM_ELEMENTALIST:

		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK1].trotyp = SPE_WATER_BOLT; break;
		    case 2: Elementalist[E_BOOK1].trotyp = SPE_VOLT_ROCK; break;
		    case 3: Elementalist[E_BOOK1].trotyp = SPE_WATER_FLAME; break;
		    case 4: Elementalist[E_BOOK1].trotyp = SPE_FIRE; break;
		    case 5: Elementalist[E_BOOK1].trotyp = SPE_STEAM_VENOM; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK2].trotyp = SPE_AIR_CURRENT; break;
		    case 2: Elementalist[E_BOOK2].trotyp = SPE_WIND; break;
		    case 3: Elementalist[E_BOOK2].trotyp = SPE_RAIN_CLOUD; break;
		    case 4: Elementalist[E_BOOK2].trotyp = SPE_FROST; break;
		    case 5: Elementalist[E_BOOK2].trotyp = SPE_DASHING; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK3].trotyp = SPE_POISON_BRAND; break;
		    case 2: Elementalist[E_BOOK3].trotyp = SPE_THUNDER_WAVE; break;
		    case 3: Elementalist[E_BOOK3].trotyp = SPE_ELEMENTAL_BEAM; break;
		    case 4: Elementalist[E_BOOK3].trotyp = SPE_BATTERING_RAM; break;
		    case 5: Elementalist[E_BOOK3].trotyp = SPE_POWER_FAILURE; break;
		    case 6: Elementalist[E_BOOK3].trotyp = SPE_VAPORIZE; break;
		    case 7: Elementalist[E_BOOK3].trotyp = SPE_BURROW; break;
		    case 8: Elementalist[E_BOOK3].trotyp = SPE_MELTDOWN; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK4].trotyp = SPE_CLOUDS; break;
		    case 2: Elementalist[E_BOOK4].trotyp = SPE_ICE; break;
		    case 3: Elementalist[E_BOOK4].trotyp = SPE_FLOOD; break;
		    case 4: Elementalist[E_BOOK4].trotyp = SPE_DRIPPING_TREAD; break;
		    case 5: Elementalist[E_BOOK4].trotyp = SPE_GEOLYSIS; break;
		    case 6: Elementalist[E_BOOK4].trotyp = SPE_LAVA; break;
		    case 7: Elementalist[E_BOOK4].trotyp = SPE_IRON_PRISON; break;
		    case 8: Elementalist[E_BOOK4].trotyp = SPE_LOCKOUT; break;
		    case 9: Elementalist[E_BOOK4].trotyp = SPE_GROW_TREES; break;
		    default: break;
		}
		switch (rnd(4)) {                
		    case 1: Elementalist[E_WAND].trotyp = WAN_FIRE; break;
		    case 2: Elementalist[E_WAND].trotyp = WAN_COLD; break;
		    case 3: Elementalist[E_WAND].trotyp = WAN_LIGHTNING; break;
		    case 4: Elementalist[E_WAND].trotyp = WAN_POISON; break;
		    default: break;
		}

		ini_inv(Elementalist);
		skill_init(Skill_Elm);

		break;

	case PM_CHAOS_SORCEROR:

		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK1].trotyp = SPE_LINE_LOSS; break;
		    case 2: ChaosSorceror[C_BOOK1].trotyp = SPE_PET_SYRINGE; break;
		    case 3: ChaosSorceror[C_BOOK1].trotyp = SPE_CURE_RANDOM_STATUS; break;
		    case 4: ChaosSorceror[C_BOOK1].trotyp = SPE_BERSERK; break;
		    case 5: ChaosSorceror[C_BOOK1].trotyp = SPE_RESIST_RANDOM_ELEMENT; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK2].trotyp = SPE_LOCK_MANIPULATION; break;
		    case 2: ChaosSorceror[C_BOOK2].trotyp = SPE_RANDOM_SPEED; break;
		    case 3: ChaosSorceror[C_BOOK2].trotyp = SPE_CHAOS_BOLT; break;
		    case 4: ChaosSorceror[C_BOOK2].trotyp = SPE_BUC_RANDOMIZATION; break;
		    case 5: ChaosSorceror[C_BOOK2].trotyp = SPE_RUSSIAN_ROULETTE; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK3].trotyp = SPE_LYCANTHROPY; break;
		    case 2: ChaosSorceror[C_BOOK3].trotyp = SPE_BOMBING; break;
		    case 3: ChaosSorceror[C_BOOK3].trotyp = SPE_VANISHING; break;
		    case 4: ChaosSorceror[C_BOOK3].trotyp = SPE_EARTHQUAKE; break;
		    case 5: ChaosSorceror[C_BOOK3].trotyp = SPE_POLYFORM; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK4].trotyp = SPE_SELFDESTRUCT; break;
		    case 2: ChaosSorceror[C_BOOK4].trotyp = SPE_THRONE_GAMBLE; break;
		    case 3: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION; break;
		    case 4: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION_BEAM; break;
		    case 5: ChaosSorceror[C_BOOK4].trotyp = SPE_REROLL_ARTIFACT; break;
		    default: break;
		}

		ini_inv(ChaosSorceror);
		skill_init(Skill_Cha);

		break;

	case PM_WILD_TALENT:
		ini_inv(WildTalent);
		skill_init(Skill_Wil);

		break;

	case PM_SAGE:

		ini_inv(Sage);
		if(!rn2(3)) ini_inv(Magicmarker);

		skill_init(Skill_Sag);
		break;

	case PM_YEOMAN:
		ini_inv(Yeoman);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		skill_init(Skill_Y);
		break;

	default:	/* impossible */
		break;
	}

	} /* role switch for non-randomizer */

	else { /* israndomizer */

	switch (Role_switch) {
	case PM_ARCHEOLOGIST:
		skill_init(Skill_A);
		break;

	case PM_AUGURER:
		skill_init(Skill_Aug);
		break;

	case PM_BARBARIAN:
		skill_init(Skill_B);
		break;

	case PM_NOOB_MODE_BARB:
		skill_init(Skill_Noo);
		break;

	case PM_BINDER:
		skill_init(Skill_Bin);
		break;

	case PM_POLITICIAN:
		skill_init(Skill_Pol);
		break;

	case PM_DQ_SLIME:
		skill_init(Skill_Sli);
		break;

	case PM_SPELLMASTER:
		skill_init(Skill_Spe);
		break;

	case PM_ALLTECHER:
		skill_init(Skill_All);
		break;

	case PM_ERDRICK:
		skill_init(Skill_Erd);
		break;

	case PM_BLEEDER:
		skill_init(Skill_Ble);
		break;

	case PM_LIBRARIAN:
		skill_init(Skill_Lib);
		break;

	case PM_SUPERMARKET_CASHIER:
		skill_init(Skill_Sup);
		break;

	case PM_INTEL_SCRIBE:
		skill_init(Skill_Scr);
		break;

	case PM_GAMER:
		skill_init(Skill_Gam);
		break;

	case PM_ARTIST:
		skill_init(Skill_Art);
		break;

	case PM_COOK:
		skill_init(Skill_Coo);
		break;

	case PM_BARD:
		skill_init(Skill_Bard);
		break;

	case PM_CAVEMAN:
		skill_init(Skill_C);
		break;

	case PM_GANGSTER:
		skill_init(Skill_Gan);
		break;

	case PM_GUNNER:
		skill_init(Skill_Gun);
		break;

	case PM_DOOM_MARINE:
		skill_init(Skill_Mar);
		break;

	case PM_DEATH_EATER:
		skill_init(Skill_Dea);
		break;

	case PM_POKEMON:
		skill_init(Skill_Pok);
		break;

	case PM_FLAME_MAGE:
		skill_init(Skill_F);
		break;

	case PM_COURIER:
            skill_init(Skill_Cou);
		break;

	case PM_SPACEWARS_FIGHTER:
	      skill_init(Skill_Spa);
		break;

	case PM_CAMPERSTRIKER:
	      skill_init(Skill_Cam);
		break;

	case PM_GANG_SCHOLAR:
	      skill_init(Skill_Sco);
		break;

	case PM_FORM_CHANGER:
	      skill_init(Skill_For);
		break;

	case PM_NUCLEAR_PHYSICIST:
	      skill_init(Skill_Nuc);
		break;

	case PM_FEMINIST:
	      skill_init(Skill_Fem);
		break;

	case PM_TRACER:
	      skill_init(Skill_Trc);
		break;

	case PM_ROCKER:
            skill_init(Skill_Roc);
		break;

	case PM_ZYBORG:
            skill_init(Skill_Zyb);
		break;

	case PM_LUNATIC:
            skill_init(Skill_Lun);
		break;

	case PM_CONVICT:
            skill_init(Skill_Con);
            break;

	case PM_MURDERER:
            skill_init(Skill_Mur);
            break;

	case PM_GRENADONIN:
            skill_init(Skill_Gre);
            break;

	case PM_WALSCHOLAR:
            skill_init(Skill_Wal);
            break;

	case PM_SINGSLAVE:
            skill_init(Skill_Sin);
            break;

	case PM_SOCIAL_JUSTICE_WARRIOR:
            skill_init(Skill_Soc);
            break;

	case PM_DEMAGOGUE:
            skill_init(Skill_Dem);
            break;

	case PM_CELLAR_CHILD:
            skill_init(Skill_Cel);
            break;

	case PM_HEALER:
		skill_init(Skill_H);
		break;

	case PM_ICE_MAGE:
		skill_init(Skill_I);
		break;

	case PM_ELECTRIC_MAGE:
		skill_init(Skill_Ele);
		break;

	case PM_POISON_MAGE:
		skill_init(Skill_Poi);
		break;

	case PM_CRUEL_ABUSER:
		skill_init(Skill_Abu);
		break;

	case PM_MYSTIC:
		skill_init(Skill_Mys);
		break;

	case PM_JESTER:
		skill_init(Skill_Jes);
		break;

	case PM_LADIESMAN:
		skill_init(Skill_Lad);
		break;

	case PM_FIGHTER:

		skill_init(Skill_Fig);
		break;

	case PM_FENCER:

		skill_init(Skill_Fen);
		break;

	case PM_MEDIUM:

		skill_init(Skill_Med);
		break;

	case PM_SEXYMATE:

		skill_init(Skill_Sex);
		break;

	case PM_STAND_USER:

		skill_init(Skill_Sta);
		break;

	case PM_JUSTICE_KEEPER:

		skill_init(Skill_Jus);
		break;

	case PM_BLOODSEEKER:
		skill_init(Skill_Blo);
		break;

	case PM_SLAVE_MASTER:
		skill_init(Skill_Sla);
		break;

	case PM_ACID_MAGE:
		skill_init(Skill_Aci);
		break;

	case PM_GEEK:
		skill_init(Skill_G);
		break;

	case PM_GRADUATE:
		skill_init(Skill_Gra);
		break;

	case PM_SCIENTIST:
		skill_init(Skill_Sci);
		break;

	case PM_JEDI:
		skill_init(Skill_J);
		break;
	case PM_SHADOW_JEDI:
		skill_init(Skill_Sdw);
		break;
	case PM_HEDDERJEDI:
		skill_init(Skill_Hed);
		break;
	case PM_KNIGHT:
		skill_init(Skill_K);
		break;

	case PM_WANDKEEPER:
		skill_init(Skill_Wan);
		break;

	case PM_FEAT_MASTER:
		skill_init(Skill_Stu);
		break;

	case PM_FOXHOUND_AGENT:
		skill_init(Skill_Fox);
		break;

	case PM_PALADIN:
		skill_init(Skill_Pal);
		break;

	case PM_MONK:
		skill_init(Skill_Mon);
		break;

	case PM_HALF_BAKED:
		skill_init(Skill_Hba);
		break;

	case PM_SAIYAN:
		skill_init(Skill_Sai);
		break;

	case PM_PSION:
		skill_init(Skill_Psi);
		break;

	case PM_NOBLEMAN:
		skill_init(Skill_Nob);
		break;

	case PM_ACTIVISTOR:
		skill_init(Skill_Act);
		break;

	case PM_PIRATE:
		skill_init(Skill_Pir);
		break;

	case PM_KORSAIR:
		skill_init(Skill_Kor);
		break;

	case PM_GLADIATOR:
		skill_init(Skill_Gla);
		break;

	case PM_GOFF:
		skill_init(Skill_Gof);
		break;

	case PM_AMAZON:
		skill_init(Skill_Ama);
		break;

	case PM_DRUID:
		skill_init(Skill_Drd);
		break;

	case PM_ORDINATOR:
		skill_init(Skill_Ord);
		break;

	case PM_THALMOR:
		skill_init(Skill_Tha);
		break;

	case PM_ALTMER:
		skill_init(Skill_Alt);
		break;

	case PM_BOSMER:
		skill_init(Skill_Bos);
		break;

	case PM_DUNMER:
		skill_init(Skill_Dun);
		break;

	case PM_DIVER:
		skill_init(Skill_Div);
		break;

	case PM_NECROMANCER:
		skill_init(Skill_N);
		break;

	case PM_WARRIOR:
		skill_init(Skill_War);
		break;

	case PM_DOLL_MISTRESS:
		skill_init(Skill_Dol);
		break;

	case PM_MAHOU_SHOUJO:
		skill_init(Skill_Mah);
		break;

	case PM_PRIEST:
		skill_init(Skill_P);
		break;

	case PM_CHEVALIER:
		skill_init(Skill_Che);
		break;

	case PM_RANGER:
		skill_init(Skill_Ran);
		break;

	case PM_ELPH:
		skill_init(Skill_Elp);
		break;

	case PM_GOLDMINER:
		skill_init(Skill_Gol);
		break;

	case PM_RINGSEEKER:
		skill_init(Skill_Rin);
		break;

	case PM_MIDGET:
		skill_init(Skill_Mid);
		break;

	case PM_SHAPESHIFTER:
		skill_init(Skill_Sha);
		break;

	case PM_TWELPH:
		skill_init(Skill_Elp);
		break;

	case PM_TRANSVESTITE:
		skill_init(Skill_Tra);
		break;

	case PM_PROSTITUTE:
		skill_init(Skill_Pro);
		break;

	case PM_HUSSY:
		skill_init(Skill_Hus);
		break;

	case PM_MASON:
		skill_init(Skill_Mas);
		break;

	case PM_ANACHRONOUNBINDER:
		skill_init(Skill_Acu);
		break;

	case PM_KURWA:
		skill_init(Skill_Kur);
		break;

	case PM_SOFTWARE_ENGINEER:
		skill_init(Skill_Sof);
		break;

	case PM_CRACKER:
		skill_init(Skill_Cra);
		break;

	case PM_JANITOR:
		skill_init(Skill_Jan);
		break;

	case PM_SPACE_MARINE:
		skill_init(Skill_Sma);
		break;

	case PM_STORMBOY:
		skill_init(Skill_Sto);
		break;

	case PM_YAUTJA:
		skill_init(Skill_Yau);
		break;

	case PM_JOCKEY:
		skill_init(Skill_Joc);
		break;

	case PM_QUARTERBACK:
		skill_init(Skill_Qua);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		break;

	case PM_PSYKER:
		skill_init(Skill_Psy);
		break;

	case PM_EMPATH:
		skill_init(Skill_Emp);
		break;

	case PM_MASTERMIND:
		skill_init(Skill_Mam);
		break;

	case PM_WEIRDBOY:
		skill_init(Skill_Wei);
		break;

	case PM_ASTRONAUT:
		skill_init(Skill_Ast);
		break;

	case PM_CYBERNINJA:
		skill_init(Skill_Cyb);
		break;

	case PM_DISSIDENT:
		skill_init(Skill_Dis);
		break;

	case PM_XELNAGA:
		skill_init(Skill_Xel);
		break;

	case PM_TRANSSYLVANIAN:
		skill_init(Skill_Trs);
		break;

	case PM_UNBELIEVER:
		skill_init(Skill_Unb);
		break;

	case PM_TOPMODEL:
		skill_init(Skill_Top);
		break;

	case PM_FAILED_EXISTENCE:
		skill_init(Skill_Fai);
		break;

	case PM_BULLY:
		skill_init(Skill_Bul);
		break;

	case PM_PICKPOCKET:
		skill_init(Skill_Pic);
		break;

	case PM_ROGUE:
		skill_init(Skill_R);
		break;

	case PM_ASSASSIN:
		skill_init(Skill_Ass);
		break;

	case PM_NINJA:
		skill_init(Skill_Nin);
		break;

	case PM_DRUNK:
		skill_init(Skill_Dru);
		break;

	case PM_OFFICER:
		skill_init(Skill_Off);
		break;

	case PM_UNDERTAKER:
		skill_init(Skill_Unt);
		break;

	case PM_MUSICIAN:
		skill_init(Skill_Mus);
		break;

	case PM_ZOOKEEPER:
		skill_init(Skill_Zoo);
		break;

	case PM_FIREFIGHTER:
		skill_init(Skill_Fir);
		break;

	case PM_LOCKSMITH:
		skill_init(Skill_Loc);
		break;

	case PM_SAMURAI:
		skill_init(Skill_S);
		break;

	case PM_OTAKU:
		skill_init(Skill_Ota);
		break;

	case PM_CARTOMANCER:
		skill_init(Skill_Car);
		break;

	case PM_DRAGONMASTER:
		skill_init(Skill_Dra);
		break;

	case PM_COMBATANT:
		skill_init(Skill_Com);
		break;

	case PM_FJORDE:
		skill_init(Skill_Fjo);
		break;

	case PM_PRACTICANT:
		skill_init(Skill_Pra);
		break;

	case PM_EMERA:
		skill_init(Skill_Eme);
		break;

	case PM_TOSSER:
		skill_init(Skill_Tos);
		break;

	case PM_AKLYST:
		skill_init(Skill_Akl);
		break;

	case PM_MILL_SWALLOWER:
		skill_init(Skill_Mil);
		break;

	case PM_SYMBIANT:
		skill_init(Skill_Sym);
		break;

	case PM_GENDERSTARIST:
		skill_init(Skill_Gen);
		break;

	case PM_BUTT_LOVER:
		skill_init(Skill_But);
		break;

	case PM_DANCER:
		skill_init(Skill_Dan);
		break;

	case PM_DIABLIST:
		skill_init(Skill_Dia);
		break;

	case PM_PREVERSIONER:
		skill_init(Skill_Pre);
		break;

	case PM_SECRET_ADVICE_MEMBER:
		skill_init(Skill_Sec);
		break;

	case PM_SHOE_FETISHIST:
		skill_init(Skill_Sho);
		break;

	case PM_TOURIST:
		skill_init(Skill_T);
		break;
	case PM_UNDEAD_SLAYER:
		skill_init(Skill_U);
		break;

	case PM_VALKYRIE:
		skill_init(Skill_V);
		break;

	case PM_VANILLA_VALK:
		skill_init(Skill_Van);
		break;

	case PM_WIZARD:
		skill_init(Skill_W);
		break;

	case PM_ELEMENTALIST:
		skill_init(Skill_Elm);
		break;

	case PM_OCCULT_MASTER:
		skill_init(Skill_Occ);
		break;

	case PM_CHAOS_SORCEROR:
		skill_init(Skill_Cha);
		break;

	case PM_WILD_TALENT:
		skill_init(Skill_Wil);
		break;

	case PM_SAGE:

		skill_init(Skill_Sag);
		break;

	case PM_YEOMAN:
		skill_init(Skill_Y);
		break;

	case PM_ANACHRONIST:
		skill_init(Skill_Ana);
		break;

	case PM_CLIMACTERIAL:
		skill_init(Skill_Cli);
		break;

	case PM_WOMANIZER:
		skill_init(Skill_Wom);
		break;


	default:	/* impossible */
		pline("skill init failed %d", Role_switch);
		break;
	}

	if (!isnullrace) { /* randomizer only */

	switch (rnd(174)) {
	case 1:
		switch (rnd(5)) {   
		    case 1: Archeologist[A_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Archeologist[A_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Archeologist[A_BOOK].trotyp = SPE_LIGHT; break;
		    case 4: Archeologist[A_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Archeologist[A_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Archeologist);
		if(!rn2(4)) ini_inv(Blindfold);
		else if(!rn2(4)) ini_inv(Towel);
		if(!rn2(4)) ini_inv(Leash);
		if(!rn2(4)) ini_inv(Tinopener);
		else if(!rn2(4))
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		if(!rn2(8)) ini_inv(Magicmarker);
		knows_object(TOUCHSTONE);
		knows_object(SACK);
		break;

	case 2:
		switch (rnd(5)) {   
		    case 1: Augurer[AUG_BOOK].trotyp = SPE_CAUSE_FEAR; break;
		    case 2: Augurer[AUG_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Augurer[AUG_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 4: Augurer[AUG_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Augurer[AUG_BOOK].trotyp = (!rn2(3) ? SPE_SLEEP : !rn2(2) ? SPE_IDENTIFY : SPE_MAGIC_MAPPING); break;
		    default: break;
		}
		ini_inv(Augurer);
		if(!rn2(4)) ini_inv(Candle);
		else if(!rn2(4)) ini_inv(Touchstone);
		else if(!rn2(4)) ini_inv(Magicmarker);

		break;

	case 3:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    Barbarian[B_MAJOR].trotyp = BATTLE_AXE;
		    Barbarian[B_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(Barbarian);
		if(!rn2(6)) ini_inv(Torch);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 4:
		ini_inv(Binder);
	  increasesincounter(16); /*One transgression is all it takes*/
	  u.alignlim -= 16;
	    change_luck(-1); /*One resurection or two rehumanizations is all it takes*/
		break;

	case 5:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = (3000 + rnd(2000));
#else
		u.umoney0 = (3000 + rnd(2000));
#endif
		ini_inv(Politician);
		break;

	case 6:
		ini_inv(Bleeder);
		break;
	case 7:
		ini_inv(Librarian);
		break;
	case 8:

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 500;
#else
		u.umoney0 = 500;
#endif

		ini_inv(Supermarket);
		if ((rnd(5)) > 2) ini_inv(SupermarketB);
		if (!rn2(5)) ini_inv(SupermarketA);
		break;
	case 9:
		ini_inv(Scribe);
		break;
	case 10:
		ini_inv(Gamer);
		break;
	case 11:
		ini_inv(Artist);
		break;
	case 12:
		ini_inv(Cook);
		break;
	case 13:
		if (rn2(100) >= 50) Bard[BARD_INSTR].trotyp = WOODEN_FLUTE;
		if (rn2(100) >= 85) Bard[BARD_WHISTLE].trotyp = BELL;
		Bard[BARD_BOOZE].trquan = rn1(2, 5);
		ini_inv(Bard);
		/* This depends on the order in objects.c */
		for (i = TIN_WHISTLE; i <= DRUM_OF_EARTHQUAKE; i++)
			knows_object(i);
		/* Bards know about the enchantment spellbooks, though they don't know
		   the spells */
		knows_object(SPE_SLEEP);
		knows_object(SPE_CONFUSE_MONSTER);
		knows_object(SPE_SLOW_MONSTER);
		knows_object(SPE_CAUSE_FEAR);
		knows_object(SPE_CHARM_MONSTER);
		/* Bards also know a lot about legendary & magical stuff. */
		know_random_obj();
		break;
	case 14:
		u.nv_range = 2;
		Cave_man[C_AMMO].trquan = rn1(11, 10);	/* 10..20 */
		ini_inv(Cave_man);
		break;
	case 15:
		ini_inv(Gangster);
		break;
	case 16:
		ini_inv(Gunner);
		break;
	case 17:
		ini_inv(Death_Eater);
		break;
	case 18:
		ini_inv(Pokemon);
		break;
	case 19:
		switch (rnd(2)) {                
			case 1: Flame_Mage[F_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
			case 2: Flame_Mage[F_BOOK].trotyp = SPE_LIGHT; break;
			default: break;
		}
		ini_inv(Flame_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;
	case 20:
        ini_inv(Courier);
		break;

	case 21:
        ini_inv(Spacewars_Fighter);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 1500;
#else
		u.umoney0 = 1500;
#endif
		break;

	case 22:
        ini_inv(Rocker);
		break;

	case 23:
        ini_inv(Zyborg);
		break;

	case 24:
        ini_inv(Lunatic);

		if (!Race_if(PM_AK_THIEF_IS_DEAD_)) {
		switch (rnd(7)) {
		case 1: 	    u.ulycn = PM_WEREWOLF; break;
		case 2: 	    u.ulycn = PM_WEREJACKAL; break;
		case 3: 	    u.ulycn = PM_WERERAT; break;
		case 4: 	    u.ulycn = PM_WEREPANTHER; break;
		case 5: 	    u.ulycn = PM_WERETIGER; break;
		case 6: 	    u.ulycn = PM_WERESNAKE; break;
		case 7: 	    u.ulycn = PM_WERESPIDER; break;
		default: 	    u.ulycn = PM_WEREWOLF; break;

		}
		}

		break;

	case 25:
        ini_inv(Convict);
        knows_object(SKELETON_KEY);
        knows_object(GRAPPLING_HOOK);
	  increasesincounter(16); /* You have sinned */
	  u.alignlim -= 16;
        u.uhunger = 550;  /* On the verge of hungry */
    	/* u.ualignbase[A_CURRENT] = u.ualignbase[A_ORIGINAL] =
        u.ualign.type = A_CHAOTIC; Override racial alignment */
        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
        urace.lovemask = 0; /* Convicts are pariahs of their race */
	    change_luck(-1); /* both their alignment and luck start out negative */
        break;
	case 26:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(1000, 1001);
#else
		u.umoney0 = rn1(1000, 1001);
#endif
		ini_inv(Healer);
		knows_classX(POTION_CLASS); /* WAC - remove? */ /* edit by Amy - nope, but change to include magic ones */
		knows_object(POT_SICKNESS);
		knows_object(POT_BLINDNESS);
		knows_object(POT_HALLUCINATION);
		knows_object(POT_RESTORE_ABILITY);
		knows_object(POT_FULL_HEALING);
		knows_object(HEALTHSTONE);	/* KMH */
		if(!rn2(5)) ini_inv(Lamp);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;
	case 27:
		switch (rnd(2)) {                
			case 1: Ice_Mage[I_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
			case 2: Ice_Mage[I_BOOK].trotyp = SPE_SLOW_MONSTER; break;
			default: break;
		}
		ini_inv(Ice_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 28:
		ini_inv(Electric_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 29:
		ini_inv(Abuser);
		break;

	case 30:
		ini_inv(Mystic);
		break;

	case 31:
		ini_inv(Jester);
		break;

	case 32:
		ini_inv(Ladiesman);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 300;
#else
		u.umoney0 = 300;
#endif
		break;

	case 33:
		ini_inv(Bloodseeker);
		if ((rnd(10)) > 3) ini_inv(BloodseekerA);
		break;

	case 34:
		ini_inv(SlaveMaster);
		if ((rnd(10)) > 3) ini_inv(SlaveMasterA);
		if (!rn2(2)) ini_inv(SlaveMasterB);
		if ((rnd(100)) > 92) ini_inv(SlaveMasterC);
		break;

	case 35:
		ini_inv(Acid_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 36:
		Geek[G_IC].trquan = rn2(7) + 1;
		ini_inv(Geek);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(PACK_OF_FLOPPIES);
		knows_object(POT_JOLT_COLA);
		knows_object(DIODE);
		knows_object(TRANSISTOR);
		knows_object(IC);
		break;

	case 37:
		ini_inv(Graduate);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 38:
		ini_inv(Scientist);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(CHEMISTRY_SET);
		knows_classX(POTION_CLASS);
		break;

	case 39:
		ini_inv(Jedi);
		switch(rnd(9)) {
			case 1: ini_inv(RedSaber); break;
			case 2: ini_inv(BlueSaber); break;
			case 3: ini_inv(GreenSaber); break;
			case 4: ini_inv(VioletSaber); break;
			case 5: ini_inv(WhiteSaber); break;
			case 6: ini_inv(YellowSaber); break;
			case 7: ini_inv(RedDoubleSaber); break;
			case 8: ini_inv(WhiteDoubleSaber); break;
			case 9: ini_inv(MysterySaber); break;
			default: break;
		}
		if(!rn2(2)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 40:
		ini_inv(Knight);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		/* give knights chess-like mobility
		 * -- idea from wooledge@skybridge.scl.cwru.edu */
		HJumping |= FROMOUTSIDE;
		break;

	case 41:
		ini_inv(Wandkeeper);
		knows_classX(WAND_CLASS);
		break;

	case 42:
		ini_inv(StuntMaster);

		HJumping |= FROMOUTSIDE;
		break;

	case 43:
		ini_inv(FoxhoundAgent);

		break;

	case 44:
		ini_inv(Paladin);

		break;

	case 45:
		switch (rn2(90) / 30) {
		case 0: Monk[M_BOOK].trotyp = SPE_HEALING; break;
		case 1: Monk[M_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: Monk[M_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(Monk);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		break;
	case 46:
		ini_inv(Saiyan);
		break;

	case 47:
		switch (rn2(90) / 30) {
		case 0: Psion[M_BOOK].trotyp = SPE_KNOCK; break;
		case 1: Psion[M_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		case 2: Psion[M_BOOK].trotyp = SPE_CHARM_MONSTER; break;
		}
		ini_inv(Psion);
		if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(10)) ini_inv(Magicmarker);
		knows_classX(SPBOOK_CLASS);
		knows_classX(ARMOR_CLASS);
		break;
	case 48:
		if(flags.female){
			Noble[NOB_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Noble);
		knows_class(ARMOR_CLASS);
		break;
	case 49:
		if(flags.female){
			Activistor[ACT_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Activistor);
		break;
	case 50:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		Pirate[PIR_KNIVES].trquan = rn1(2, 2);
		if(!rn2(4)) Pirate[PIR_SNACK].trotyp = KELP_FROND;
		Pirate[PIR_SNACK].trquan += rn2(4);
		if(rn2(100)<50)	Pirate[PIR_JEWELRY].trotyp = RIN_ADORNMENT;
		if(rn2(100)<50)	Pirate[PIR_TOOL].trotyp = GRAPPLING_HOOK;
		ini_inv(Pirate);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 51:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		ini_inv(Korsair);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 52:
		ini_inv(Gladiator);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 53:
		ini_inv(Goff);
		break;
	case 54:
		ini_inv(Amazon);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 55:
		ini_inv(Ordinator);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 56:
		ini_inv(Thalmor);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 57:
		ini_inv(Altmer);
		knows_classX(SPBOOK_CLASS);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 58:
		ini_inv(Bosmer);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 59:
		ini_inv(Dunmer);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 60:
		ini_inv(Diver);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 61:
		switch (rnd(5)) {   
                    case 1: Necromancer[N_BOOK].trotyp = SPE_MAGIC_BOLT; break;
                    case 2: Necromancer[N_BOOK].trotyp = SPE_KNOCK; break;
                    case 3: Necromancer[N_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
                    case 4: Necromancer[N_BOOK].trotyp = SPE_CREATE_MONSTER; break;
                    case 5: Necromancer[N_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Necromancer);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;
	case 62:
		switch (rnd(21)) {   
                    case 1: ini_inv(WarXtrA); break;
                    case 2: ini_inv(WarXtrB); break;
                    case 3: ini_inv(WarXtrC); break;
                    case 4: ini_inv(WarXtrD); break;
                    case 5: ini_inv(WarXtrE); break;
                    case 6: ini_inv(WarXtrF); break;
                    case 7: ini_inv(WarXtrG); break;
                    case 8: ini_inv(WarXtrH); break;
                    case 9: ini_inv(WarXtrI); break;
                    case 10: ini_inv(WarXtrJ); break;
                    case 11: ini_inv(WarXtrK); break;
                    case 12: ini_inv(WarXtrL); break;
                    case 13: ini_inv(WarXtrM); break;
                    case 14: ini_inv(WarXtrN); break;
                    case 15: ini_inv(WarXtrO); break;
                    case 16: ini_inv(WarXtrP); break;
                    case 17: ini_inv(WarXtrQ); break;
                    case 18: ini_inv(WarXtrR); break;
                    case 19: ini_inv(WarXtrS); break;
                    case 20: ini_inv(WarXtrT); break;
                    case 21: ini_inv(WarXtrU); break;
		    default: break;
		}
		ini_inv(Warrior);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 63:
		ini_inv(DollMistress);

		break;

	case 64:
		ini_inv(MahouShoujo);

		break;

	case 65:
		switch (rnd(9)) {   
		    case 1: Priest[P_BOOK].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Priest[P_BOOK].trotyp = SPE_SLEEP; break;
		    case 3: Priest[P_BOOK].trotyp = SPE_RESIST_POISON; break;
		    case 4: Priest[P_BOOK].trotyp = SPE_RESIST_SLEEP; break;
		    case 5: Priest[P_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 6: Priest[P_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: Priest[P_BOOK].trotyp = SPE_LIGHT; break;
		    case 8: Priest[P_BOOK].trotyp = SPE_KNOCK; break;
		    case 9: Priest[P_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Priest);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		spellbook_skill_raise(Skill_P, Priest[P_BOOK].trotyp);
		/* KMH, conduct --
		 * Some may claim that this isn't agnostic, since they
		 * are literally "priests" and they have holy water.
		 * But we don't count it as such.  Purists can always
		 * avoid playing priests and/or confirm another player's
		 * role in their YAAP.
		 */
		break;
	case 66:
		ini_inv(Chevalier);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		break;
	case 67:
		Ranger[RAN_TWO_ARROWS].trquan = rn1(10, 50);
		Ranger[RAN_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Ranger);
		break;
	case 68:
		Elph[ELP_TWO_ARROWS].trquan = rn1(10, 50);
		Elph[ELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Elph);

	    /* Elves can recognize all elvish objects */
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);

		break;
	case 69:
		ini_inv(Transvestite);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 70:
		ini_inv(Topmodel);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;

	case 71:
		ini_inv(Bully);

		if (rn2(5)) ini_inv(BullyA);
		if (rn2(2)) ini_inv(BullyB);
		if (!rn2(20)) ini_inv(Candle);
		if (!rn2(20)) ini_inv(BullyD);
		if (!rn2(20)) ini_inv(BullyE);

		break;

	case 72:

		ini_inv(Pickpocket);
		knows_classX(GEM_CLASS);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 200;
#else
		u.umoney0 = 200;
#endif

		break;

	case 73:
		Rogue[R_DAGGERS].trquan = rn1(10, 6);
		Rogue[R_DARTS].trquan = rn1(10, 25);
		if (rn2(100) < 30) {
			Rogue[R_DAGGERS].trotyp = PISTOL;
			Rogue[R_DAGGERS].trquan = 1;
			Rogue[R_DARTS].trotyp = PISTOL_BULLET;
		}
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500 ,1500);
#else
		u.umoney0 = rn1(500 ,1500);
#endif
		ini_inv(Rogue);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_object(OILSKIN_SACK);
		break;

	case 74:

		if (!rn2(20)) ini_inv(InvisibilityRing);
		ini_inv(Assassin);
		break;

	case 75:
		knows_class(WEAPON_CLASS);
		ini_inv(Ninja);
		break;

	case 76:
		ini_inv(Drunk);
		break;

	case 77:
		ini_inv(Officer);
		break;

	case 78:
		ini_inv(Undertaker);
		break;

	case 79:
		ini_inv(Musician);
		break;

	case 80:
		ini_inv(Zookeeper);
		break;

	case 81:
		ini_inv(Firefighter);
		break;

	case 82:
		ini_inv(Locksmith);
		break;

	case 83:
		Samurai[S_ARROWS].trquan = rn1(20, 26);
		ini_inv(Samurai);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 84:
		ini_inv(Otaku);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(500);
#else
		u.umoney0 = rnd(500);
#endif

		break;

	case 85:
		Tourist[T_DARTS].trquan = rn1(20, 21);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500,1000);
#else
		u.umoney0 = rn1(500,1000);
#endif
		ini_inv(Tourist);
		if(!rn2(25)) ini_inv(Tinopener);
		else if(!rn2(25)) ini_inv(Leash);
		else if(!rn2(25)) ini_inv(Towel);
		else if(!rn2(25)) ini_inv(Magicmarker);
		break;
	case 86:
		switch (rn2(100) / 25) {
		    case 0:	/* Pistol and silver bullets */
			UndeadSlayer[U_MINOR].trotyp = PISTOL;
			UndeadSlayer[U_RANGE].trotyp = SILVER_PISTOL_BULLET;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			break;
		    case 1:	/* Crossbow and bolts */
			UndeadSlayer[U_MINOR].trotyp = CROSSBOW;
			UndeadSlayer[U_RANGE].trotyp = CROSSBOW_BOLT;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			UndeadSlayer[U_MISC].trotyp = LOW_BOOTS;
			UndeadSlayer[U_MISC].trspe = 1;
			UndeadSlayer[U_ARMOR].trotyp = LEATHER_JACKET;
			UndeadSlayer[U_ARMOR].trspe = 1;
			/* helmet & armour are no longer candidates for
			 * substitution for orcish versions so no extra
			 * food should be given in compensation.
			 */
			if (Race_if(PM_ORC))
			    no_extra_food = TRUE;
		        break;
		    case 2:	/* Whip and daggers */
		        UndeadSlayer[U_MINOR].trotyp = BULLWHIP;
		        UndeadSlayer[U_MINOR].trspe = 2;
		        break;
		    case 3:	/* Silver spear and daggers */
			break;
		}
		ini_inv(UndeadSlayer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		if(!rn2(6)) ini_inv(Lamp);
		break;
	case 87:
		ini_inv(Valkyrie);
		if(!rn2(6)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 88:
		switch (rnd(2)) {                
		    case 1: Wizard[W_BOOK1].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Wizard[W_BOOK1].trotyp = SPE_SLEEP; break;
		    default: break;
		}
		switch (rnd(2)) {
		    case 1: Wizard[W_BOOK2].trotyp = SPE_RESIST_POISON; break;
		    case 2: Wizard[W_BOOK2].trotyp = SPE_RESIST_SLEEP; break;
		    default: break;
		}
		switch (rnd(5)) {   
		    case 1: Wizard[W_BOOK3].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Wizard[W_BOOK3].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Wizard[W_BOOK3].trotyp = SPE_LIGHT; break;
		    case 4: Wizard[W_BOOK3].trotyp = SPE_KNOCK; break;
		    case 5: Wizard[W_BOOK3].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		switch (rnd(9)) {
		    case 1: Wizard[W_BOOK4].trotyp = SPE_MAGIC_MISSILE; break;
		    case 2: Wizard[W_BOOK4].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Wizard[W_BOOK4].trotyp = SPE_SLOW_MONSTER; break;
		    case 4: Wizard[W_BOOK4].trotyp = SPE_CURE_BLINDNESS; break;
		    case 5: Wizard[W_BOOK4].trotyp = SPE_ENDURE_HEAT; break;
		    case 6: Wizard[W_BOOK4].trotyp = SPE_ENDURE_COLD; break;
		    case 7: Wizard[W_BOOK4].trotyp = SPE_INSULATE; break;
		    case 8: Wizard[W_BOOK4].trotyp = SPE_CREATE_MONSTER; break;
		    case 9: Wizard[W_BOOK4].trotyp = SPE_HEALING; break;
		    default: break;
		}
		ini_inv(Wizard);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;

	case 89:

		ini_inv(Sage);
		if(!rn2(3)) ini_inv(Magicmarker);

		break;

	case 90:
		ini_inv(Yeoman);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 91:
		ini_inv(Failed_Existence);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;

	case 92:
		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_ONE].trotyp = HELM_OF_THIRST; Murderer[M_ITEM_ONE].trspe = 3; break;
			case 2: Murderer[M_ITEM_ONE].trotyp = HELM_OF_BAD_ALIGNMENT; Murderer[M_ITEM_ONE].trspe = 0; break;
			default: break;
		}

		switch (rnd(5)) {                
			case 1: Murderer[M_ITEM_TWO].trotyp = GAUNTLETS_OF_TRAP_CREATION; Murderer[M_ITEM_TWO].trspe = 0; break;
			case 2: 
			case 3:
			case 4:
			case 5: Murderer[M_ITEM_TWO].trotyp = UNDROPPABLE_GLOVES; Murderer[M_ITEM_TWO].trspe = 2; break;
			default: break;
		}

		switch (rnd(11)) {                
			case 1: Murderer[M_ITEM_THREE].trotyp = STONE_OF_MAGIC_RESISTANCE; break;
			case 2: Murderer[M_ITEM_THREE].trotyp = SHADES_OF_GREY_STONE; break;
			case 3: Murderer[M_ITEM_THREE].trotyp = DSTW_STONE; break;
			case 4: Murderer[M_ITEM_THREE].trotyp = CONFUSION_STONE; break;
			case 5: Murderer[M_ITEM_THREE].trotyp = STONE_OF_INTRINSIC_LOSS; break;
			case 6: Murderer[M_ITEM_THREE].trotyp = ALIGNMENT_STONE; break;
			case 7: Murderer[M_ITEM_THREE].trotyp = TRAP_CREATION_STONE; break;
			case 8: Murderer[M_ITEM_THREE].trotyp = STONE_OF_VULNERABILITY; break;
			case 9: Murderer[M_ITEM_THREE].trotyp = STONE_OF_CURSING; break;
			case 10: Murderer[M_ITEM_THREE].trotyp = STATUS_STONE; break;
			case 11: Murderer[M_ITEM_THREE].trotyp = DEAFNESS_STONE; break;
			default: break;
		}

		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_FOUR].trotyp = TINNING_KIT; break;
			case 2: Murderer[M_ITEM_FOUR].trotyp = CAN_OF_GREASE; break;
			default: break;
		}

	        ini_inv(Murderer);
		  increasesincounter(16); /* You have sinned */
		  u.alignlim -= 16;
	        u.uhunger = 550;  /* On the verge of hungry */
	        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
	        urace.lovemask = 0; /* Murderers are pariahs of their race */
		    change_luck(-1); /* both their alignment and luck start out negative */
		break;

	case 93:
		ini_inv(Camperstriker);
		break;

	case 94:

		ini_inv(DQSlime);
		break;

	case 95:

		ini_inv(Erdrick);
		if (!rn2(4)) ini_inv(ErdrickKey);
		break;

	case 96:
		Twelph[TWELP_TWO_ARROWS].trquan = rn1(10, 50);
		Twelph[TWELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Twelph);

	    /* Elves can recognize all elvish objects */
	    knows_object(DARK_ELVEN_SHORT_SWORD);
	    knows_object(DARK_ELVEN_ARROW);
	    knows_object(DARK_ELVEN_BOW);
	    knows_object(DARK_ELVEN_DAGGER);
	    knows_object(DARK_ELVEN_MITHRIL_COAT);

		break;

	case 97:

		ini_inv(Golddigger);

		 knows_object(GNOMISH_HELM);
		 knows_object(GNOMISH_BOOTS);
		 knows_object(GNOMISH_SUIT);
		 knows_object(AKLYS);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(1000);
#else
		u.umoney0 = rnd(1000);
#endif

		break;

	case 98:

		ini_inv(Ringseeker);

		break;

	case 99:

		ini_inv(Midget);
	    knows_object(DWARVISH_SPEAR);
	    knows_object(DWARVISH_SHORT_SWORD);
	    knows_object(DWARVISH_MATTOCK);
	    knows_object(DWARVISH_IRON_HELM);
	    knows_object(DWARVISH_MITHRIL_COAT);
	    knows_object(DWARVISH_CLOAK);
	    knows_object(DWARVISH_ROUNDSHIELD);

		break;

	case 100:

		ini_inv(Shapeshifter);

		break;

	case 101:

		ini_inv(Anachronist);

		break;

	case 102:

		ini_inv(Druid);
		break;

	case 103:
		ini_inv(DoomMarine);
		break;

	case 104:
		ini_inv(Fighter);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 105:
		ini_inv(Fencer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 106:
		Medium[MED_TWO_ARROWS].trquan = rn1(10, 50);
		Medium[MED_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Medium);
		break;

	case 107:
		ini_inv(Sexymate);
		break;

	case 108:
		ini_inv(StandUser);
		break;

	case 109:
		ini_inv(JusticeKeeper);
		break;

	case 110:
		ini_inv(Poison_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 111:
		ini_inv(Transsylvanian);
		break;

	case 112:
		ini_inv(Unbeliever);
		break;

	case 113:
		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK1].trotyp = SPE_WATER_BOLT; break;
		    case 2: Elementalist[E_BOOK1].trotyp = SPE_VOLT_ROCK; break;
		    case 3: Elementalist[E_BOOK1].trotyp = SPE_WATER_FLAME; break;
		    case 4: Elementalist[E_BOOK1].trotyp = SPE_FIRE; break;
		    case 5: Elementalist[E_BOOK1].trotyp = SPE_STEAM_VENOM; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK2].trotyp = SPE_AIR_CURRENT; break;
		    case 2: Elementalist[E_BOOK2].trotyp = SPE_WIND; break;
		    case 3: Elementalist[E_BOOK2].trotyp = SPE_RAIN_CLOUD; break;
		    case 4: Elementalist[E_BOOK2].trotyp = SPE_FROST; break;
		    case 5: Elementalist[E_BOOK2].trotyp = SPE_DASHING; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK3].trotyp = SPE_POISON_BRAND; break;
		    case 2: Elementalist[E_BOOK3].trotyp = SPE_THUNDER_WAVE; break;
		    case 3: Elementalist[E_BOOK3].trotyp = SPE_ELEMENTAL_BEAM; break;
		    case 4: Elementalist[E_BOOK3].trotyp = SPE_BATTERING_RAM; break;
		    case 5: Elementalist[E_BOOK3].trotyp = SPE_POWER_FAILURE; break;
		    case 6: Elementalist[E_BOOK3].trotyp = SPE_VAPORIZE; break;
		    case 7: Elementalist[E_BOOK3].trotyp = SPE_BURROW; break;
		    case 8: Elementalist[E_BOOK3].trotyp = SPE_MELTDOWN; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK4].trotyp = SPE_CLOUDS; break;
		    case 2: Elementalist[E_BOOK4].trotyp = SPE_ICE; break;
		    case 3: Elementalist[E_BOOK4].trotyp = SPE_FLOOD; break;
		    case 4: Elementalist[E_BOOK4].trotyp = SPE_DRIPPING_TREAD; break;
		    case 5: Elementalist[E_BOOK4].trotyp = SPE_GEOLYSIS; break;
		    case 6: Elementalist[E_BOOK4].trotyp = SPE_LAVA; break;
		    case 7: Elementalist[E_BOOK4].trotyp = SPE_IRON_PRISON; break;
		    case 8: Elementalist[E_BOOK4].trotyp = SPE_LOCKOUT; break;
		    case 9: Elementalist[E_BOOK4].trotyp = SPE_GROW_TREES; break;
		    default: break;
		}
		switch (rnd(4)) {                
		    case 1: Elementalist[E_WAND].trotyp = WAN_FIRE; break;
		    case 2: Elementalist[E_WAND].trotyp = WAN_COLD; break;
		    case 3: Elementalist[E_WAND].trotyp = WAN_LIGHTNING; break;
		    case 4: Elementalist[E_WAND].trotyp = WAN_POISON; break;
		    default: break;
		}

		ini_inv(Elementalist);
		break;

	case 114:
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK1].trotyp = SPE_LINE_LOSS; break;
		    case 2: ChaosSorceror[C_BOOK1].trotyp = SPE_PET_SYRINGE; break;
		    case 3: ChaosSorceror[C_BOOK1].trotyp = SPE_CURE_RANDOM_STATUS; break;
		    case 4: ChaosSorceror[C_BOOK1].trotyp = SPE_BERSERK; break;
		    case 5: ChaosSorceror[C_BOOK1].trotyp = SPE_RESIST_RANDOM_ELEMENT; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK2].trotyp = SPE_LOCK_MANIPULATION; break;
		    case 2: ChaosSorceror[C_BOOK2].trotyp = SPE_RANDOM_SPEED; break;
		    case 3: ChaosSorceror[C_BOOK2].trotyp = SPE_CHAOS_BOLT; break;
		    case 4: ChaosSorceror[C_BOOK2].trotyp = SPE_BUC_RANDOMIZATION; break;
		    case 5: ChaosSorceror[C_BOOK2].trotyp = SPE_RUSSIAN_ROULETTE; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK3].trotyp = SPE_LYCANTHROPY; break;
		    case 2: ChaosSorceror[C_BOOK3].trotyp = SPE_BOMBING; break;
		    case 3: ChaosSorceror[C_BOOK3].trotyp = SPE_VANISHING; break;
		    case 4: ChaosSorceror[C_BOOK3].trotyp = SPE_EARTHQUAKE; break;
		    case 5: ChaosSorceror[C_BOOK3].trotyp = SPE_POLYFORM; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK4].trotyp = SPE_SELFDESTRUCT; break;
		    case 2: ChaosSorceror[C_BOOK4].trotyp = SPE_THRONE_GAMBLE; break;
		    case 3: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION; break;
		    case 4: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION_BEAM; break;
		    case 5: ChaosSorceror[C_BOOK4].trotyp = SPE_REROLL_ARTIFACT; break;
		    default: break;
		}

		ini_inv(ChaosSorceror);
		break;

	case 115:
		ini_inv(WildTalent);
		break;

	case 116:
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK1].trotyp = SPE_PREACHING; break;
		    case 2: OccultMaster[O_BOOK1].trotyp = SPE_STRANGLING; break;
		    case 3: OccultMaster[O_BOOK1].trotyp = SPE_MIMICRY; break;
		    case 4: OccultMaster[O_BOOK1].trotyp = SPE_MANA_BATTERY; break;
		    case 5: OccultMaster[O_BOOK1].trotyp = SPE_RESIST_PARALYSIS; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK2].trotyp = SPE_SPELLBINDER; break;
		    case 2: OccultMaster[O_BOOK2].trotyp = SPE_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_BOOK2].trotyp = SPE_TRACKER; break;
		    case 4: OccultMaster[O_BOOK2].trotyp = SPE_TOTEM_SUMMONING; break;
		    case 5: OccultMaster[O_BOOK2].trotyp = SPE_POSSESSION; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK3].trotyp = SPE_CODE_EDITING; break;
		    case 2: OccultMaster[O_BOOK3].trotyp = SPE_SATISFY_HUNGER; break;
		    case 3: OccultMaster[O_BOOK3].trotyp = SPE_FIRE_GOLEM; break;
		    case 4: OccultMaster[O_BOOK3].trotyp = SPE_DISRUPTION_SHIELD; break;
		    case 5: OccultMaster[O_BOOK3].trotyp = SPE_BLINDING_RAY; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK4].trotyp = SPE_COMMAND_DEMON; break;
		    case 2: OccultMaster[O_BOOK4].trotyp = SPE_REDEMPTION; break;
		    case 3: OccultMaster[O_BOOK4].trotyp = SPE_NEXUS_FIELD; break;
		    case 4: OccultMaster[O_BOOK4].trotyp = SPE_PHASE_DOOR; break;
		    case 5: OccultMaster[O_BOOK4].trotyp = SPE_HORRIFY; break;
		    default: break;
		}
		switch (rnd(3)) {                
		    case 1: OccultMaster[O_WAND].trotyp = WAN_SPELLBINDER; break;
		    case 2: OccultMaster[O_WAND].trotyp = WAN_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_WAND].trotyp = WAN_STERILIZE; break;
		    default: break;
		}

		ini_inv(OccultMaster);
		break;

	case 117:

		ini_inv(Prostitute);
		if(!rn2(10)) ini_inv(Condome);
		break;

	case 118:

		ini_inv(Kurwa);
		break;

	case 119:
		ini_inv(Feminist);

		break;

	case 120:
		ini_inv(Tracer);

		break;

	case 121:
		ini_inv(NuclearPhysicist);

		break;

	case 122:
		ini_inv(FormChanger);

		break;

	case 123:

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_WEAPON].trotyp = DAGGER; break;
		    case 2: GangScholar[GSC_WEAPON].trotyp = MACE; break;
		    case 3: GangScholar[GSC_WEAPON].trotyp = MORNING_STAR; break;
		    case 4: GangScholar[GSC_WEAPON].trotyp = SHORT_SWORD; break;
		    case 5: GangScholar[GSC_WEAPON].trotyp = FLAIL; break;
		    case 6: GangScholar[GSC_WEAPON].trotyp = TWO_HANDED_SWORD; break;
		    case 7: GangScholar[GSC_WEAPON].trotyp = SPEAR; break;
		    case 8: GangScholar[GSC_WEAPON].trotyp = QUARTERSTAFF; break;
		    case 9: GangScholar[GSC_WEAPON].trotyp = LONG_SWORD; break;
		    case 10: GangScholar[GSC_WEAPON].trotyp = BROADSWORD; break;
		    case 11: GangScholar[GSC_WEAPON].trotyp = CLUB; break;
		    default: break;
		}

		switch (rnd(9)) {
		    case 1: GangScholar[GSC_ARMOR].trotyp = LEATHER_ARMOR; break;
		    case 2: GangScholar[GSC_ARMOR].trotyp = YELLOW_DRAGON_SCALES; break;
		    case 3: GangScholar[GSC_ARMOR].trotyp = RING_MAIL; break;
		    case 4: GangScholar[GSC_ARMOR].trotyp = SCALE_MAIL; break;
		    case 5: GangScholar[GSC_ARMOR].trotyp = CHAIN_MAIL; break;
		    case 6: GangScholar[GSC_ARMOR].trotyp = SPLINT_MAIL; break;
		    case 7: GangScholar[GSC_ARMOR].trotyp = PLATE_MAIL; break;
		    case 8: GangScholar[GSC_ARMOR].trotyp = STUDDED_LEATHER_ARMOR; break;
		    case 9: GangScholar[GSC_ARMOR].trotyp = ELVEN_MITHRIL_COAT; break;
		}

		switch (rnd(8)) {
		    case 1: GangScholar[GSC_RING].trotyp = RIN_ADORNMENT; break;
		    case 2: GangScholar[GSC_RING].trotyp = RIN_PROTECTION; break;
		    case 3: GangScholar[GSC_RING].trotyp = RIN_GAIN_CONSTITUTION; break;
		    case 4: GangScholar[GSC_RING].trotyp = RIN_GAIN_DEXTERITY; break;
		    case 5: GangScholar[GSC_RING].trotyp = RIN_GAIN_INTELLIGENCE; break;
		    case 6: GangScholar[GSC_RING].trotyp = RIN_GAIN_STRENGTH; break;
		    case 7: GangScholar[GSC_RING].trotyp = RIN_INCREASE_ACCURACY; break;
		    case 8: GangScholar[GSC_RING].trotyp = RIN_INCREASE_DAMAGE; break;
		}

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_POTION].trotyp = POT_HEALING; break;
		    case 2: GangScholar[GSC_POTION].trotyp = POT_EXTRA_HEALING; break;
		    case 3: GangScholar[GSC_POTION].trotyp = POT_GAIN_ENERGY; break;
		    case 4: GangScholar[GSC_POTION].trotyp = POT_BANISHING_FEAR; break;
		    case 5: GangScholar[GSC_POTION].trotyp = POT_MONSTER_DETECTION; break;
		    case 6: GangScholar[GSC_POTION].trotyp = POT_OBJECT_DETECTION; break;
		    case 7: GangScholar[GSC_POTION].trotyp = POT_LEVITATION; break;
		    case 8: GangScholar[GSC_POTION].trotyp = POT_SPEED; break;
		    case 9: GangScholar[GSC_POTION].trotyp = POT_GAIN_ABILITY; break;
		    case 10: GangScholar[GSC_POTION].trotyp = POT_GAIN_LEVEL; break;
		    case 11: GangScholar[GSC_POTION].trotyp = POT_WATER; break;
		}

		switch (rnd(13)) {
		    case 1: GangScholar[GSC_SCROLL].trotyp = SCR_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_SCROLL].trotyp = SCR_SUMMON_UNDEAD; break;
		    case 3: GangScholar[GSC_SCROLL].trotyp = SCR_LIGHT; break;
		    case 4: GangScholar[GSC_SCROLL].trotyp = SCR_IDENTIFY; break;
		    case 5: GangScholar[GSC_SCROLL].trotyp = SCR_MAGIC_MAPPING; break;
		    case 6: GangScholar[GSC_SCROLL].trotyp = SCR_REMOVE_CURSE; break;
		    case 7: GangScholar[GSC_SCROLL].trotyp = SCR_TELEPORTATION; break;
		    case 8: GangScholar[GSC_SCROLL].trotyp = SCR_HEALING; break;
		    case 9: GangScholar[GSC_SCROLL].trotyp = SCR_PHASE_DOOR; break;
		    case 10: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_DETECTION; break;
		    case 11: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_CREATION; break;
		    case 12: GangScholar[GSC_SCROLL].trotyp = SCR_SLEEP; break;
		    case 13: GangScholar[GSC_SCROLL].trotyp = SCR_BLANK_PAPER; break;
		}

		switch (rnd(26)) {
		    case 1: GangScholar[GSC_WAND].trotyp = WAN_LIGHT; break;
		    case 2: GangScholar[GSC_WAND].trotyp = WAN_NOTHING; break;
		    case 3: GangScholar[GSC_WAND].trotyp = WAN_HEALING; break;
		    case 4: GangScholar[GSC_WAND].trotyp = WAN_IDENTIFY; break;
		    case 5: GangScholar[GSC_WAND].trotyp = WAN_REMOVE_CURSE; break;
		    case 6: GangScholar[GSC_WAND].trotyp = WAN_ENTRAPPING; break;
		    case 7: GangScholar[GSC_WAND].trotyp = WAN_TRAP_CREATION; break;
		    case 8: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MAPPING; break;
		    case 9: GangScholar[GSC_WAND].trotyp = WAN_DETECT_MONSTERS; break;
		    case 10: GangScholar[GSC_WAND].trotyp = WAN_OBJECTION; break;
		    case 11: GangScholar[GSC_WAND].trotyp = WAN_SLOW_MONSTER; break;
		    case 12: GangScholar[GSC_WAND].trotyp = WAN_SPEED_MONSTER; break;
		    case 13: GangScholar[GSC_WAND].trotyp = WAN_HASTE_MONSTER; break;
		    case 14: GangScholar[GSC_WAND].trotyp = WAN_CREATE_MONSTER; break;
		    case 15: GangScholar[GSC_WAND].trotyp = WAN_SUMMON_UNDEAD; break;
		    case 16: GangScholar[GSC_WAND].trotyp = WAN_POLYMORPH; break;
		    case 17: GangScholar[GSC_WAND].trotyp = WAN_TELEPORTATION; break;
		    case 18: GangScholar[GSC_WAND].trotyp = WAN_BANISHMENT; break;
		    case 19: GangScholar[GSC_WAND].trotyp = WAN_EXTRA_HEALING; break;
		    case 20: GangScholar[GSC_WAND].trotyp = WAN_FULL_HEALING; break;
		    case 21: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_WAND].trotyp = WAN_FIRE; break;
		    case 23: GangScholar[GSC_WAND].trotyp = WAN_COLD; break;
		    case 24: GangScholar[GSC_WAND].trotyp = WAN_SLEEP; break;
		    case 25: GangScholar[GSC_WAND].trotyp = WAN_LIGHTNING; break;
		    case 26: GangScholar[GSC_WAND].trotyp = WAN_FIREBALL; break;
		}

		switch (rnd(25)) {
		    case 1: GangScholar[GSC_BOOK].trotyp = SPE_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_BOOK].trotyp = SPE_HEALING; break;
		    case 3: GangScholar[GSC_BOOK].trotyp = SPE_EXTRA_HEALING; break;
		    case 4: GangScholar[GSC_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 5: GangScholar[GSC_BOOK].trotyp = SPE_CLAIRVOYANCE; break;
		    case 6: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_TREASURE; break;
		    case 8: GangScholar[GSC_BOOK].trotyp = SPE_IDENTIFY; break;
		    case 9: GangScholar[GSC_BOOK].trotyp = SPE_ENTRAPPING; break;
		    case 10: GangScholar[GSC_BOOK].trotyp = SPE_SLOW_MONSTER; break;
		    case 11: GangScholar[GSC_BOOK].trotyp = SPE_PROTECTION; break;
		    case 12: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_COLD; break;
		    case 13: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_HEAT; break;
		    case 14: GangScholar[GSC_BOOK].trotyp = SPE_INSULATE; break;
		    case 15: GangScholar[GSC_BOOK].trotyp = SPE_REMOVE_CURSE; break;
		    case 16: GangScholar[GSC_BOOK].trotyp = SPE_LEVITATION; break;
		    case 17: GangScholar[GSC_BOOK].trotyp = SPE_TELEPORT_AWAY; break;
		    case 18: GangScholar[GSC_BOOK].trotyp = SPE_POLYMORPH; break;
		    case 19: GangScholar[GSC_BOOK].trotyp = SPE_FIRE_BOLT; break;
		    case 20: GangScholar[GSC_BOOK].trotyp = SPE_PHASE_DOOR; break;
		    case 21: GangScholar[GSC_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_BOOK].trotyp = SPE_FIREBALL; break;
		    case 23: GangScholar[GSC_BOOK].trotyp = SPE_CONE_OF_COLD; break;
		    case 24: GangScholar[GSC_BOOK].trotyp = SPE_SLEEP; break;
		    case 25: GangScholar[GSC_BOOK].trotyp = SPE_LIGHTNING; break;
		}

		ini_inv(GangScholar);

		break;

	case 124:
		ini_inv(Hussy);
		break;

	case 125:
		ini_inv(Mason);
		break;

	case 126:

		switch (rnd(20)) {
		    case 1: Acu[ACUWEAPON].trotyp = DAGGER; break;
		    case 2: Acu[ACUWEAPON].trotyp = KNIFE; break;
		    case 3: Acu[ACUWEAPON].trotyp = AXE; break;
		    case 4: Acu[ACUWEAPON].trotyp = SHORT_SWORD; break;
		    case 5: Acu[ACUWEAPON].trotyp = PAPER_SWORD; break;
		    case 6: Acu[ACUWEAPON].trotyp = SUGUHANOKEN; break;
		    case 7: Acu[ACUWEAPON].trotyp = SCIMITAR; break;
		    case 8: Acu[ACUWEAPON].trotyp = RAPIER; break;
		    case 9: Acu[ACUWEAPON].trotyp = CLUB; break;
		    case 10: Acu[ACUWEAPON].trotyp = FLY_SWATTER; break;
		    case 11: Acu[ACUWEAPON].trotyp = MACE; break;
		    case 12: Acu[ACUWEAPON].trotyp = MORNING_STAR; break;
		    case 13: Acu[ACUWEAPON].trotyp = FLAIL; break;
		    case 14: Acu[ACUWEAPON].trotyp = WAR_HAMMER; break;
		    case 15: Acu[ACUWEAPON].trotyp = SICKLE; break;
		    case 16: Acu[ACUWEAPON].trotyp = SPEAR; break;
		    case 17: Acu[ACUWEAPON].trotyp = JAVELIN; break;
		    case 18: Acu[ACUWEAPON].trotyp = TRIDENT; break;
		    case 19: Acu[ACUWEAPON].trotyp = LANCE; break;
		    case 20: Acu[ACUWEAPON].trotyp = BULLWHIP; break;
		}

		ini_inv(Acu);
		break;

	case 127:
		ini_inv(Grenadonin);
		break;

	case 128:
		ini_inv(Demagogue);
		break;

	case 129:
		ini_inv(Walscholar);
		break;

	case 130:
		ini_inv(SocialJusticeWarrior);
		break;

	case 131:
		ini_inv(CellarChild);
		break;

	case 132:
		ini_inv(SoftwareEngineer);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(200);
#else
		u.umoney0 = rnd(200);
#endif

		break;

	case 133:
		ini_inv(Cracker);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 134:
		ini_inv(Janitor);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 135:
		ini_inv(SpaceMarine);
		break;

	case 136:
		ini_inv(Stormboy);
		break;

	case 137:
		ini_inv(Yautja);
		break;

	case 138:
		ini_inv(Quarterback);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		break;

	case 139:
		ini_inv(Psyker);
		break;

	case 140:
		ini_inv(Empath);
		break;

	case 141:
		ini_inv(Mastermind);
		break;

	case 142:
		ini_inv(Weirdboy);
		break;

	case 143:
		ini_inv(Astronaut);
		break;

	case 144:
		ini_inv(Cyberninja);
		break;

	case 145:
		ini_inv(Dissident);
		break;

	case 146:
		ini_inv(XelNaga);
		break;

	case 147:
		ini_inv(Cartomancer);
		break;

	case 148:
		ini_inv(Dragonmaster);
		break;

	case 149:
		ini_inv(Combatant);
		break;

	case 150:
		ini_inv(Fjorde);
		break;

	case 151:
		ini_inv(Practicant);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 152:
		Emera[EMERA_FLINT].trquan = 50 + rnd(50);
		ini_inv(Emera);
		break;

	case 153:
		ini_inv(Tosser);
		break;

	case 154:
		ini_inv(Aklyst);
		break;

	case 155:
		MillSwallower[MS_BOLTS].trquan = 20 + rnd(40);
		ini_inv(MillSwallower);
		break;

	case 156:
		ini_inv(Symbiant);
		break;

	case 157:
		ini_inv(Genderstarist);
		break;

	case 158:
		ini_inv(ButtLover);
		break;

	case 159:
		ini_inv(Dancer);
		break;

	case 160:
		ini_inv(Diablist);
		break;

	case 161:
		ini_inv(Preversioner);
		break;

	case 162:
		ini_inv(SecretAdviceMember);
		break;

	case 163:
		ini_inv(ShoeFetishist);
		break;

	case 164:
		switch (rn2(90) / 30) {
		case 0: HalfBaked[HBA_BOOK].trotyp = SPE_HEALING; break;
		case 1: HalfBaked[HBA_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: HalfBaked[HBA_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(HalfBaked);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		break;

	case 165:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    NoobModeBarb[N_MAJOR].trotyp = BATTLE_AXE;
		    NoobModeBarb[N_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(NoobModeBarb);
		break;

	case 166:
		ini_inv(Climacterial);
		break;

	case 167:
		Womanizer[WOMGEM].trotyp = rnd_class(ELIF_S_JEWEL, DORA_S_JEWEL);
		ini_inv(Womanizer);
		break;

	case 168:
		ini_inv(Singslave);
		break;

	case 169:
		ini_inv(Jedi);
		ini_inv(GreenSaber);
		ini_inv(YellowSaber);
		ini_inv(WhiteDoubleSaber);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 170:
		ini_inv(VanillaValk);
		if(!rn2(6)) ini_inv(Lamp);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 171:
		ini_inv(ShadowJedi);
		if(!rn2(2)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 172:
		ini_inv(Jockey);
		break;

	case 173:

		ini_inv(Alltecher);
		break;

	case 174:

		ini_inv(Spellmaster);
		break;


	default:	/* impossible */
		break;
	}

	xtraskillinit();	/* so you actually get the skills of those objects --Amy */

	} /* randomizer only */

	if (isnullrace && israndomizer) { /* null would cancel out randomizer, so let's allow hybrids to start with some _very_ random stuff. --Amy */

		if (!rn2(5)) ini_inv(UberLostSoulItemC1);
		if (!rn2(5)) ini_inv(UberLostSoulItemD1);
		if (!rn2(10)) ini_inv(UberLostSoulItemE1);
		if (!rn2(6)) ini_inv(UberLostSoulItemF1);
		if (!rn2(10)) ini_inv(UberLostSoulItemG1);
		if (!rn2(10)) ini_inv(UberLostSoulItemH1);
		if (!rn2(20)) ini_inv(UberLostSoulItemI1);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ1);
		if (!rn2(5)) ini_inv(UberLostSoulItemK1);
		if (!rn2(10)) ini_inv(UberLostSoulItemL1);
		if (!rn2(20)) ini_inv(UberLostSoulItemM1);

		if (rn2(5)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC2);
		if (!rn2(5)) ini_inv(UberLostSoulItemD2);
		if (!rn2(10)) ini_inv(UberLostSoulItemE2);
		if (!rn2(6)) ini_inv(UberLostSoulItemF2);
		if (!rn2(10)) ini_inv(UberLostSoulItemG2);
		if (!rn2(10)) ini_inv(UberLostSoulItemH2);
		if (!rn2(20)) ini_inv(UberLostSoulItemI2);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ2);
		if (!rn2(5)) ini_inv(UberLostSoulItemK2);
		if (!rn2(10)) ini_inv(UberLostSoulItemL2);
		if (!rn2(20)) ini_inv(UberLostSoulItemM2);
		}

		if (rn2(3)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC3);
		if (!rn2(5)) ini_inv(UberLostSoulItemD3);
		if (!rn2(10)) ini_inv(UberLostSoulItemE3);
		if (!rn2(6)) ini_inv(UberLostSoulItemF3);
		if (!rn2(10)) ini_inv(UberLostSoulItemG3);
		if (!rn2(10)) ini_inv(UberLostSoulItemH3);
		if (!rn2(20)) ini_inv(UberLostSoulItemI3);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ3);
		if (!rn2(5)) ini_inv(UberLostSoulItemK3);
		if (!rn2(10)) ini_inv(UberLostSoulItemL3);
		if (!rn2(20)) ini_inv(UberLostSoulItemM3);
		}

		if (rn2(2)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC4);
		if (!rn2(5)) ini_inv(UberLostSoulItemD4);
		if (!rn2(10)) ini_inv(UberLostSoulItemE4);
		if (!rn2(6)) ini_inv(UberLostSoulItemF4);
		if (!rn2(10)) ini_inv(UberLostSoulItemG4);
		if (!rn2(10)) ini_inv(UberLostSoulItemH4);
		if (!rn2(20)) ini_inv(UberLostSoulItemI4);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ4);
		if (!rn2(5)) ini_inv(UberLostSoulItemK4);
		if (!rn2(10)) ini_inv(UberLostSoulItemL4);
		if (!rn2(20)) ini_inv(UberLostSoulItemM4);
		}

		if (!rn2(3)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC5);
		if (!rn2(5)) ini_inv(UberLostSoulItemD5);
		if (!rn2(10)) ini_inv(UberLostSoulItemE5);
		if (!rn2(6)) ini_inv(UberLostSoulItemF5);
		if (!rn2(10)) ini_inv(UberLostSoulItemG5);
		if (!rn2(10)) ini_inv(UberLostSoulItemH5);
		if (!rn2(20)) ini_inv(UberLostSoulItemI5);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ5);
		if (!rn2(5)) ini_inv(UberLostSoulItemK5);
		if (!rn2(10)) ini_inv(UberLostSoulItemL5);
		if (!rn2(20)) ini_inv(UberLostSoulItemM5);
		}

		if (!rn2(5)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC6);
		if (!rn2(5)) ini_inv(UberLostSoulItemD6);
		if (!rn2(10)) ini_inv(UberLostSoulItemE6);
		if (!rn2(6)) ini_inv(UberLostSoulItemF6);
		if (!rn2(10)) ini_inv(UberLostSoulItemG6);
		if (!rn2(10)) ini_inv(UberLostSoulItemH6);
		if (!rn2(20)) ini_inv(UberLostSoulItemI6);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ6);
		if (!rn2(5)) ini_inv(UberLostSoulItemK6);
		if (!rn2(10)) ini_inv(UberLostSoulItemL6);
		if (!rn2(20)) ini_inv(UberLostSoulItemM6);
		}

		if (!rn2(7)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC7);
		if (!rn2(5)) ini_inv(UberLostSoulItemD7);
		if (!rn2(10)) ini_inv(UberLostSoulItemE7);
		if (!rn2(6)) ini_inv(UberLostSoulItemF7);
		if (!rn2(10)) ini_inv(UberLostSoulItemG7);
		if (!rn2(10)) ini_inv(UberLostSoulItemH7);
		if (!rn2(20)) ini_inv(UberLostSoulItemI7);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ7);
		if (!rn2(5)) ini_inv(UberLostSoulItemK7);
		if (!rn2(10)) ini_inv(UberLostSoulItemL7);
		if (!rn2(20)) ini_inv(UberLostSoulItemM7);
		}

		if (!rn2(10)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC8);
		if (!rn2(5)) ini_inv(UberLostSoulItemD8);
		if (!rn2(10)) ini_inv(UberLostSoulItemE8);
		if (!rn2(6)) ini_inv(UberLostSoulItemF8);
		if (!rn2(10)) ini_inv(UberLostSoulItemG8);
		if (!rn2(10)) ini_inv(UberLostSoulItemH8);
		if (!rn2(20)) ini_inv(UberLostSoulItemI8);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ8);
		if (!rn2(5)) ini_inv(UberLostSoulItemK8);
		if (!rn2(10)) ini_inv(UberLostSoulItemL8);
		if (!rn2(20)) ini_inv(UberLostSoulItemM8);
		}

		if (!rn2(20)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC9);
		if (!rn2(5)) ini_inv(UberLostSoulItemD9);
		if (!rn2(10)) ini_inv(UberLostSoulItemE9);
		if (!rn2(6)) ini_inv(UberLostSoulItemF9);
		if (!rn2(10)) ini_inv(UberLostSoulItemG9);
		if (!rn2(10)) ini_inv(UberLostSoulItemH9);
		if (!rn2(20)) ini_inv(UberLostSoulItemI9);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ9);
		if (!rn2(5)) ini_inv(UberLostSoulItemK9);
		if (!rn2(10)) ini_inv(UberLostSoulItemL9);
		if (!rn2(20)) ini_inv(UberLostSoulItemM9);
		}

		if (!rn2(50)) {
		if (!rn2(5)) ini_inv(UberLostSoulItemC10);
		if (!rn2(5)) ini_inv(UberLostSoulItemD10);
		if (!rn2(10)) ini_inv(UberLostSoulItemE10);
		if (!rn2(6)) ini_inv(UberLostSoulItemF10);
		if (!rn2(10)) ini_inv(UberLostSoulItemG10);
		if (!rn2(10)) ini_inv(UberLostSoulItemH10);
		if (!rn2(20)) ini_inv(UberLostSoulItemI10);
		if (!rn2(8)) ini_inv(UberLostSoulItemJ10);
		if (!rn2(5)) ini_inv(UberLostSoulItemK10);
		if (!rn2(10)) ini_inv(UberLostSoulItemL10);
		if (!rn2(20)) ini_inv(UberLostSoulItemM10);
		}

	xtraskillinit();	/* so you actually get the skills of those objects --Amy */

	} /* null and randomizer */

	} /* israndomizer */

	if (Race_if(PM_BASTARD)) {

	switch (rnd(174)) {
	case 1:
		switch (rnd(5)) {   
		    case 1: Archeologist[A_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Archeologist[A_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Archeologist[A_BOOK].trotyp = SPE_LIGHT; break;
		    case 4: Archeologist[A_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Archeologist[A_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Archeologist);
		if(!rn2(4)) ini_inv(Blindfold);
		else if(!rn2(4)) ini_inv(Towel);
		if(!rn2(4)) ini_inv(Leash);
		if(!rn2(4)) ini_inv(Tinopener);
		else if(!rn2(4))
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		if(!rn2(8)) ini_inv(Magicmarker);
		knows_object(TOUCHSTONE);
		knows_object(SACK);
		break;

	case 2:
		switch (rnd(5)) {   
		    case 1: Augurer[AUG_BOOK].trotyp = SPE_CAUSE_FEAR; break;
		    case 2: Augurer[AUG_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Augurer[AUG_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 4: Augurer[AUG_BOOK].trotyp = SPE_KNOCK; break;
		    case 5: Augurer[AUG_BOOK].trotyp = (!rn2(3) ? SPE_SLEEP : !rn2(2) ? SPE_IDENTIFY : SPE_MAGIC_MAPPING); break;
		    default: break;
		}
		ini_inv(Augurer);
		if(!rn2(4)) ini_inv(Candle);
		else if(!rn2(4)) ini_inv(Touchstone);
		else if(!rn2(4)) ini_inv(Magicmarker);

		break;

	case 3:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    Barbarian[B_MAJOR].trotyp = BATTLE_AXE;
		    Barbarian[B_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(Barbarian);
		if(!rn2(6)) ini_inv(Torch);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 4:
		ini_inv(Binder);
	  increasesincounter(16); /*One transgression is all it takes*/
	  u.alignlim -= 16;
	    change_luck(-1); /*One resurection or two rehumanizations is all it takes*/
		break;

	case 5:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = (3000 + rnd(2000));
#else
		u.umoney0 = (3000 + rnd(2000));
#endif
		ini_inv(Politician);
		break;

	case 6:
		ini_inv(Bleeder);
		break;
	case 7:
		ini_inv(Librarian);
		break;
	case 8:

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 500;
#else
		u.umoney0 = 500;
#endif

		ini_inv(Supermarket);
		if ((rnd(5)) > 2) ini_inv(SupermarketB);
		if (!rn2(5)) ini_inv(SupermarketA);
		break;
	case 9:
		ini_inv(Scribe);
		break;
	case 10:
		ini_inv(Gamer);
		break;
	case 11:
		ini_inv(Artist);
		break;
	case 12:
		ini_inv(Cook);
		break;
	case 13:
		if (rn2(100) >= 50) Bard[BARD_INSTR].trotyp = WOODEN_FLUTE;
		if (rn2(100) >= 85) Bard[BARD_WHISTLE].trotyp = BELL;
		Bard[BARD_BOOZE].trquan = rn1(2, 5);
		ini_inv(Bard);
		/* This depends on the order in objects.c */
		for (i = TIN_WHISTLE; i <= DRUM_OF_EARTHQUAKE; i++)
			knows_object(i);
		/* Bards know about the enchantment spellbooks, though they don't know
		   the spells */
		knows_object(SPE_SLEEP);
		knows_object(SPE_CONFUSE_MONSTER);
		knows_object(SPE_SLOW_MONSTER);
		knows_object(SPE_CAUSE_FEAR);
		knows_object(SPE_CHARM_MONSTER);
		/* Bards also know a lot about legendary & magical stuff. */
		know_random_obj();
		break;
	case 14:
		u.nv_range = 2;
		Cave_man[C_AMMO].trquan = rn1(11, 10);	/* 10..20 */
		ini_inv(Cave_man);
		break;
	case 15:
		ini_inv(Gangster);
		break;
	case 16:
		ini_inv(Gunner);
		break;
	case 17:
		ini_inv(Death_Eater);
		break;
	case 18:
		ini_inv(Pokemon);
		break;
	case 19:
		switch (rnd(2)) {                
			case 1: Flame_Mage[F_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
			case 2: Flame_Mage[F_BOOK].trotyp = SPE_LIGHT; break;
			default: break;
		}
		ini_inv(Flame_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;
	case 20:
        ini_inv(Courier);
		break;

	case 21:
        ini_inv(Spacewars_Fighter);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 1500;
#else
		u.umoney0 = 1500;
#endif
		break;

	case 22:
        ini_inv(Rocker);
		break;

	case 23:
        ini_inv(Zyborg);
		break;

	case 24:
        ini_inv(Lunatic);

		if (!Race_if(PM_AK_THIEF_IS_DEAD_)) {
		switch (rnd(7)) {
		case 1: 	    u.ulycn = PM_WEREWOLF; break;
		case 2: 	    u.ulycn = PM_WEREJACKAL; break;
		case 3: 	    u.ulycn = PM_WERERAT; break;
		case 4: 	    u.ulycn = PM_WEREPANTHER; break;
		case 5: 	    u.ulycn = PM_WERETIGER; break;
		case 6: 	    u.ulycn = PM_WERESNAKE; break;
		case 7: 	    u.ulycn = PM_WERESPIDER; break;
		default: 	    u.ulycn = PM_WEREWOLF; break;

		}
		}

		break;

	case 25:
        ini_inv(Convict);
        knows_object(SKELETON_KEY);
        knows_object(GRAPPLING_HOOK);
	  increasesincounter(16); /* You have sinned */
	  u.alignlim -= 16;
        u.uhunger = 550;  /* On the verge of hungry */
    	/* u.ualignbase[A_CURRENT] = u.ualignbase[A_ORIGINAL] =
        u.ualign.type = A_CHAOTIC; Override racial alignment */
        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
        urace.lovemask = 0; /* Convicts are pariahs of their race */
	    change_luck(-1); /* both their alignment and luck start out negative */
        break;
	case 26:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(1000, 1001);
#else
		u.umoney0 = rn1(1000, 1001);
#endif
		ini_inv(Healer);
		knows_classX(POTION_CLASS); /* WAC - remove? */ /* edit by Amy - nope, but change to include magic ones */
		knows_object(POT_SICKNESS);
		knows_object(POT_BLINDNESS);
		knows_object(POT_HALLUCINATION);
		knows_object(POT_RESTORE_ABILITY);
		knows_object(POT_FULL_HEALING);
		knows_object(HEALTHSTONE);	/* KMH */
		if(!rn2(5)) ini_inv(Lamp);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;
	case 27:
		switch (rnd(2)) {                
			case 1: Ice_Mage[I_BOOK].trotyp = SPE_CONFUSE_MONSTER; break;
			case 2: Ice_Mage[I_BOOK].trotyp = SPE_SLOW_MONSTER; break;
			default: break;
		}
		ini_inv(Ice_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 28:
		ini_inv(Electric_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 29:
		ini_inv(Abuser);
		break;

	case 30:
		ini_inv(Mystic);
		break;

	case 31:
		ini_inv(Jester);
		break;

	case 32:
		ini_inv(Ladiesman);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 300;
#else
		u.umoney0 = 300;
#endif
		break;

	case 33:
		ini_inv(Bloodseeker);
		if ((rnd(10)) > 3) ini_inv(BloodseekerA);
		break;

	case 34:
		ini_inv(SlaveMaster);
		if ((rnd(10)) > 3) ini_inv(SlaveMasterA);
		if (!rn2(2)) ini_inv(SlaveMasterB);
		if ((rnd(100)) > 92) ini_inv(SlaveMasterC);
		break;

	case 35:
		ini_inv(Acid_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 36:
		Geek[G_IC].trquan = rn2(7) + 1;
		ini_inv(Geek);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(PACK_OF_FLOPPIES);
		knows_object(POT_JOLT_COLA);
		knows_object(DIODE);
		knows_object(TRANSISTOR);
		knows_object(IC);
		break;

	case 37:
		ini_inv(Graduate);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 38:
		ini_inv(Scientist);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		knows_object(CHEMISTRY_SET);
		knows_classX(POTION_CLASS);
		break;

	case 39:
		ini_inv(Jedi);
		switch(rnd(9)) {
			case 1: ini_inv(RedSaber); break;
			case 2: ini_inv(BlueSaber); break;
			case 3: ini_inv(GreenSaber); break;
			case 4: ini_inv(VioletSaber); break;
			case 5: ini_inv(WhiteSaber); break;
			case 6: ini_inv(YellowSaber); break;
			case 7: ini_inv(RedDoubleSaber); break;
			case 8: ini_inv(WhiteDoubleSaber); break;
			case 9: ini_inv(MysterySaber); break;
			default: break;
		}
		if(!rn2(2)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 40:
		ini_inv(Knight);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		/* give knights chess-like mobility
		 * -- idea from wooledge@skybridge.scl.cwru.edu */
		HJumping |= FROMOUTSIDE;
		break;

	case 41:
		ini_inv(Wandkeeper);
		knows_classX(WAND_CLASS);
		break;

	case 42:
		ini_inv(StuntMaster);

		HJumping |= FROMOUTSIDE;
		break;

	case 43:
		ini_inv(FoxhoundAgent);

		break;

	case 44:
		ini_inv(Paladin);

		break;

	case 45:
		switch (rn2(90) / 30) {
		case 0: Monk[M_BOOK].trotyp = SPE_HEALING; break;
		case 1: Monk[M_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: Monk[M_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(Monk);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		break;
	case 46:
		ini_inv(Saiyan);
		break;

	case 47:
		switch (rn2(90) / 30) {
		case 0: Psion[M_BOOK].trotyp = SPE_KNOCK; break;
		case 1: Psion[M_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		case 2: Psion[M_BOOK].trotyp = SPE_CHARM_MONSTER; break;
		}
		ini_inv(Psion);
		if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(10)) ini_inv(Magicmarker);
		knows_classX(SPBOOK_CLASS);
		knows_classX(ARMOR_CLASS);
		break;
	case 48:
		if(flags.female){
			Noble[NOB_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Noble);
		knows_class(ARMOR_CLASS);
		break;
	case 49:
		if(flags.female){
			Activistor[ACT_SHIRT].trotyp = VICTORIAN_UNDERWEAR;
		}
		ini_inv(Activistor);
		break;
	case 50:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		Pirate[PIR_KNIVES].trquan = rn1(2, 2);
		if(!rn2(4)) Pirate[PIR_SNACK].trotyp = KELP_FROND;
		Pirate[PIR_SNACK].trquan += rn2(4);
		if(rn2(100)<50)	Pirate[PIR_JEWELRY].trotyp = RIN_ADORNMENT;
		if(rn2(100)<50)	Pirate[PIR_TOOL].trotyp = GRAPPLING_HOOK;
		ini_inv(Pirate);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 51:
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(300);
#else
		u.umoney0 = rnd(300);
#endif
		ini_inv(Korsair);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 52:
		ini_inv(Gladiator);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 53:
		ini_inv(Goff);
		break;
	case 54:
		ini_inv(Amazon);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 55:
		ini_inv(Ordinator);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 56:
		ini_inv(Thalmor);
		knows_class(ARMOR_CLASS);
		knows_class(WEAPON_CLASS);
		break;
	case 57:
		ini_inv(Altmer);
		knows_classX(SPBOOK_CLASS);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 58:
		ini_inv(Bosmer);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 59:
		ini_inv(Dunmer);
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
		break;
	case 60:
		ini_inv(Diver);
		knows_object(OILSKIN_SACK);
		knows_object(OILSKIN_CLOAK);
		knows_object(GRAPPLING_HOOK);
		break;
	case 61:
		switch (rnd(5)) {   
                    case 1: Necromancer[N_BOOK].trotyp = SPE_MAGIC_BOLT; break;
                    case 2: Necromancer[N_BOOK].trotyp = SPE_KNOCK; break;
                    case 3: Necromancer[N_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
                    case 4: Necromancer[N_BOOK].trotyp = SPE_CREATE_MONSTER; break;
                    case 5: Necromancer[N_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Necromancer);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;
	case 62:
		switch (rnd(21)) {   
                    case 1: ini_inv(WarXtrA); break;
                    case 2: ini_inv(WarXtrB); break;
                    case 3: ini_inv(WarXtrC); break;
                    case 4: ini_inv(WarXtrD); break;
                    case 5: ini_inv(WarXtrE); break;
                    case 6: ini_inv(WarXtrF); break;
                    case 7: ini_inv(WarXtrG); break;
                    case 8: ini_inv(WarXtrH); break;
                    case 9: ini_inv(WarXtrI); break;
                    case 10: ini_inv(WarXtrJ); break;
                    case 11: ini_inv(WarXtrK); break;
                    case 12: ini_inv(WarXtrL); break;
                    case 13: ini_inv(WarXtrM); break;
                    case 14: ini_inv(WarXtrN); break;
                    case 15: ini_inv(WarXtrO); break;
                    case 16: ini_inv(WarXtrP); break;
                    case 17: ini_inv(WarXtrQ); break;
                    case 18: ini_inv(WarXtrR); break;
                    case 19: ini_inv(WarXtrS); break;
                    case 20: ini_inv(WarXtrT); break;
                    case 21: ini_inv(WarXtrU); break;
		    default: break;
		}
		ini_inv(Warrior);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 63:
		ini_inv(DollMistress);

		break;

	case 64:
		ini_inv(MahouShoujo);

		break;

	case 65:
		switch (rnd(9)) {   
		    case 1: Priest[P_BOOK].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Priest[P_BOOK].trotyp = SPE_SLEEP; break;
		    case 3: Priest[P_BOOK].trotyp = SPE_RESIST_POISON; break;
		    case 4: Priest[P_BOOK].trotyp = SPE_RESIST_SLEEP; break;
		    case 5: Priest[P_BOOK].trotyp = SPE_DETECT_FOOD; break;
		    case 6: Priest[P_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: Priest[P_BOOK].trotyp = SPE_LIGHT; break;
		    case 8: Priest[P_BOOK].trotyp = SPE_KNOCK; break;
		    case 9: Priest[P_BOOK].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		ini_inv(Priest);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		spellbook_skill_raise(Skill_P, Priest[P_BOOK].trotyp);
		/* KMH, conduct --
		 * Some may claim that this isn't agnostic, since they
		 * are literally "priests" and they have holy water.
		 * But we don't count it as such.  Purists can always
		 * avoid playing priests and/or confirm another player's
		 * role in their YAAP.
		 */
		break;
	case 66:
		ini_inv(Chevalier);
		if(!rn2(10)) ini_inv(Magicmarker);
		else if(!rn2(10)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_object(POT_WATER);
		break;
	case 67:
		Ranger[RAN_TWO_ARROWS].trquan = rn1(10, 50);
		Ranger[RAN_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Ranger);
		break;
	case 68:
		Elph[ELP_TWO_ARROWS].trquan = rn1(10, 50);
		Elph[ELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Elph);

	    /* Elves can recognize all elvish objects */
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);

		break;
	case 69:
		ini_inv(Transvestite);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 70:
		ini_inv(Topmodel);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;

	case 71:
		ini_inv(Bully);

		if (rn2(5)) ini_inv(BullyA);
		if (rn2(2)) ini_inv(BullyB);
		if (!rn2(20)) ini_inv(Candle);
		if (!rn2(20)) ini_inv(BullyD);
		if (!rn2(20)) ini_inv(BullyE);

		break;

	case 72:

		ini_inv(Pickpocket);
		knows_classX(GEM_CLASS);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = 200;
#else
		u.umoney0 = 200;
#endif

		break;

	case 73:
		Rogue[R_DAGGERS].trquan = rn1(10, 6);
		Rogue[R_DARTS].trquan = rn1(10, 25);
		if (rn2(100) < 30) {
			Rogue[R_DAGGERS].trotyp = PISTOL;
			Rogue[R_DAGGERS].trquan = 1;
			Rogue[R_DARTS].trotyp = PISTOL_BULLET;
		}
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500 ,1500);
#else
		u.umoney0 = rn1(500 ,1500);
#endif
		ini_inv(Rogue);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_object(OILSKIN_SACK);
		break;

	case 74:

		if (!rn2(20)) ini_inv(InvisibilityRing);
		ini_inv(Assassin);
		break;

	case 75:
		knows_class(WEAPON_CLASS);
		ini_inv(Ninja);
		break;

	case 76:
		ini_inv(Drunk);
		break;

	case 77:
		ini_inv(Officer);
		break;

	case 78:
		ini_inv(Undertaker);
		break;

	case 79:
		ini_inv(Musician);
		break;

	case 80:
		ini_inv(Zookeeper);
		break;

	case 81:
		ini_inv(Firefighter);
		break;

	case 82:
		ini_inv(Locksmith);
		break;

	case 83:
		Samurai[S_ARROWS].trquan = rn1(20, 26);
		ini_inv(Samurai);
		if(!rn2(5)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 84:
		ini_inv(Otaku);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(500);
#else
		u.umoney0 = rnd(500);
#endif

		break;

	case 85:
		Tourist[T_DARTS].trquan = rn1(20, 21);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rn1(500,1000);
#else
		u.umoney0 = rn1(500,1000);
#endif
		ini_inv(Tourist);
		if(!rn2(25)) ini_inv(Tinopener);
		else if(!rn2(25)) ini_inv(Leash);
		else if(!rn2(25)) ini_inv(Towel);
		else if(!rn2(25)) ini_inv(Magicmarker);
		break;
	case 86:
		switch (rn2(100) / 25) {
		    case 0:	/* Pistol and silver bullets */
			UndeadSlayer[U_MINOR].trotyp = PISTOL;
			UndeadSlayer[U_RANGE].trotyp = SILVER_PISTOL_BULLET;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			break;
		    case 1:	/* Crossbow and bolts */
			UndeadSlayer[U_MINOR].trotyp = CROSSBOW;
			UndeadSlayer[U_RANGE].trotyp = CROSSBOW_BOLT;
			UndeadSlayer[U_RANGE].trquan = rn1(10, 30);
			UndeadSlayer[U_MISC].trotyp = LOW_BOOTS;
			UndeadSlayer[U_MISC].trspe = 1;
			UndeadSlayer[U_ARMOR].trotyp = LEATHER_JACKET;
			UndeadSlayer[U_ARMOR].trspe = 1;
			/* helmet & armour are no longer candidates for
			 * substitution for orcish versions so no extra
			 * food should be given in compensation.
			 */
			if (Race_if(PM_ORC))
			    no_extra_food = TRUE;
		        break;
		    case 2:	/* Whip and daggers */
		        UndeadSlayer[U_MINOR].trotyp = BULLWHIP;
		        UndeadSlayer[U_MINOR].trspe = 2;
		        break;
		    case 3:	/* Silver spear and daggers */
			break;
		}
		ini_inv(UndeadSlayer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		if(!rn2(6)) ini_inv(Lamp);
		break;
	case 87:
		ini_inv(Valkyrie);
		if(!rn2(6)) 
		  (rn2(100) > 50 ? ini_inv(Lamp) : ini_inv(Torch));
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;
	case 88:
		switch (rnd(2)) {                
		    case 1: Wizard[W_BOOK1].trotyp = SPE_MAGIC_BOLT; break;
		    case 2: Wizard[W_BOOK1].trotyp = SPE_SLEEP; break;
		    default: break;
		}
		switch (rnd(2)) {
		    case 1: Wizard[W_BOOK2].trotyp = SPE_RESIST_POISON; break;
		    case 2: Wizard[W_BOOK2].trotyp = SPE_RESIST_SLEEP; break;
		    default: break;
		}
		switch (rnd(5)) {   
		    case 1: Wizard[W_BOOK3].trotyp = SPE_DETECT_FOOD; break;
		    case 2: Wizard[W_BOOK3].trotyp = SPE_DETECT_MONSTERS; break;
		    case 3: Wizard[W_BOOK3].trotyp = SPE_LIGHT; break;
		    case 4: Wizard[W_BOOK3].trotyp = SPE_KNOCK; break;
		    case 5: Wizard[W_BOOK3].trotyp = SPE_WIZARD_LOCK; break;
		    default: break;
		}
		switch (rnd(9)) {
		    case 1: Wizard[W_BOOK4].trotyp = SPE_MAGIC_MISSILE; break;
		    case 2: Wizard[W_BOOK4].trotyp = SPE_CONFUSE_MONSTER; break;
		    case 3: Wizard[W_BOOK4].trotyp = SPE_SLOW_MONSTER; break;
		    case 4: Wizard[W_BOOK4].trotyp = SPE_CURE_BLINDNESS; break;
		    case 5: Wizard[W_BOOK4].trotyp = SPE_ENDURE_HEAT; break;
		    case 6: Wizard[W_BOOK4].trotyp = SPE_ENDURE_COLD; break;
		    case 7: Wizard[W_BOOK4].trotyp = SPE_INSULATE; break;
		    case 8: Wizard[W_BOOK4].trotyp = SPE_CREATE_MONSTER; break;
		    case 9: Wizard[W_BOOK4].trotyp = SPE_HEALING; break;
		    default: break;
		}
		ini_inv(Wizard);
		knows_classX(SPBOOK_CLASS);
		if(!rn2(5)) ini_inv(Magicmarker);
		if(!rn2(5)) ini_inv(Blindfold);
		break;

	case 89:

		ini_inv(Sage);
		if(!rn2(3)) ini_inv(Magicmarker);

		break;

	case 90:
		ini_inv(Yeoman);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 91:
		ini_inv(Failed_Existence);
	      u.uhunger = 550;  /* They don't eat much --Amy */
		break;

	case 92:
		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_ONE].trotyp = HELM_OF_THIRST; Murderer[M_ITEM_ONE].trspe = 3; break;
			case 2: Murderer[M_ITEM_ONE].trotyp = HELM_OF_BAD_ALIGNMENT; Murderer[M_ITEM_ONE].trspe = 0; break;
			default: break;
		}

		switch (rnd(5)) {                
			case 1: Murderer[M_ITEM_TWO].trotyp = GAUNTLETS_OF_TRAP_CREATION; Murderer[M_ITEM_TWO].trspe = 0; break;
			case 2: 
			case 3:
			case 4:
			case 5: Murderer[M_ITEM_TWO].trotyp = UNDROPPABLE_GLOVES; Murderer[M_ITEM_TWO].trspe = 2; break;
			default: break;
		}

		switch (rnd(11)) {                
			case 1: Murderer[M_ITEM_THREE].trotyp = STONE_OF_MAGIC_RESISTANCE; break;
			case 2: Murderer[M_ITEM_THREE].trotyp = SHADES_OF_GREY_STONE; break;
			case 3: Murderer[M_ITEM_THREE].trotyp = DSTW_STONE; break;
			case 4: Murderer[M_ITEM_THREE].trotyp = CONFUSION_STONE; break;
			case 5: Murderer[M_ITEM_THREE].trotyp = STONE_OF_INTRINSIC_LOSS; break;
			case 6: Murderer[M_ITEM_THREE].trotyp = ALIGNMENT_STONE; break;
			case 7: Murderer[M_ITEM_THREE].trotyp = TRAP_CREATION_STONE; break;
			case 8: Murderer[M_ITEM_THREE].trotyp = STONE_OF_VULNERABILITY; break;
			case 9: Murderer[M_ITEM_THREE].trotyp = STONE_OF_CURSING; break;
			case 10: Murderer[M_ITEM_THREE].trotyp = STATUS_STONE; break;
			case 11: Murderer[M_ITEM_THREE].trotyp = DEAFNESS_STONE; break;
			default: break;
		}

		switch (rnd(2)) {                
			case 1: Murderer[M_ITEM_FOUR].trotyp = TINNING_KIT; break;
			case 2: Murderer[M_ITEM_FOUR].trotyp = CAN_OF_GREASE; break;
			default: break;
		}

	        ini_inv(Murderer);
		  increasesincounter(16); /* You have sinned */
		  u.alignlim -= 16;
	        u.uhunger = 550;  /* On the verge of hungry */
	        urace.hatemask |= urace.lovemask;   /* Hated by the race's allies */
	        urace.lovemask = 0; /* Murderers are pariahs of their race */
		    change_luck(-1); /* both their alignment and luck start out negative */
		break;

	case 93:
		ini_inv(Camperstriker);
		break;

	case 94:

		ini_inv(DQSlime);
		break;

	case 95:

		ini_inv(Erdrick);
		if (!rn2(4)) ini_inv(ErdrickKey);
		break;

	case 96:
		Twelph[TWELP_TWO_ARROWS].trquan = rn1(10, 50);
		Twelph[TWELP_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Twelph);

	    /* Elves can recognize all elvish objects */
	    knows_object(DARK_ELVEN_SHORT_SWORD);
	    knows_object(DARK_ELVEN_ARROW);
	    knows_object(DARK_ELVEN_BOW);
	    knows_object(DARK_ELVEN_DAGGER);
	    knows_object(DARK_ELVEN_MITHRIL_COAT);

		break;

	case 97:

		ini_inv(Golddigger);

		 knows_object(GNOMISH_HELM);
		 knows_object(GNOMISH_BOOTS);
		 knows_object(GNOMISH_SUIT);
		 knows_object(AKLYS);

#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(1000);
#else
		u.umoney0 = rnd(1000);
#endif

		break;

	case 98:

		ini_inv(Ringseeker);

		break;

	case 99:

		ini_inv(Midget);
	    knows_object(DWARVISH_SPEAR);
	    knows_object(DWARVISH_SHORT_SWORD);
	    knows_object(DWARVISH_MATTOCK);
	    knows_object(DWARVISH_IRON_HELM);
	    knows_object(DWARVISH_MITHRIL_COAT);
	    knows_object(DWARVISH_CLOAK);
	    knows_object(DWARVISH_ROUNDSHIELD);

		break;

	case 100:

		ini_inv(Shapeshifter);

		break;

	case 101:

		ini_inv(Anachronist);

		break;

	case 102:

		ini_inv(Druid);
		break;

	case 103:
		ini_inv(DoomMarine);
		break;

	case 104:
		ini_inv(Fighter);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 105:
		ini_inv(Fencer);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 106:
		Medium[MED_TWO_ARROWS].trquan = rn1(10, 50);
		Medium[MED_ZERO_ARROWS].trquan = rn1(10, 30);
		ini_inv(Medium);
		break;

	case 107:
		ini_inv(Sexymate);
		break;

	case 108:
		ini_inv(StandUser);
		break;

	case 109:
		ini_inv(JusticeKeeper);
		break;

	case 110:
		ini_inv(Poison_Mage);
		if(!rn2(5)) ini_inv(Lamp);
		else if(!rn2(5)) ini_inv(Blindfold);
		else if(!rn2(5)) ini_inv(Magicmarker);
		break;

	case 111:
		ini_inv(Transsylvanian);
		break;

	case 112:
		ini_inv(Unbeliever);
		break;

	case 113:
		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK1].trotyp = SPE_WATER_BOLT; break;
		    case 2: Elementalist[E_BOOK1].trotyp = SPE_VOLT_ROCK; break;
		    case 3: Elementalist[E_BOOK1].trotyp = SPE_WATER_FLAME; break;
		    case 4: Elementalist[E_BOOK1].trotyp = SPE_FIRE; break;
		    case 5: Elementalist[E_BOOK1].trotyp = SPE_STEAM_VENOM; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: Elementalist[E_BOOK2].trotyp = SPE_AIR_CURRENT; break;
		    case 2: Elementalist[E_BOOK2].trotyp = SPE_WIND; break;
		    case 3: Elementalist[E_BOOK2].trotyp = SPE_RAIN_CLOUD; break;
		    case 4: Elementalist[E_BOOK2].trotyp = SPE_FROST; break;
		    case 5: Elementalist[E_BOOK2].trotyp = SPE_DASHING; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK3].trotyp = SPE_POISON_BRAND; break;
		    case 2: Elementalist[E_BOOK3].trotyp = SPE_THUNDER_WAVE; break;
		    case 3: Elementalist[E_BOOK3].trotyp = SPE_ELEMENTAL_BEAM; break;
		    case 4: Elementalist[E_BOOK3].trotyp = SPE_BATTERING_RAM; break;
		    case 5: Elementalist[E_BOOK3].trotyp = SPE_POWER_FAILURE; break;
		    case 6: Elementalist[E_BOOK3].trotyp = SPE_VAPORIZE; break;
		    case 7: Elementalist[E_BOOK3].trotyp = SPE_BURROW; break;
		    case 8: Elementalist[E_BOOK3].trotyp = SPE_MELTDOWN; break;
		    default: break;
		}
		switch (rnd(8)) {                
		    case 1: Elementalist[E_BOOK4].trotyp = SPE_CLOUDS; break;
		    case 2: Elementalist[E_BOOK4].trotyp = SPE_ICE; break;
		    case 3: Elementalist[E_BOOK4].trotyp = SPE_FLOOD; break;
		    case 4: Elementalist[E_BOOK4].trotyp = SPE_DRIPPING_TREAD; break;
		    case 5: Elementalist[E_BOOK4].trotyp = SPE_GEOLYSIS; break;
		    case 6: Elementalist[E_BOOK4].trotyp = SPE_LAVA; break;
		    case 7: Elementalist[E_BOOK4].trotyp = SPE_IRON_PRISON; break;
		    case 8: Elementalist[E_BOOK4].trotyp = SPE_LOCKOUT; break;
		    case 9: Elementalist[E_BOOK4].trotyp = SPE_GROW_TREES; break;
		    default: break;
		}
		switch (rnd(4)) {                
		    case 1: Elementalist[E_WAND].trotyp = WAN_FIRE; break;
		    case 2: Elementalist[E_WAND].trotyp = WAN_COLD; break;
		    case 3: Elementalist[E_WAND].trotyp = WAN_LIGHTNING; break;
		    case 4: Elementalist[E_WAND].trotyp = WAN_POISON; break;
		    default: break;
		}

		ini_inv(Elementalist);
		break;

	case 114:
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK1].trotyp = SPE_LINE_LOSS; break;
		    case 2: ChaosSorceror[C_BOOK1].trotyp = SPE_PET_SYRINGE; break;
		    case 3: ChaosSorceror[C_BOOK1].trotyp = SPE_CURE_RANDOM_STATUS; break;
		    case 4: ChaosSorceror[C_BOOK1].trotyp = SPE_BERSERK; break;
		    case 5: ChaosSorceror[C_BOOK1].trotyp = SPE_RESIST_RANDOM_ELEMENT; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK2].trotyp = SPE_LOCK_MANIPULATION; break;
		    case 2: ChaosSorceror[C_BOOK2].trotyp = SPE_RANDOM_SPEED; break;
		    case 3: ChaosSorceror[C_BOOK2].trotyp = SPE_CHAOS_BOLT; break;
		    case 4: ChaosSorceror[C_BOOK2].trotyp = SPE_BUC_RANDOMIZATION; break;
		    case 5: ChaosSorceror[C_BOOK2].trotyp = SPE_RUSSIAN_ROULETTE; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK3].trotyp = SPE_LYCANTHROPY; break;
		    case 2: ChaosSorceror[C_BOOK3].trotyp = SPE_BOMBING; break;
		    case 3: ChaosSorceror[C_BOOK3].trotyp = SPE_VANISHING; break;
		    case 4: ChaosSorceror[C_BOOK3].trotyp = SPE_EARTHQUAKE; break;
		    case 5: ChaosSorceror[C_BOOK3].trotyp = SPE_POLYFORM; break;
		    default: break;
		}
		switch (rnd(5)) {
		    case 1: ChaosSorceror[C_BOOK4].trotyp = SPE_SELFDESTRUCT; break;
		    case 2: ChaosSorceror[C_BOOK4].trotyp = SPE_THRONE_GAMBLE; break;
		    case 3: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION; break;
		    case 4: ChaosSorceror[C_BOOK4].trotyp = SPE_DISINTEGRATION_BEAM; break;
		    case 5: ChaosSorceror[C_BOOK4].trotyp = SPE_REROLL_ARTIFACT; break;
		    default: break;
		}

		ini_inv(ChaosSorceror);
		break;

	case 115:
		ini_inv(WildTalent);
		break;

	case 116:
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK1].trotyp = SPE_PREACHING; break;
		    case 2: OccultMaster[O_BOOK1].trotyp = SPE_STRANGLING; break;
		    case 3: OccultMaster[O_BOOK1].trotyp = SPE_MIMICRY; break;
		    case 4: OccultMaster[O_BOOK1].trotyp = SPE_MANA_BATTERY; break;
		    case 5: OccultMaster[O_BOOK1].trotyp = SPE_RESIST_PARALYSIS; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK2].trotyp = SPE_SPELLBINDER; break;
		    case 2: OccultMaster[O_BOOK2].trotyp = SPE_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_BOOK2].trotyp = SPE_TRACKER; break;
		    case 4: OccultMaster[O_BOOK2].trotyp = SPE_TOTEM_SUMMONING; break;
		    case 5: OccultMaster[O_BOOK2].trotyp = SPE_POSSESSION; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK3].trotyp = SPE_CODE_EDITING; break;
		    case 2: OccultMaster[O_BOOK3].trotyp = SPE_SATISFY_HUNGER; break;
		    case 3: OccultMaster[O_BOOK3].trotyp = SPE_FIRE_GOLEM; break;
		    case 4: OccultMaster[O_BOOK3].trotyp = SPE_DISRUPTION_SHIELD; break;
		    case 5: OccultMaster[O_BOOK3].trotyp = SPE_BLINDING_RAY; break;
		    default: break;
		}
		switch (rnd(5)) {                
		    case 1: OccultMaster[O_BOOK4].trotyp = SPE_COMMAND_DEMON; break;
		    case 2: OccultMaster[O_BOOK4].trotyp = SPE_REDEMPTION; break;
		    case 3: OccultMaster[O_BOOK4].trotyp = SPE_NEXUS_FIELD; break;
		    case 4: OccultMaster[O_BOOK4].trotyp = SPE_PHASE_DOOR; break;
		    case 5: OccultMaster[O_BOOK4].trotyp = SPE_HORRIFY; break;
		    default: break;
		}
		switch (rnd(3)) {                
		    case 1: OccultMaster[O_WAND].trotyp = WAN_SPELLBINDER; break;
		    case 2: OccultMaster[O_WAND].trotyp = WAN_INERTIA_CONTROL; break;
		    case 3: OccultMaster[O_WAND].trotyp = WAN_STERILIZE; break;
		    default: break;
		}

		ini_inv(OccultMaster);
		break;

	case 117:

		ini_inv(Prostitute);
		if(!rn2(10)) ini_inv(Condome);
		break;

	case 118:

		ini_inv(Kurwa);
		break;

	case 119:
		ini_inv(Feminist);

		break;

	case 120:
		ini_inv(Tracer);

		break;

	case 121:
		ini_inv(NuclearPhysicist);

		break;

	case 122:
		ini_inv(FormChanger);

		break;

	case 123:

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_WEAPON].trotyp = DAGGER; break;
		    case 2: GangScholar[GSC_WEAPON].trotyp = MACE; break;
		    case 3: GangScholar[GSC_WEAPON].trotyp = MORNING_STAR; break;
		    case 4: GangScholar[GSC_WEAPON].trotyp = SHORT_SWORD; break;
		    case 5: GangScholar[GSC_WEAPON].trotyp = FLAIL; break;
		    case 6: GangScholar[GSC_WEAPON].trotyp = TWO_HANDED_SWORD; break;
		    case 7: GangScholar[GSC_WEAPON].trotyp = SPEAR; break;
		    case 8: GangScholar[GSC_WEAPON].trotyp = QUARTERSTAFF; break;
		    case 9: GangScholar[GSC_WEAPON].trotyp = LONG_SWORD; break;
		    case 10: GangScholar[GSC_WEAPON].trotyp = BROADSWORD; break;
		    case 11: GangScholar[GSC_WEAPON].trotyp = CLUB; break;
		    default: break;
		}

		switch (rnd(9)) {
		    case 1: GangScholar[GSC_ARMOR].trotyp = LEATHER_ARMOR; break;
		    case 2: GangScholar[GSC_ARMOR].trotyp = YELLOW_DRAGON_SCALES; break;
		    case 3: GangScholar[GSC_ARMOR].trotyp = RING_MAIL; break;
		    case 4: GangScholar[GSC_ARMOR].trotyp = SCALE_MAIL; break;
		    case 5: GangScholar[GSC_ARMOR].trotyp = CHAIN_MAIL; break;
		    case 6: GangScholar[GSC_ARMOR].trotyp = SPLINT_MAIL; break;
		    case 7: GangScholar[GSC_ARMOR].trotyp = PLATE_MAIL; break;
		    case 8: GangScholar[GSC_ARMOR].trotyp = STUDDED_LEATHER_ARMOR; break;
		    case 9: GangScholar[GSC_ARMOR].trotyp = ELVEN_MITHRIL_COAT; break;
		}

		switch (rnd(8)) {
		    case 1: GangScholar[GSC_RING].trotyp = RIN_ADORNMENT; break;
		    case 2: GangScholar[GSC_RING].trotyp = RIN_PROTECTION; break;
		    case 3: GangScholar[GSC_RING].trotyp = RIN_GAIN_CONSTITUTION; break;
		    case 4: GangScholar[GSC_RING].trotyp = RIN_GAIN_DEXTERITY; break;
		    case 5: GangScholar[GSC_RING].trotyp = RIN_GAIN_INTELLIGENCE; break;
		    case 6: GangScholar[GSC_RING].trotyp = RIN_GAIN_STRENGTH; break;
		    case 7: GangScholar[GSC_RING].trotyp = RIN_INCREASE_ACCURACY; break;
		    case 8: GangScholar[GSC_RING].trotyp = RIN_INCREASE_DAMAGE; break;
		}

		switch (rnd(11)) {
		    case 1: GangScholar[GSC_POTION].trotyp = POT_HEALING; break;
		    case 2: GangScholar[GSC_POTION].trotyp = POT_EXTRA_HEALING; break;
		    case 3: GangScholar[GSC_POTION].trotyp = POT_GAIN_ENERGY; break;
		    case 4: GangScholar[GSC_POTION].trotyp = POT_BANISHING_FEAR; break;
		    case 5: GangScholar[GSC_POTION].trotyp = POT_MONSTER_DETECTION; break;
		    case 6: GangScholar[GSC_POTION].trotyp = POT_OBJECT_DETECTION; break;
		    case 7: GangScholar[GSC_POTION].trotyp = POT_LEVITATION; break;
		    case 8: GangScholar[GSC_POTION].trotyp = POT_SPEED; break;
		    case 9: GangScholar[GSC_POTION].trotyp = POT_GAIN_ABILITY; break;
		    case 10: GangScholar[GSC_POTION].trotyp = POT_GAIN_LEVEL; break;
		    case 11: GangScholar[GSC_POTION].trotyp = POT_WATER; break;
		}

		switch (rnd(13)) {
		    case 1: GangScholar[GSC_SCROLL].trotyp = SCR_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_SCROLL].trotyp = SCR_SUMMON_UNDEAD; break;
		    case 3: GangScholar[GSC_SCROLL].trotyp = SCR_LIGHT; break;
		    case 4: GangScholar[GSC_SCROLL].trotyp = SCR_IDENTIFY; break;
		    case 5: GangScholar[GSC_SCROLL].trotyp = SCR_MAGIC_MAPPING; break;
		    case 6: GangScholar[GSC_SCROLL].trotyp = SCR_REMOVE_CURSE; break;
		    case 7: GangScholar[GSC_SCROLL].trotyp = SCR_TELEPORTATION; break;
		    case 8: GangScholar[GSC_SCROLL].trotyp = SCR_HEALING; break;
		    case 9: GangScholar[GSC_SCROLL].trotyp = SCR_PHASE_DOOR; break;
		    case 10: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_DETECTION; break;
		    case 11: GangScholar[GSC_SCROLL].trotyp = SCR_TRAP_CREATION; break;
		    case 12: GangScholar[GSC_SCROLL].trotyp = SCR_SLEEP; break;
		    case 13: GangScholar[GSC_SCROLL].trotyp = SCR_BLANK_PAPER; break;
		}

		switch (rnd(26)) {
		    case 1: GangScholar[GSC_WAND].trotyp = WAN_LIGHT; break;
		    case 2: GangScholar[GSC_WAND].trotyp = WAN_NOTHING; break;
		    case 3: GangScholar[GSC_WAND].trotyp = WAN_HEALING; break;
		    case 4: GangScholar[GSC_WAND].trotyp = WAN_IDENTIFY; break;
		    case 5: GangScholar[GSC_WAND].trotyp = WAN_REMOVE_CURSE; break;
		    case 6: GangScholar[GSC_WAND].trotyp = WAN_ENTRAPPING; break;
		    case 7: GangScholar[GSC_WAND].trotyp = WAN_TRAP_CREATION; break;
		    case 8: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MAPPING; break;
		    case 9: GangScholar[GSC_WAND].trotyp = WAN_DETECT_MONSTERS; break;
		    case 10: GangScholar[GSC_WAND].trotyp = WAN_OBJECTION; break;
		    case 11: GangScholar[GSC_WAND].trotyp = WAN_SLOW_MONSTER; break;
		    case 12: GangScholar[GSC_WAND].trotyp = WAN_SPEED_MONSTER; break;
		    case 13: GangScholar[GSC_WAND].trotyp = WAN_HASTE_MONSTER; break;
		    case 14: GangScholar[GSC_WAND].trotyp = WAN_CREATE_MONSTER; break;
		    case 15: GangScholar[GSC_WAND].trotyp = WAN_SUMMON_UNDEAD; break;
		    case 16: GangScholar[GSC_WAND].trotyp = WAN_POLYMORPH; break;
		    case 17: GangScholar[GSC_WAND].trotyp = WAN_TELEPORTATION; break;
		    case 18: GangScholar[GSC_WAND].trotyp = WAN_BANISHMENT; break;
		    case 19: GangScholar[GSC_WAND].trotyp = WAN_EXTRA_HEALING; break;
		    case 20: GangScholar[GSC_WAND].trotyp = WAN_FULL_HEALING; break;
		    case 21: GangScholar[GSC_WAND].trotyp = WAN_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_WAND].trotyp = WAN_FIRE; break;
		    case 23: GangScholar[GSC_WAND].trotyp = WAN_COLD; break;
		    case 24: GangScholar[GSC_WAND].trotyp = WAN_SLEEP; break;
		    case 25: GangScholar[GSC_WAND].trotyp = WAN_LIGHTNING; break;
		    case 26: GangScholar[GSC_WAND].trotyp = WAN_FIREBALL; break;
		}

		switch (rnd(25)) {
		    case 1: GangScholar[GSC_BOOK].trotyp = SPE_CREATE_MONSTER; break;
		    case 2: GangScholar[GSC_BOOK].trotyp = SPE_HEALING; break;
		    case 3: GangScholar[GSC_BOOK].trotyp = SPE_EXTRA_HEALING; break;
		    case 4: GangScholar[GSC_BOOK].trotyp = SPE_LIGHT_AREA; break;
		    case 5: GangScholar[GSC_BOOK].trotyp = SPE_CLAIRVOYANCE; break;
		    case 6: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_MONSTERS; break;
		    case 7: GangScholar[GSC_BOOK].trotyp = SPE_DETECT_TREASURE; break;
		    case 8: GangScholar[GSC_BOOK].trotyp = SPE_IDENTIFY; break;
		    case 9: GangScholar[GSC_BOOK].trotyp = SPE_ENTRAPPING; break;
		    case 10: GangScholar[GSC_BOOK].trotyp = SPE_SLOW_MONSTER; break;
		    case 11: GangScholar[GSC_BOOK].trotyp = SPE_PROTECTION; break;
		    case 12: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_COLD; break;
		    case 13: GangScholar[GSC_BOOK].trotyp = SPE_ENDURE_HEAT; break;
		    case 14: GangScholar[GSC_BOOK].trotyp = SPE_INSULATE; break;
		    case 15: GangScholar[GSC_BOOK].trotyp = SPE_REMOVE_CURSE; break;
		    case 16: GangScholar[GSC_BOOK].trotyp = SPE_LEVITATION; break;
		    case 17: GangScholar[GSC_BOOK].trotyp = SPE_TELEPORT_AWAY; break;
		    case 18: GangScholar[GSC_BOOK].trotyp = SPE_POLYMORPH; break;
		    case 19: GangScholar[GSC_BOOK].trotyp = SPE_FIRE_BOLT; break;
		    case 20: GangScholar[GSC_BOOK].trotyp = SPE_PHASE_DOOR; break;
		    case 21: GangScholar[GSC_BOOK].trotyp = SPE_MAGIC_MISSILE; break;
		    case 22: GangScholar[GSC_BOOK].trotyp = SPE_FIREBALL; break;
		    case 23: GangScholar[GSC_BOOK].trotyp = SPE_CONE_OF_COLD; break;
		    case 24: GangScholar[GSC_BOOK].trotyp = SPE_SLEEP; break;
		    case 25: GangScholar[GSC_BOOK].trotyp = SPE_LIGHTNING; break;
		}

		ini_inv(GangScholar);

		break;

	case 124:
		ini_inv(Hussy);
		break;

	case 125:
		ini_inv(Mason);
		break;

	case 126:

		switch (rnd(20)) {
		    case 1: Acu[ACUWEAPON].trotyp = DAGGER; break;
		    case 2: Acu[ACUWEAPON].trotyp = KNIFE; break;
		    case 3: Acu[ACUWEAPON].trotyp = AXE; break;
		    case 4: Acu[ACUWEAPON].trotyp = SHORT_SWORD; break;
		    case 5: Acu[ACUWEAPON].trotyp = PAPER_SWORD; break;
		    case 6: Acu[ACUWEAPON].trotyp = SUGUHANOKEN; break;
		    case 7: Acu[ACUWEAPON].trotyp = SCIMITAR; break;
		    case 8: Acu[ACUWEAPON].trotyp = RAPIER; break;
		    case 9: Acu[ACUWEAPON].trotyp = CLUB; break;
		    case 10: Acu[ACUWEAPON].trotyp = FLY_SWATTER; break;
		    case 11: Acu[ACUWEAPON].trotyp = MACE; break;
		    case 12: Acu[ACUWEAPON].trotyp = MORNING_STAR; break;
		    case 13: Acu[ACUWEAPON].trotyp = FLAIL; break;
		    case 14: Acu[ACUWEAPON].trotyp = WAR_HAMMER; break;
		    case 15: Acu[ACUWEAPON].trotyp = SICKLE; break;
		    case 16: Acu[ACUWEAPON].trotyp = SPEAR; break;
		    case 17: Acu[ACUWEAPON].trotyp = JAVELIN; break;
		    case 18: Acu[ACUWEAPON].trotyp = TRIDENT; break;
		    case 19: Acu[ACUWEAPON].trotyp = LANCE; break;
		    case 20: Acu[ACUWEAPON].trotyp = BULLWHIP; break;
		}

		ini_inv(Acu);
		break;

	case 127:
		ini_inv(Grenadonin);
		break;

	case 128:
		ini_inv(Demagogue);
		break;

	case 129:
		ini_inv(Walscholar);
		break;

	case 130:
		ini_inv(SocialJusticeWarrior);
		break;

	case 131:
		ini_inv(CellarChild);
		break;

	case 132:
		ini_inv(SoftwareEngineer);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(200);
#else
		u.umoney0 = rnd(200);
#endif

		break;

	case 133:
		ini_inv(Cracker);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 134:
		ini_inv(Janitor);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 135:
		ini_inv(SpaceMarine);
		break;

	case 136:
		ini_inv(Stormboy);
		break;

	case 137:
		ini_inv(Yautja);
		break;

	case 138:
		ini_inv(Quarterback);
		break;

	case 139:
		ini_inv(Psyker);
		break;

	case 140:
		ini_inv(Empath);
		break;

	case 141:
		ini_inv(Mastermind);
		break;

	case 142:
		ini_inv(Weirdboy);
		break;

	case 143:
		ini_inv(Astronaut);
		break;

	case 144:
		ini_inv(Cyberninja);
		break;

	case 145:
		ini_inv(Dissident);
		break;

	case 146:
		ini_inv(XelNaga);
		break;

	case 147:
		ini_inv(Cartomancer);
		break;

	case 148:
		ini_inv(Dragonmaster);
		break;

	case 149:
		ini_inv(Combatant);
		break;

	case 150:
		ini_inv(Fjorde);
		break;

	case 151:
		ini_inv(Practicant);
#ifndef GOLDOBJ
		u.ugold = u.ugold0 = rnd(100);
#else
		u.umoney0 = rnd(100);
#endif
		break;

	case 152:
		Emera[EMERA_FLINT].trquan = 50 + rnd(50);
		ini_inv(Emera);
		break;

	case 153:
		ini_inv(Tosser);
		break;

	case 154:
		ini_inv(Aklyst);
		break;

	case 155:
		MillSwallower[MS_BOLTS].trquan = 20 + rnd(40);
		ini_inv(MillSwallower);
		break;

	case 156:
		ini_inv(Symbiant);
		break;

	case 157:
		ini_inv(Genderstarist);
		break;

	case 158:
		ini_inv(ButtLover);
		break;

	case 159:
		ini_inv(Dancer);
		break;

	case 160:
		ini_inv(Diablist);
		break;

	case 161:
		ini_inv(Preversioner);
		break;

	case 162:
		ini_inv(SecretAdviceMember);
		break;

	case 163:
		ini_inv(ShoeFetishist);
		break;

	case 164:
		switch (rn2(90) / 30) {
		case 0: HalfBaked[HBA_BOOK].trotyp = SPE_HEALING; break;
		case 1: HalfBaked[HBA_BOOK].trotyp = SPE_PROTECTION; break;
		case 2: HalfBaked[HBA_BOOK].trotyp = SPE_SLEEP; break;
		}
		ini_inv(HalfBaked);
		if(!rn2(5)) ini_inv(Magicmarker);
		else if(!rn2(10)) ini_inv(Lamp);
		knows_class(ARMOR_CLASS);
		break;

	case 165:
		if (rn2(100) >= 50) {   /* see Elf comment */
		    NoobModeBarb[N_MAJOR].trotyp = BATTLE_AXE;
		    NoobModeBarb[N_MINOR].trotyp = SHORT_SWORD;
		}
		ini_inv(NoobModeBarb);
		break;

	case 166:
		ini_inv(Climacterial);
		break;

	case 167:
		Womanizer[WOMGEM].trotyp = rnd_class(ELIF_S_JEWEL, DORA_S_JEWEL);
		ini_inv(Womanizer);
		break;

	case 168:
		ini_inv(Singslave);
		break;

	case 169:
		ini_inv(Jedi);
		ini_inv(GreenSaber);
		ini_inv(YellowSaber);
		ini_inv(WhiteDoubleSaber);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 170:
		ini_inv(VanillaValk);
		if(!rn2(6)) ini_inv(Lamp);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 171:
		ini_inv(ShadowJedi);
		if(!rn2(2)) ini_inv(Blindfold);
		knows_class(WEAPON_CLASS);
		knows_class(ARMOR_CLASS);
		break;

	case 172:
		ini_inv(Jockey);
		break;

	case 173:

		ini_inv(Alltecher);
		break;

	case 174:

		ini_inv(Spellmaster);
		break;

	default:	/* impossible */
		break;
	}

	xtraskillinit();	/* so you actually get the skills of those objects --Amy */

	} /* bastard only */

	/*** Race-specific initializations ***/
	switch (Race_switch) {
	case PM_HUMAN:
	    /* Nothing special */
	    break;

	case PM_INKA:
		ini_inv(Inka_spellbook);
	    break;

	case PM_ELF:
	    /*
	     * Elves are people of music and song, or they are warriors.
	     * Non-warriors get an instrument.  We use a kludge to
	     * get only non-magic instruments.
	     */
	    if (Role_if(PM_PRIEST) || Role_if(PM_WIZARD)) {
		static int trotyp[] = {
		    WOODEN_FLUTE, TOOLED_HORN, WOODEN_HARP,
		    BELL, BUGLE, LEATHER_DRUM
		};
		Instrument[0].trotyp = trotyp[rn2(SIZE(trotyp))];
		ini_inv(Instrument);
	    }

	    /* Elves can recognize all elvish objects */
	    knows_object(ELVEN_SHORT_SWORD);
	    knows_object(ELVEN_ARROW);
	    knows_object(ELVEN_BOW);
	    knows_object(ELVEN_SPEAR);
	    knows_object(ELVEN_DAGGER);
	    knows_object(ELVEN_BROADSWORD);
	    knows_object(ELVEN_MITHRIL_COAT);
	    knows_object(ELVEN_LEATHER_HELM);
	    knows_object(ELVEN_SHIELD);
	    knows_object(ELVEN_BOOTS);
	    knows_object(ELVEN_CLOAK);
	    break;
	case PM_DROW:
	    /* Drows can recognize all droven objects */
	    knows_object(DARK_ELVEN_SHORT_SWORD);
	    knows_object(DARK_ELVEN_ARROW);
	    knows_object(DARK_ELVEN_BOW);
	    knows_object(DARK_ELVEN_DAGGER);
	    knows_object(DARK_ELVEN_MITHRIL_COAT);
	    break;

	case PM_DWARF:
	    /* Dwarves can recognize all dwarvish objects */
	    knows_object(DWARVISH_SPEAR);
	    knows_object(DWARVISH_SHORT_SWORD);
	    knows_object(DWARVISH_MATTOCK);
	    knows_object(DWARVISH_IRON_HELM);
	    knows_object(DWARVISH_MITHRIL_COAT);
	    knows_object(DWARVISH_CLOAK);
	    knows_object(DWARVISH_ROUNDSHIELD);
	    break;

	case PM_GNOME:
		 /* Gnomes don't see how silly they really look */
		 knows_object(GNOMISH_HELM);
		 knows_object(GNOMISH_BOOTS);
		 knows_object(GNOMISH_SUIT);
		 knows_object(AKLYS);			  /* they're all carrying one! */
	    break;
	case PM_HUMAN_WEREWOLF:
	    if (!Role_if(PM_LUNATIC)) u.ulycn = PM_WEREWOLF;
/*	    u.nv_range = 2;
	    u.uen = u.uenmax += 6;
	    ini_inv(Lycanthrope);*/
	    break;

	case PM_HUMANOID_ANGEL:

	    u.nv_range = 2;
	    break;

	case PM_AK_THIEF_IS_DEAD_:

	    u.ulycn = PM_UN_IN_PROTECT_MODE;
	    break;

	case PM_LICH_WARRIOR:

		ini_inv(LichOne);
		ini_inv(LichTwo);

	   break;
	case PM_HUMAN_WRAITH:

		ini_inv(WraithItem);

	   break;

	case PM_CUPID:

          ini_inv(CupidItem);		
		break;

	case PM_GOAULD:

          ini_inv(GoauldItem);		
		break;

	case PM_KORONST:

          ini_inv(KoronstItem);		
		break;

	case PM_ALCHEMIST:	/* a racial version of the scientist --Amy */

		knows_classX(POTION_CLASS);

          ini_inv(AlchemistItem);		
          ini_inv(AlchemistItemB);		
          ini_inv(AlchemistItemC);		
          ini_inv(AlchemistItemD);		
          ini_inv(AlchemistItemE);		
          ini_inv(AlchemistItemF);		
          ini_inv(AlchemistItemG);		
          ini_inv(AlchemistItemH);		
          ini_inv(AlchemistItemI);		
          ini_inv(AlchemistItemJ);		
          ini_inv(AlchemistItemK);		

	   break;

	case PM_ANGBANDER:

		ini_inv(AngbandItem);
		ini_inv(AngbandItemB);
		ini_inv(AngbandItemC);

	   break;

	case PM_DEATHMOLD:

		ini_inv(DeathmoldItem);

	   break;

	case PM_DUNADAN:

		ini_inv(DunadanItem);

	   break;

	case PM_THUNDERLORD:

		ini_inv(ThunderlordItem);

	   break;

	case PM_KLACKON:

		ini_inv(KlackonItem);

	   break;

	case PM_KUTAR:

		ini_inv(KutarItem);

	   break;

	case PM_BORG:

		ini_inv(BorgItems);

	   break;

	case PM_PEACEMAKER:

		ini_inv(PeacemakerItems);

	   break;

	case PM_ORC:
	    /* compensate for generally inferior equipment */
	    if (!no_extra_food && !Role_if(PM_WIZARD) &&
		    !Role_if(PM_FLAME_MAGE) && !Role_if(PM_ICE_MAGE) &&
		    !Role_if(PM_NECROMANCER))
        if (!Role_if(PM_CONVICT) && !Role_if(PM_MURDERER))
		ini_inv(Xtra_food);
	    /* Orcs can recognize all orcish objects */
	    knows_object(ORCISH_SHORT_SWORD);
	    knows_object(ORCISH_ARROW);
	    knows_object(ORCISH_BOW);
	    knows_object(ORCISH_SPEAR);
	    knows_object(ORCISH_DAGGER);
	    knows_object(ORCISH_CHAIN_MAIL);
	    knows_object(ORCISH_RING_MAIL);
	    knows_object(ORCISH_HELM);
	    knows_object(ORCISH_SHIELD);
	    knows_object(URUK_HAI_SHIELD);
	    knows_object(ORCISH_CLOAK);
	    break;
	case PM_VAMPIRE:
	    /* Vampires start off with gods not as pleased, luck penalty */
	    adjalign(-5); 
	    increasesincounter(5);
	    u.alignlim -= 5;
	    change_luck(-1);
		{
		static int trotyp[] = {POT_BLOOD, POT_VAMPIRE_BLOOD};
		Xtra_food[0].trotyp = trotyp[rn2(SIZE(trotyp))];
		ini_inv(Xtra_food);
	    }
		ini_inv(XtraRing);

		if(!rn2(5))
		{
		static int trotyp[] = {POT_BLOOD, POT_VAMPIRE_BLOOD};
		Xtra_fopod[0].trotyp = trotyp[rn2(SIZE(trotyp))];
		ini_inv(Xtra_fopod);
	    }
	    break;
	case PM_VAMGOYLE:
	    adjalign(-5);
	    increasesincounter(5);
	    u.alignlim -= 5;
	    change_luck(-1);
	    break;

	case PM_SINNER:
	    adjalign(-100);
	    increasesincounter(100);
	    u.alignlim -= 100;
	    change_luck(-1);
	    break;

	case PM_SUCKING_FIEND:
	    adjalign(-5);
	    increasesincounter(5);
	    u.alignlim -= 5;
	    change_luck(-1);

	    break;
	case PM_ALIEN: /* this is the harder than hard race, combine it with convict role for maximum torture */
	    adjalign(-20);
	    change_luck(-2);
          ini_inv(AlienItem); /* yeah its a lodestone, good luck getting rid of it! */
	    break;

	case PM_ANCIENT: /* random technique --Amy */

		learnrandomregulartech();

	    break;

	case PM_KOP:
          ini_inv(KopItemA);
	    ini_inv(KopItemB);
	    break;

	case PM_CURSER: /* starts out with cursed stuff --Amy */
		{register struct obj *obj;

		for(obj = invent; obj ; obj = obj->nobj)
			if (rn2(5))	curse(obj);
		}
		break;
	case PM_KOBOLT:
          ini_inv(KoboltItem);		
          ini_inv(KoboltItemB);		
          ini_inv(KoboltItemC);		
		HSleeping = 5;
		break;
	case PM_SWIKNI:
          ini_inv(SwikniItem);		
		break;
	case PM_LEVITATOR:
          ini_inv(LevitatorItem);		
          ini_inv(LevitatorItemB);		
          ini_inv(LevitatorItemC);		
          ini_inv(LevitatorItemD);		
          ini_inv(LevitatorItemE);		

		break;
	case PM_GASTLY:

	/* "Ghast characters no longer start with corpses. ...unless the role they're playing as starts with food rations." In Soviet Russia, ghasts are somehow the only race that's actually MORE difficult to play. The starting food is actually supposed to be helpful, since they have a hard time trying to fight starvation, so I'll have ghasts keep it unless they choose the soviet hybrid race. --Amy */
          if (!issoviet) ini_inv(GhastFood);		
		break;
	case PM_INSECTOID:
          ini_inv(InsectoidItem);
		break;
	case PM_WEAPON_TRAPPER:
          ini_inv(TrapperItem);
		break;
	case PM_NAVI:
          ini_inv(NaviItem);
		break;
	case PM_SATRE:
          ini_inv(SatreItem);
		break;
	case PM_TONBERRY:
          ini_inv(TonberryItem);
		break;
	case PM_UNGENOMOLD:
          ini_inv(UngMoldWand);
		break;
	case PM_MAIA:
          ini_inv(MaiaWand);
          ini_inv(MaiaScroll);
		break;
	case PM_STICKER:
          ini_inv(StickerItem);
		break;
	case PM_DEVELOPER:
          ini_inv(DeveloperItem);
		break;
	case PM_CLOCKWORK_AUTOMATON:
          ini_inv(AutomatonItem);
		break;
	case PM_TROLLOR:
		switch (rnd(4)) {   
                case 1: ini_inv(TrollItemA); break;
                case 2: ini_inv(TrollItemB); break;
                case 3: ini_inv(TrollItemC); break;
                case 4: ini_inv(TrollItemD); break;
		    default: break;
		}
		break;
	case PM_OGRO:
          ini_inv(OgroItem);
		break;
	case PM_NEMESIS:
          ini_inv(NemesisItem);
		break;
	case PM_HERBALIST:	/* a racial version of the healer --Amy */
          ini_inv(HerbalistItem);
          ini_inv(HerbalistItemB);
          ini_inv(HerbalistItemC);
          ini_inv(HerbalistItemD);
          ini_inv(HerbalistItemE);
          ini_inv(HerbalistItemF);
          ini_inv(HerbalistItemG);
          ini_inv(HerbalistItemH);
          ini_inv(HerbalistItemI);
          ini_inv(HerbalistItemJ);
		break;

	case PM_RODNEYAN:	/* idea by FIQ - playable rodney */

          ini_inv(RodneyItem);
          ini_inv(RodneyItemB);
          ini_inv(RodneyItemC);
          ini_inv(RodneyItemD);
          ini_inv(RodneyItemE);

		break;

	case PM_RACE_X:	/* from Half-Life addon Opposing Force */

          ini_inv(RaceXItem);
          ini_inv(RaceXItemB);

		break;

	case PM_ELONA_SNAIL:

          ini_inv(SnailItem);

		break;

	case PM_UNMAGIC_FISH:

          ini_inv(UnmagicFishItem);

		break;

	case PM_PLAYER_UNICORN:

		HJumping |= FROMOUTSIDE;
		break;

	case PM_BATMAN:
          ini_inv(BatmanItem);
		break;

	case PM_SYLPH:
          ini_inv(SylphStuff);
		break;

	case PM_LOWER_ENT:
          ini_inv(EntStuff);
		break;

	case PM_VENTURE_CAPITALIST:	/* idea by deepy */
          u.ugold += rnd(5000);		
		break;

	case PM_HUMANLIKE_DRAGON:

		switch (rnd(11)) {
                    case 1: ini_inv(WarXtrJ); break;
                    case 2: ini_inv(WarXtrK); break;
                    case 3: ini_inv(WarXtrL); break;
                    case 4: ini_inv(WarXtrM); break;
                    case 5: ini_inv(WarXtrN); break;
                    case 6: ini_inv(WarXtrO); break;
                    case 7: ini_inv(WarXtrP); break;
                    case 8: ini_inv(WarXtrQ); break;
                    case 9: ini_inv(WarXtrR); break;
                    case 10: ini_inv(WarXtrS); break;
                    case 11: ini_inv(WarXtrT); break;
		}
		break;
	case PM_GIGANT:
          ini_inv(GigantItem);
		break;

	default:	/* impossible */
		break;
	}

	/* Players will start with a few healing and identify items now. --Amy
	 * hardmoder race makes it so that you don't */

	if (!ishardmoder) {
          ini_inv(AlwaysStartItem);
          ini_inv(AlwaysStartItemC); /* and some that restore mana */
          ini_inv(AlwaysStartItemE); /* phase door for emergency escapes */
          ini_inv(AlwaysStartItemB); /* standard id to facilitate the identification game */
          ini_inv(AlwaysStartItemD); /* and a curing scroll for those pesky delayed instadeaths */
          ini_inv(AlwaysStartItemF); /* plus a heal other scroll to heal pets and symbiotes */
	}

	if (flags.lostsoul && !flags.uberlostsoul) { 
          ini_inv(LostSoulItem);  /* In Angband or TOME these would be scrolls of cure hunger instead of food rations. */
          ini_inv(LostSoulItemX);
          ini_inv(LostSoulItemY);
	} 

	if (flags.uberlostsoul) { /* lots of items, but you're gonna need them! --Amy */
          ini_inv(LostSoulItem);
          ini_inv(LostSoulItemX);
          ini_inv(LostSoulItemY);
          ini_inv(UberLostSoulItemA);
          ini_inv(UberLostSoulItemB);
          if (!rn2(20)) ini_inv(UberLostSoulItemC);
          if (!rn2(20)) ini_inv(UberLostSoulItemD);
          if (!rn2(25)) ini_inv(UberLostSoulItemE);
          if (!rn2(50)) ini_inv(UberLostSoulItemF);
          if (!rn2(33)) ini_inv(UberLostSoulItemG);
          if (!rn2(75)) ini_inv(UberLostSoulItemH);
          if (!rn2(100)) ini_inv(UberLostSoulItemI);
          if (!rn2(40)) ini_inv(UberLostSoulItemJ);
          if (!rn2(5)) ini_inv(UberLostSoulItemK);
          if (!rn2(25)) ini_inv(UberLostSoulItemL);
          if (!rn2(10)) ini_inv(UberLostSoulItemM);
          if (!rn2(5)) ini_inv(UberLostSoulItemN);
          if (!rn2(100)) ini_inv(UberLostSoulItemO);
          if (!rn2(100)) ini_inv(UberLostSoulItemP);
          if (!rn2(500)) ini_inv(UberLostSoulItemQ);
          if (!rn2(20)) ini_inv(UberLostSoulItemR);
          if (!rn2(40)) ini_inv(UberLostSoulItemR);
          if (!rn2(80)) ini_inv(UberLostSoulItemR);
          if (!rn2(160)) ini_inv(UberLostSoulItemR);
          if (!rn2(320)) ini_inv(UberLostSoulItemR);
          if (!rn2(640)) ini_inv(UberLostSoulItemR);
          if (!rn2(1280)) ini_inv(UberLostSoulItemR);
	} 
	/* Even if you actually get most of these items (by being lucky or savescumming), your level 1 character probably
	 * won't stand a chance on dlvl 64 with no means of levelporting or branchporting, so this is still fair. --Amy */

	if (!issoviet) knows_class(VENOM_CLASS);
	/* "Also venom class isn't discovered by default anymore." In Soviet Russia, people like to make changes to games because they can, not because they want to actually have the effect of their changes in the game. Case in point: venoms being discovered makes sure that the game won't say "you are hit by a splash of venom" if it's e.g. tail spikes or a faerie floss rhing, but that depends on the player knowing what the object is, so if they aren't discovered it doesn't work right! So, dear other people who happen to stumble upon this piece of code: Remove it, and you'll remove messages like "you are hit by a faerie floss rhing", which you hopefully don't want so by the love of whatever god you believe in, don't remove it! --Amy */

	if (!issoviet && !ishardmoder) {
		knows_object(SCR_EXTRA_HEALING);
		knows_object(SCR_GREATER_MANA_RESTORATION);
	}

	if (discover)
		ini_inv(Wishing);

#ifdef WIZARD
	if (wizard)
		read_wizkit();
#endif

#ifndef GOLDOBJ
	u.ugold0 += hidden_gold();	/* in case sack has gold in it */
#else
	if (u.umoney0) ini_inv(Money);
	u.umoney0 += hidden_gold();	/* in case sack has gold in it */
#endif

	/* Starting stat point totals will be higher or lower depending on the player character. --Amy */
	/* keywords: newroles, newraces */

	rolebounus = racebounus = genderbounus = alignbounus = 0;
	maxbounus = 60 + rnd(20);
	if (Role_if(PM_BINDER)) maxbounus += 5;
	if (Role_if(PM_LUNATIC)) maxbounus += 5;
	if (Race_if(PM_HUMAN_WEREWOLF)) maxbounus += 5;
	if (Race_if(PM_BURNINATOR)) maxbounus += 5;
	if (Race_if(PM_SUXXOR)) maxbounus += 10;
	if (Race_if(PM_AK_THIEF_IS_DEAD_)) maxbounus += 5;
	if (Race_if(PM_DEVELOPER)) maxbounus += 5;
	if (Race_if(PM_JELLY)) maxbounus += 5;
	if (Race_if(PM_DUNADAN)) maxbounus += 10;
	if (Race_if(PM_YEEK)) maxbounus -= 10;

	switch (Role_switch) {

	case PM_ARCHEOLOGIST: rolebounus = rnd(15); break;
	case PM_BINDER: rolebounus = rnd(10); break;
	case PM_CAVEMAN: rolebounus = rnd(15); break;
	case PM_GEEK: rolebounus = rnd(18); break;
	case PM_TOURIST: rolebounus = rnd(15); break;
	case PM_PRACTICANT: rolebounus = rnd(15); break;
	case PM_GENDERSTARIST: rolebounus = rnd(12); break;
	case PM_SCIENTIST: rolebounus = rnd(15); break;
	case PM_PIRATE: rolebounus = rnd(22); break;
	case PM_JEDI: rolebounus = rnd(22); break;
	case PM_SHADOW_JEDI: rolebounus = rnd(22); break;
	case PM_HEDDERJEDI: rolebounus = rnd(22); break;
	case PM_HUSSY: rolebounus = rnd(22); break;
	case PM_TOPMODEL: rolebounus = rnd(15); break;
	case PM_UNDEAD_SLAYER: rolebounus = rnd(25); break;
	case PM_COURIER: rolebounus = rnd(5); break;
	case PM_ZYBORG: rolebounus = rnd(30); break;
	case PM_LUNATIC: rolebounus = rnd(30); break;
	case PM_BLEEDER: rolebounus = rnd(30); break;
	case PM_SECRET_ADVICE_MEMBER: rolebounus = rnd(22); break;
	default:	rolebounus = rnd(20); break;

	}

	switch (Race_switch) {

	case PM_ALIEN: racebounus = rnz(2); break;
	case PM_AUREAL: racebounus = rnz(2); break;
	case PM_MAZKE: racebounus = rnz(2); break;
	case PM_CURSER: racebounus = rnz(12); break;
	case PM_DOPPELGANGER: racebounus = rnz(8); break;
	case PM_DROW: racebounus = rnz(7); break;
	case PM_HUMANOID_ANGEL: racebounus = rnz(6); break;
	case PM_BRETON: racebounus = rnz(5); break;
	case PM_REDGUARD: racebounus = rnz(5); break;
	case PM_DUFFLEPUD: racebounus = rnz(5); break;
	case PM_YOKUDA: racebounus = rnz(7); break;
	case PM_SCURRIER: racebounus = rnz(6); break;
	case PM_IMPERIAL: racebounus = rnz(13); break;
	case PM_ELF: racebounus = rnz(11); break;
	case PM_GIGANT: racebounus = rnz(12); break;
	case PM_HOBBIT: racebounus = rnz(8); break;
	case PM_HOMICIDER: racebounus = rnz(8); break;
	case PM_KOBOLT: racebounus = rnz(8); break;
	case PM_ALCHEMIST: racebounus = rnz(7); break;
	case PM_HUMAN_WEREWOLF: racebounus = rnz(15); break;
	case PM_AK_THIEF_IS_DEAD_: racebounus = rnz(15); break;
	case PM_MOULD: racebounus = rnz(12); break;
	case PM_DEATHMOLD: racebounus = rnz(12); break;
	case PM_MISSINGNO: racebounus = rnz(20); break;
	case PM_WORM_THAT_WALKS: racebounus = rnz(13); break;
	case PM_WISP: racebounus = rnz(13); break;
	case PM_OGRO: racebounus = rnz(11); break;
	case PM_WEAPON_XORN: racebounus = rnz(11); break;
	case PM_TROLLOR: racebounus = rnz(12); break;
	case PM_UNGENOMOLD: racebounus = rnz(15); break;
	case PM_BATMAN: racebounus = rnz(14); break;
	case PM_BURNINATOR: racebounus = rnz(14); break;
	case PM_VAMPIRE: racebounus = rnz(12); break;
	case PM_DWARF: racebounus = rnz(11); break;
	case PM_ASGARDIAN: racebounus = rnz(15); break;
	case PM_HAXOR: racebounus = rnz(15); break;
	case PM_SUXXOR: racebounus = rnz(16); break;
	case PM_JELLY: racebounus = rnz(16); break;
	case PM_RACE_X: racebounus = rnz(12); break;
	case PM_ELEMENTAL: racebounus = rnz(12); break;
	case PM_TURTLE: racebounus = rnz(11); break;
	case PM_THUNDERLORD: racebounus = rnz(11); break;
	case PM_CHIQUAI: racebounus = rnz(16); break;
	case PM_ITAQUE: racebounus = rnz(11); break;
	case PM_DUNADAN: racebounus = rnz(15); break;
	case PM_DEVELOPER: racebounus = rnz(15); break;
	case PM_LOWER_ENT: racebounus = rnz(12); break;
	case PM_HC_ALIEN: racebounus = rnz(12); break;
	case PM_SLYER_ALIEN: racebounus = rnz(12); break;
	case PM_MANSTER: racebounus = rnz(12); break;
	case PM_RETICULAN: racebounus = rnz(15); break;
	case PM_NEMESIS: racebounus = rnz(15); break;
	case PM_OUTSIDER: racebounus = rnz(12); break;
	case PM_WEAPON_BUG: racebounus = rnz(16); break;
	case PM_BASTARD: racebounus = rnz(7); break;
	case PM_SOVIET: racebounus = rnd(5); break; /* note the rnd instead of rnz! */
	case PM_FAWN: racebounus = rnz(8); break;
	case PM_MAGYAR: racebounus = rnz(5); break;
	case PM_VIKING: racebounus = rnz(8); break;
	case PM_YUKI_PLAYA: racebounus = 0; break;
	case PM_YEEK: racebounus = 0; break;
	case PM_WOOKIE: racebounus = 0; break;
	case PM_HUMANOID_DRYAD: racebounus = rnz(8); break;
	case PM_PLAYER_ZRUTY: racebounus = rnz(15); break;
	case PM_METAL: racebounus = rnz(6); break;
	case PM_BACTERIA: racebounus = rnz(16); break;
	case PM_PLAYER_CERBERUS: racebounus = rnz(16); break;
	case PM_PLAYER_GOLEM: racebounus = rnz(11); break;
	case PM_PLAYER_MECHANIC: racebounus = rnz(12); break;
	case PM_BULDOZGAR: racebounus = rnz(12); break;
	case PM_SWIKNI: racebounus = rnz(13); break;
	case PM_URGOTH: racebounus = rnz(15); break;
	case PM_PLAYABLE_NEANDERTHAL: racebounus = rnz(15); break;
	case PM_THRALL: racebounus = rnz(8); break;
	case PM_STARTSCUMMER: racebounus = 0; break;
	default:	racebounus = rnz(10); break;

	if (Race_if(PM_BADSTATTER)) racebounus += 12; /* not granted when using hybrid race, obviously --Amy */

	}

    switch (u.ualign.type) {
    case A_LAWFUL: alignbounus = rnz(5); break;
    case A_NEUTRAL: alignbounus = rnd(12); break;
    case A_CHAOTIC: alignbounus = rnz(3); break;
	default: /*impossible*/ alignbounus = rnz(3); break;

	}

	if (flags.female) genderbounus = rnz(3);
	else genderbounus = rnd(5);

	temp = 30 + rolebounus + racebounus + alignbounus + genderbounus; /* new algorithm --Amy */
	if (issoviet) temp = 75;

	if (Race_if(PM_AUREAL) && !flags.female) temp -= 10;
	if (Race_if(PM_MAZKE) && !flags.female) temp -= 10;

	if (temp > maxbounus) temp = maxbounus; /* prevent value from randomly becoming too high */
	/*temp = rn1(10,70);*/
	init_attr(temp, FALSE);		/* init attribute values */
	find_ac();			/* get initial ac value */
	max_rank_sz();			/* set max str size for class ranks */
/*
 *	Do we really need this?
 */
	for(i = 0; i < A_MAX; i++)
	    if(!rn2(20)) {
		register int xd = rn2(7) - 2;	/* biased variation */
		(void) adjattrib(i, xd, 3, TRUE);
		if (ABASE(i) < AMAX(i)) AMAX(i) = ABASE(i);
	    }
	/* make sure you can carry all you have - especially for Tourists */
	/* but also prevent players from having ridiculous starting strength or constitution, especially for ghasts --Amy */
	while (inv_weight() > 0 && ( (weight_cap() < 1000 && rn2(10)) || (weight_cap() > 999 && rn2(2)) ) ) {

		if (ABASE(A_STR) < 18) {
			if (adjattrib(A_STR, 1, 3, TRUE)) continue;
		}
		if (ABASE(A_CON) < 18) {
			if (adjattrib(A_CON, 1, 3, TRUE)) continue;
		}
		/* only get here when didn't boost strength or constitution */
		break;
	}

	u.startstr = ABASE(A_STR);
	u.startdex = ABASE(A_DEX);
	u.startcon = ABASE(A_CON);
	u.startint = ABASE(A_INT);
	u.startwis = ABASE(A_WIS);
	u.startcha = ABASE(A_CHA);

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shambler->mmove = rn2(10)+9;				/* slow to very fast */
	shambler->ac = rn2(21)-10;				/* any AC */
	shambler->mr = rn2(5)*25;				/* varying amounts of MR */
	shambler->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shambler->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shambler->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shambler->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shambler->cnutrit = rnd(2000);					/* see above */
	shambler->msound = randmonsound();			/* any but the specials */
	shambler->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shambler->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shambler->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shambler->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shambler->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shambler->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shambler->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shambler->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shambler->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shambler->mflags2 |= (1 << rn2(31));
	}
	shambler->mflags2 &= ~M2_MERC;				/* no guards */
	shambler->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shambler->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shambler->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerp->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerp->ac = rn2(21)-10;				/* any AC */
	shamblerp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerp->cnutrit = rnd(2000);					/* see above */
	shamblerp->msound = randmonsound();			/* any but the specials */
	shamblerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerp->mflags2 |= (1 << rn2(31));
	}
	shamblerp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	pokshambler->mmove = rn2(10)+9;				/* slow to very fast */
	pokshambler->ac = rn2(21)-10;				/* any AC */
	pokshambler->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshambler->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshambler->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	pokshambler->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshambler->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshambler->cnutrit = rnd(2000);					/* see above */
	pokshambler->msound = randmonsound();			/* any but the specials */
	pokshambler->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshambler->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshambler->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshambler->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshambler->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshambler->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshambler->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshambler->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshambler->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshambler->mflags2 |= (1 << rn2(31));
	}
	pokshambler->mflags2 &= ~M2_MERC;				/* no guards */
	pokshambler->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshambler->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshambler->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	pokshamblerp->mmove = rn2(10)+9;				/* slow to very fast */
	pokshamblerp->ac = rn2(21)-10;				/* any AC */
	pokshamblerp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	pokshamblerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerp->cnutrit = rnd(2000);					/* see above */
	pokshamblerp->msound = randmonsound();			/* any but the specials */
	pokshamblerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerp->mflags2 |= (1 << rn2(31));
	}
	pokshamblerp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerp->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblera->mmove = rn2(10)+9;				/* slow to very fast */
	shamblera->ac = rn2(21)-10;				/* any AC */
	shamblera->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblera->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblera->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblera->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblera->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblera->cnutrit = rnd(2000);					/* see above */
	shamblera->msound = randmonsound();			/* any but the specials */
	shamblera->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblera->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblera->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblera->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblera->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblera->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblera->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblera->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblera->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblera->mflags2 |= (1 << rn2(31));
	}
	shamblera->mflags2 &= ~M2_MERC;				/* no guards */
	shamblera->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblera->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblera->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerap->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerap->ac = rn2(21)-10;				/* any AC */
	shamblerap->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerap->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerap->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerap->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerap->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerap->cnutrit = rnd(2000);					/* see above */
	shamblerap->msound = randmonsound();			/* any but the specials */
	shamblerap->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerap->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerap->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerap->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerap->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerap->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerap->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerap->mflags2 |= (1 << rn2(31));
	}
	shamblerap->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerap->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerap->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerap->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerb->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerb->ac = rn2(21)-10;				/* any AC */
	shamblerb->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerb->cnutrit = rnd(2000);					/* see above */
	shamblerb->msound = randmonsound();			/* any but the specials */
	shamblerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerb->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblerb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerb->mflags2 |= (1 << rn2(31));
	}
	shamblerb->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerbp->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerbp->ac = rn2(21)-10;				/* any AC */
	shamblerbp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerbp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerbp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerbp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerbp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerbp->cnutrit = rnd(2000);					/* see above */
	shamblerbp->msound = randmonsound();			/* any but the specials */
	shamblerbp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerbp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerbp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerbp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerbp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerb->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblerbp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerbp->mflags2 |= (1 << rn2(31));
	}
	shamblerbp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerbp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerbp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerbp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/*extra hard versions*/

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblers->mmove = rn2(18)+9;				/* slow to very fast */
	shamblers->ac = rn2(35)-24;				/* any AC */
	shamblers->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblers->cnutrit = rnd(2000);					/* see above */
	shamblers->msound = randmonsound();			/* any but the specials */
	shamblers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblers->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblers->mflags2 |= (1 << rn2(31));
	}
	shamblers->mflags2 &= ~M2_MERC;				/* no guards */
	shamblers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblers->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblersp->mmove = rn2(18)+9;				/* slow to very fast */
	shamblersp->ac = rn2(35)-24;				/* any AC */
	shamblersp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblersp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblersp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblersp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblersp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblersp->cnutrit = rnd(2000);					/* see above */
	shamblersp->msound = randmonsound();			/* any but the specials */
	shamblersp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblersp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblersp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblersp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblersp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblersp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblersp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblersp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblersp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblersp->mflags2 |= (1 << rn2(31));
	}
	shamblersp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblersp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblersp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblersp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblers->mmove = rn2(18)+9;				/* slow to very fast */
	pokshamblers->ac = rn2(35)-24;				/* any AC */
	pokshamblers->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &pokshamblers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	pokshamblers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblers->cnutrit = rnd(2000);					/* see above */
	pokshamblers->msound = randmonsound();			/* any but the specials */
	pokshamblers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblers->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblers->mflags2 |= (1 << rn2(31));
	}
	pokshamblers->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblers->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblersp->mmove = rn2(18)+9;				/* slow to very fast */
	pokshamblersp->ac = rn2(35)-24;				/* any AC */
	pokshamblersp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblersp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &pokshamblersp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	pokshamblersp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblersp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblersp->cnutrit = rnd(2000);					/* see above */
	pokshamblersp->msound = randmonsound();			/* any but the specials */
	pokshamblersp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblersp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblersp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblersp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblersp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblersp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblersp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblersp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblersp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblersp->mflags2 |= (1 << rn2(31));
	}
	pokshamblersp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblersp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblersp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblersp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblerxts->mmove = rn2(20)+9;				/* slow to very fast */
	pokshamblerxts->ac = rn2(40)-29;				/* any AC */
	pokshamblerxts->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxts->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &pokshamblerxts->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	pokshamblerxts->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxts->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxts->cnutrit = rnd(2000);					/* see above */
	pokshamblerxts->msound = randmonsound();			/* any but the specials */
	pokshamblerxts->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxts->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxts->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxts->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxts->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxts->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxts->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxts->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxts->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxts->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxts->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxts->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxts->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxts->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblerxtsp->mmove = rn2(20)+9;				/* slow to very fast */
	pokshamblerxtsp->ac = rn2(40)-29;				/* any AC */
	pokshamblerxtsp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxtsp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &pokshamblerxtsp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	pokshamblerxtsp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxtsp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxtsp->cnutrit = rnd(2000);					/* see above */
	pokshamblerxtsp->msound = randmonsound();			/* any but the specials */
	pokshamblerxtsp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxtsp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxtsp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxtsp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxtsp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxtsp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxtsp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxtsp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxtsp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxtsp->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxtsp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxtsp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxtsp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxtsp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	shamblerz->ac = rn2(40)-29;				/* any AC */
	shamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	shamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerz->cnutrit = rnd(2000);					/* see above */
	shamblerz->msound = randmonsound();			/* any but the specials */
	shamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerz->mflags2 |= (1 << rn2(31));
	}
	shamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerza->mmove = rn2(20)+9;				/* slow to very fast */
	shamblerza->ac = rn2(40)-29;				/* any AC */
	shamblerza->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerza->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblerza->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	shamblerza->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerza->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerza->cnutrit = rnd(2000);					/* see above */
	shamblerza->msound = randmonsound();			/* any but the specials */
	shamblerza->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerza->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerza->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerza->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerza->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerza->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerza->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerza->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerza->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerza->mflags2 |= (1 << rn2(31));
	}
	shamblerza->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerza->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerza->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerza->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblernl->mmove = rn2(22)+9;				/* slow to very fast */
	shamblernl->ac = rn2(45)-29;				/* any AC */
	shamblernl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblernl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblernl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(26)+2;				/* either too high or too low */
	}
	shamblernl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblernl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblernl->cnutrit = rnd(2000);					/* see above */
	shamblernl->msound = randmonsound();			/* any but the specials */
	shamblernl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblernl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblernl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblernl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblernl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblernl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblernl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblernl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblernl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblernl->mflags2 |= (1 << rn2(31));
	}
	shamblernl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblernl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblernl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblernl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblernla->mmove = rn2(22)+9;				/* slow to very fast */
	shamblernla->ac = rn2(45)-29;				/* any AC */
	shamblernla->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblernla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblernla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(26)+2;				/* either too high or too low */
	}
	shamblernla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblernla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblernla->cnutrit = rnd(2000);					/* see above */
	shamblernla->msound = randmonsound();			/* any but the specials */
	shamblernla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblernla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblernla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblernla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblernla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblernla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblernla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblernla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblernla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblernla->mflags2 |= (1 << rn2(31));
	}
	shamblernla->mflags2 &= ~M2_MERC;				/* no guards */
	shamblernla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblernla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblernla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	rshamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	rshamblerz->ac = rn2(40)-29;				/* any AC */
	rshamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &rshamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	rshamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerz->cnutrit = rnd(2000);					/* see above */
	rshamblerz->msound = randmonsound();			/* any but the specials */
	rshamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerz->mflags2 |= (1 << rn2(31));
	}
	rshamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerz, buf, sizeof(buf) );
	rshamblerz->mname = u.strshamblerz;

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	rshamblerza->mmove = rn2(20)+9;				/* slow to very fast */
	rshamblerza->ac = rn2(40)-29;				/* any AC */
	rshamblerza->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerza->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &rshamblerza->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	rshamblerza->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerza->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerza->cnutrit = rnd(2000);					/* see above */
	rshamblerza->msound = randmonsound();			/* any but the specials */
	rshamblerza->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerza->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerza->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerza->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerza->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerza->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerza->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerza->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerza->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerza->mflags2 |= (1 << rn2(31));
	}
	rshamblerza->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerza->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerza->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerza->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerza, buf, sizeof(buf) );
	rshamblerza->mname = u.strshamblerza;


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerr->mmove = rn2(18)+9;				/* slow to very fast */
	shamblerr->ac = rn2(35)-24;				/* any AC */
	shamblerr->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerr->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblerr->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblerr->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerr->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerr->cnutrit = rnd(2000);					/* see above */
	shamblerr->msound = randmonsound();			/* any but the specials */
	shamblerr->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerr->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerr->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerr->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerr->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerr->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerr->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerr->mflags2 |= (1 << rn2(31));
	}
	shamblerr->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerr->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerr->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerr->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerrp->mmove = rn2(18)+9;				/* slow to very fast */
	shamblerrp->ac = rn2(35)-24;				/* any AC */
	shamblerrp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerrp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblerrp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblerrp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerrp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerrp->cnutrit = rnd(2000);					/* see above */
	shamblerrp->msound = randmonsound();			/* any but the specials */
	shamblerrp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerrp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerrp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerrp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerrp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerrp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerrp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerrp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerrp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerrp->mflags2 |= (1 << rn2(31));
	}
	shamblerrp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerrp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerrp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerrp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblert->mmove = rn2(14)+9;				/* slow to very fast */
	shamblert->ac = rn2(31)-20;				/* any AC */
	shamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblert->cnutrit = rnd(2000);					/* see above */
	shamblert->msound = randmonsound();			/* any but the specials */
	shamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblert->mflags2 |= (1 << rn2(31));
	}
	shamblert->mflags2 &= ~M2_MERC;				/* no guards */
	shamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	randspoilerb->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerb->ac = rn2(18)-7;				/* any AC */
	randspoilerb->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	randspoilerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerb->cnutrit = rnd(2000);					/* see above */
	randspoilerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randspoilerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randspoilerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randspoilerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randspoilerb->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		randspoilerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*randspoilerb->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*randspoilerb->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	randspoilerb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randspoilerb->mflags2 |= (1 << rn2(31));
	}
	randspoilerb->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randspoilerb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	randspoilerc->mmove = rn2(14)+9;				/* slow to very fast */
	randspoilerc->ac = rn2(31)-20;				/* any AC */
	randspoilerc->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerc->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randspoilerc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	randspoilerc->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerc->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerc->cnutrit = rnd(2000);					/* see above */
	randspoilerc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randspoilerc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randspoilerc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randspoilerc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randspoilerc->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		randspoilerc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	randspoilerc->mflags1 &= ~M1_HIDE;				/* no hiding */

	randspoilerc->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randspoilerc->mflags2 |= (1 << rn2(31));
	}
	randspoilerc->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randspoilerc->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblery->mmove = rn2(14)+9;				/* slow to very fast */
	shamblery->ac = rn2(31)-20;				/* any AC */
	shamblery->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblery->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblery->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblery->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblery->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblery->cnutrit = rnd(2000);					/* see above */
	shamblery->msound = randmonsound();			/* any but the specials */
	shamblery->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblery->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblery->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblery->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblery->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblery->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblery->mflags1 &= ~M1_HIDE;				/* no hiding */

	shamblery->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblery->mflags2 |= (1 << rn2(31));
	}
	shamblery->mflags2 &= ~M2_MERC;				/* no guards */
	shamblery->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblery->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblery->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	shamblertp->ac = rn2(31)-20;				/* any AC */
	shamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblertp->cnutrit = rnd(2000);					/* see above */
	shamblertp->msound = randmonsound();			/* any but the specials */
	shamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblertp->mflags2 |= (1 << rn2(31));
	}
	shamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	pokshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	pokshamblert->ac = rn2(31)-20;				/* any AC */
	pokshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &pokshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	pokshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblert->cnutrit = rnd(2000);					/* see above */
	pokshamblert->msound = randmonsound();			/* any but the specials */
	pokshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		pokshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	pokshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblert->mflags2 |= (1 << rn2(31));
	}
	pokshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	pokshamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	pokshamblertp->ac = rn2(31)-20;				/* any AC */
	pokshamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &pokshamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	pokshamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblertp->cnutrit = rnd(2000);					/* see above */
	pokshamblertp->msound = randmonsound();			/* any but the specials */
	pokshamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		pokshamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	pokshamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	pokshamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblertp->mflags2 |= (1 << rn2(31));
	}
	pokshamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	rpokshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	rpokshamblert->ac = rn2(31)-20;				/* any AC */
	rpokshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	rpokshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rpokshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rpokshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rpokshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rpokshamblert->cnutrit = rnd(2000);					/* see above */
	rpokshamblert->msound = randmonsound();			/* any but the specials */
	rpokshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rpokshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rpokshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rpokshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rpokshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		rpokshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	rpokshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rpokshamblert->mflags2 |= (1 << rn2(31));
	}
	rpokshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	rpokshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rpokshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rpokshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strpokshamblert, buf, sizeof(buf) );
	rpokshamblert->mname = u.strpokshamblert;

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	rpokshamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	rpokshamblertp->ac = rn2(31)-20;				/* any AC */
	rpokshamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	rpokshamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rpokshamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rpokshamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rpokshamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rpokshamblertp->cnutrit = rnd(2000);					/* see above */
	rpokshamblertp->msound = randmonsound();			/* any but the specials */
	rpokshamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rpokshamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rpokshamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rpokshamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rpokshamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		rpokshamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	rpokshamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	rpokshamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rpokshamblertp->mflags2 |= (1 << rn2(31));
	}
	rpokshamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	rpokshamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rpokshamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rpokshamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strpokshamblertp, buf, sizeof(buf) );
	rpokshamblertp->mname = u.strpokshamblertp;

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerta->mmove = rn2(14)+9;				/* slow to very fast */
	shamblerta->ac = rn2(31)-20;				/* any AC */
	shamblerta->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerta->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerta->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblerta->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerta->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerta->cnutrit = rnd(2000);					/* see above */
	shamblerta->msound = randmonsound();			/* any but the specials */
	shamblerta->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerta->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerta->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerta->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerta->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerta->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerta->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerta->mflags2 |= (1 << rn2(31));
	}
	shamblerta->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerta->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerta->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerta->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerya->mmove = rn2(14)+9;				/* slow to very fast */
	shamblerya->ac = rn2(31)-20;				/* any AC */
	shamblerya->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerya->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerya->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblerya->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerya->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerya->cnutrit = rnd(2000);					/* see above */
	shamblerya->msound = randmonsound();			/* any but the specials */
	shamblerya->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerya->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerya->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerya->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerya->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerya->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerya->mflags1 &= ~M1_HIDE;				/* no hiding */

	shamblerya->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerya->mflags2 |= (1 << rn2(31));
	}
	shamblerya->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerya->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerya->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerya->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblertpa->mmove = rn2(14)+9;				/* slow to very fast */
	shamblertpa->ac = rn2(31)-20;				/* any AC */
	shamblertpa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblertpa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblertpa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblertpa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblertpa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblertpa->cnutrit = rnd(2000);					/* see above */
	shamblertpa->msound = randmonsound();			/* any but the specials */
	shamblertpa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblertpa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblertpa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblertpa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblertpa->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblertpa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblertpa->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblertpa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblertpa->mflags2 |= (1 << rn2(31));
	}
	shamblertpa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblertpa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblertpa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblertpa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	shamblerl->mmove = rn2(8)+9;				/* slow to very fast */
	shamblerl->ac = rn2(16)-5;				/* any AC */
	shamblerl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	shamblerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerl->cnutrit = rnd(2000);					/* see above */
	shamblerl->msound = randmonsound();			/* any but the specials */
	shamblerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerl->mflags2 |= (1 << rn2(31));
	}
	shamblerl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	shamblerln->mmove = rn2(3)+6;				/* slow to very fast */
	shamblerln->ac = 10 - rn2(6);				/* any AC */
	shamblerln->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerln->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(2); i++) {
		attkptr = &shamblerln->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2);				/* either too high or too low */
	}
	shamblerln->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerln->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerln->cnutrit = rnd(2000);					/* see above */
	shamblerln->msound = randmonsound();			/* any but the specials */
	shamblerln->mresists = 0;
	for (i = 0; i < rnd(3); i++) {
		shamblerln->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(2); i++) {
		shamblerln->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerln->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerln->mflags1 = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerln->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerln->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerln->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerln->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(7); i++) {
		shamblerln->mflags2 |= (1 << rn2(31));
	}
	shamblerln->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerln->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerln->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerln->mflags2 &= ~M2_PNAME;				/* not a proper name */

	shamblerlo->mmove = rn2(3)+6;				/* slow to very fast */
	shamblerlo->ac = 10 - rn2(6);				/* any AC */
	shamblerlo->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerlo->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(2); i++) {
		attkptr = &shamblerlo->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2);				/* either too high or too low */
	}
	shamblerlo->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerlo->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerlo->cnutrit = rnd(2000);					/* see above */
	shamblerlo->msound = randmonsound();			/* any but the specials */
	shamblerlo->mresists = 0;
	for (i = 0; i < rnd(3); i++) {
		shamblerlo->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(2); i++) {
		shamblerlo->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerlo->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerlo->mflags1 = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerlo->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerlo->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerlo->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerlo->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(7); i++) {
		shamblerlo->mflags2 |= (1 << rn2(31));
	}
	shamblerlo->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerlo->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerlo->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerlo->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	shamblerla->mmove = rn2(8)+9;				/* slow to very fast */
	shamblerla->ac = rn2(16)-5;				/* any AC */
	shamblerla->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	shamblerla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerla->cnutrit = rnd(2000);					/* see above */
	shamblerla->msound = randmonsound();			/* any but the specials */
	shamblerla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerla->mflags2 |= (1 << rn2(31));
	}
	shamblerla->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	pokshamblerl->mmove = rn2(8)+9;				/* slow to very fast */
	pokshamblerl->ac = rn2(16)-5;				/* any AC */
	pokshamblerl->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	pokshamblerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerl->cnutrit = rnd(2000);					/* see above */
	pokshamblerl->msound = randmonsound();			/* any but the specials */
	pokshamblerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerl->mflags2 |= (1 << rn2(31));
	}
	pokshamblerl->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	pokshamblerla->mmove = rn2(8)+9;				/* slow to very fast */
	pokshamblerla->ac = rn2(16)-5;				/* any AC */
	pokshamblerla->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	pokshamblerla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerla->cnutrit = rnd(2000);					/* see above */
	pokshamblerla->msound = randmonsound();			/* any but the specials */
	pokshamblerla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerla->mflags2 |= (1 << rn2(31));
	}
	pokshamblerla->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	gloshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	gloshamblerx->ac = rn2(18)-7;				/* any AC */
	gloshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &gloshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	gloshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblerx->cnutrit = rnd(2000);					/* see above */
	gloshamblerx->msound = randmonsound();			/* any but the specials */
	gloshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		gloshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*gloshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*gloshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	gloshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblerx->mflags2 |= (1 << rn2(31));
	}
	gloshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	gloshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	gloshamblert->ac = rn2(31)-20;				/* any AC */
	gloshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &gloshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	gloshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblert->cnutrit = rnd(2000);					/* see above */
	gloshamblert->msound = randmonsound();			/* any but the specials */
	gloshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		gloshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	gloshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblert->mflags2 |= (1 << rn2(31));
	}
	gloshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	gloshamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	gloshamblerz->ac = rn2(40)-29;				/* any AC */
	gloshamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &gloshamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	gloshamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblerz->cnutrit = rnd(2000);					/* see above */
	gloshamblerz->msound = randmonsound();			/* any but the specials */
	gloshamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		gloshamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*gloshamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*gloshamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	gloshamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblerz->mflags2 |= (1 << rn2(31));
	}
	gloshamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerx->ac = rn2(18)-7;				/* any AC */
	shamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerx->cnutrit = rnd(2000);					/* see above */
	shamblerx->msound = randmonsound();			/* any but the specials */
	shamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerx->mflags2 |= (1 << rn2(31));
	}
	shamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerxz->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerxz->ac = rn2(18)-7;				/* any AC */
	shamblerxz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerxz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerxz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerxz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerxz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerxz->cnutrit = rnd(2000);					/* see above */
	shamblerxz->msound = randmonsound();			/* any but the specials */
	shamblerxz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerxz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerxz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerxz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerxz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerxz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerxz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerxz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerxz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerxz->mflags2 |= (1 << rn2(31));
	}
	shamblerxz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerxz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerxz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerxz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerxa->ac = rn2(18)-7;				/* any AC */
	shamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerxa->cnutrit = rnd(2000);					/* see above */
	shamblerxa->msound = randmonsound();			/* any but the specials */
	shamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerxa->mflags2 |= (1 << rn2(31));
	}
	shamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	rshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	rshamblerx->ac = rn2(18)-7;				/* any AC */
	rshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &rshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	rshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerx->cnutrit = rnd(2000);					/* see above */
	rshamblerx->msound = randmonsound();			/* any but the specials */
	rshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerx->mflags2 |= (1 << rn2(31));
	}
	rshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerx, buf, sizeof(buf) );
	rshamblerx->mname = u.strshamblerx;

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	rshamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	rshamblerxa->ac = rn2(18)-7;				/* any AC */
	rshamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &rshamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	rshamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerxa->cnutrit = rnd(2000);					/* see above */
	rshamblerxa->msound = randmonsound();			/* any but the specials */
	rshamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerxa->mflags2 |= (1 << rn2(31));
	}
	rshamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerxa, buf, sizeof(buf) );
	rshamblerxa->mname = u.strshamblerxa;

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	pokshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerx->ac = rn2(18)-7;				/* any AC */
	pokshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	pokshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerx->cnutrit = rnd(2000);					/* see above */
	pokshamblerx->msound = randmonsound();			/* any but the specials */
	pokshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerx->mflags2 |= (1 << rn2(31));
	}
	pokshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	pokshamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerxa->ac = rn2(18)-7;				/* any AC */
	pokshamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	pokshamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxa->cnutrit = rnd(2000);					/* see above */
	pokshamblerxa->msound = randmonsound();			/* any but the specials */
	pokshamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxa->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerm->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerm->ac = rn2(21)-10;				/* any AC */
	shamblerm->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerm->cnutrit = rnd(2000);					/* see above */
	shamblerm->msound = randmonsound();			/* any but the specials */
	shamblerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerm->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerm->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerm->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerm->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerm->mflags2 |= (1 << rn2(31));
	}
	shamblerm->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerm->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerma->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerma->ac = rn2(21)-10;				/* any AC */
	shamblerma->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerma->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerma->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerma->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerma->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerma->cnutrit = rnd(2000);					/* see above */
	shamblerma->msound = randmonsound();			/* any but the specials */
	shamblerma->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerma->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerma->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerma->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerma->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerma->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerma->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerma->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerma->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerma->mflags2 |= (1 << rn2(31));
	}
	shamblerma->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerma->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerma->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerma->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblern->mmove = rn2(9)+9;				/* slow to very fast */
	shamblern->ac = rn2(21)-10;				/* any AC */
	shamblern->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblern->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblern->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblern->cnutrit = rnd(2000);					/* see above */
	shamblern->msound = randmonsound();			/* any but the specials */
	shamblern->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblern->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblern->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblern->mflags1 = M1_HIDE;
	for (i = 0; i < rnd(17); i++) {
		shamblern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblern->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblern->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblern->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblern->mflags2 |= (1 << rn2(31));
	}
	shamblern->mflags2 &= ~M2_MERC;				/* no guards */
	shamblern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblern->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerna->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerna->ac = rn2(21)-10;				/* any AC */
	shamblerna->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerna->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerna->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerna->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerna->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerna->cnutrit = rnd(2000);					/* see above */
	shamblerna->msound = randmonsound();			/* any but the specials */
	shamblerna->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerna->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerna->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerna->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerna->mflags1 = M1_HIDE;
	for (i = 0; i < rnd(17); i++) {
		shamblerna->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerna->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerna->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerna->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerna->mflags2 |= (1 << rn2(31));
	}
	shamblerna->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerna->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerna->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerna->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	pokshamblerm->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerm->ac = rn2(21)-10;				/* any AC */
	pokshamblerm->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	pokshamblerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerm->cnutrit = rnd(2000);					/* see above */
	pokshamblerm->msound = randmonsound();			/* any but the specials */
	pokshamblerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerm->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerm->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerm->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerm->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerm->mflags2 |= (1 << rn2(31));
	}
	pokshamblerm->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerm->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	pokshamblerma->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerma->ac = rn2(21)-10;				/* any AC */
	pokshamblerma->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerma->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerma->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	pokshamblerma->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerma->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerma->cnutrit = rnd(2000);					/* see above */
	pokshamblerma->msound = randmonsound();			/* any but the specials */
	pokshamblerma->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerma->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerma->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerma->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerma->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerma->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerma->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerma->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerma->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerma->mflags2 |= (1 << rn2(31));
	}
	pokshamblerma->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerma->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerma->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerma->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shamblerplayer->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayer->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayer->ac = rn2(21)-10;				/* any AC */
	shamblerplayer->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayer->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayer->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayer->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayer->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayer->cnutrit = rnd(2000);					/* see above */
	shamblerplayer->msound = randmonsound();			/* any but the specials */
	shamblerplayer->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayer->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayer->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayer->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayer->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayer->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayer->mflags2 = M2_HOSTILE | M2_WERE;		/* mondata.c prevents players from polying into them */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayer->mflags2 |= (1 << rn2(31));
	}
	shamblerplayer->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayer->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayer->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayer->mflags2 &= ~M2_NOPOLY;				/* see above */

	/* what a horrible night to have a curse */
	/*shamblerplayergl->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayergl->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayergl->ac = rn2(21)-10;				/* any AC */
	shamblerplayergl->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayergl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayergl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayergl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayergl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayergl->cnutrit = rnd(2000);					/* see above */
	shamblerplayergl->msound = randmonsound();			/* any but the specials */
	shamblerplayergl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayergl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayergl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayergl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayergl->mflags1 = M1_CARNIVORE|M1_OVIPAROUS;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayergl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayergl->mflags2 = M2_NOPOLY;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayergl->mflags2 |= (1 << rn2(31));
	}
	shamblerplayergl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayergl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayergl->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayergl->mflags2 &= ~M2_WERE;				/* no werefoo */

	/* what a horrible night to have a curse */
	/*shamblerplayerb->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerb->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayerb->ac = rn2(21)-10;				/* any AC */
	shamblerplayerb->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerb->cnutrit = rnd(2000);					/* see above */
	shamblerplayerb->msound = randmonsound();			/* any but the specials */
	shamblerplayerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerb->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerb->mflags2 = M2_HOSTILE | M2_WERE;		/* mondata.c prevents players from polying into them */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerb->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerb->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerb->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerb->mflags2 &= ~M2_NOPOLY;				/* see above */

	/* what a horrible night to have a curse */
	/*shamblerplayerc->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerc->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerc->ac = rn2(21)-10;				/* any AC */
	shamblerplayerc->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerc->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerc->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerc->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerc->cnutrit = rnd(2000);					/* see above */
	shamblerplayerc->msound = randmonsound();			/* any but the specials */
	shamblerplayerc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerc->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerc->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerc->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerc->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerc->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerc->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerc->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerc->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayerd->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerd->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerd->ac = rn2(21)-10;				/* any AC */
	shamblerplayerd->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerd->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerd->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerd->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerd->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerd->cnutrit = rnd(2000);					/* see above */
	shamblerplayerd->msound = randmonsound();			/* any but the specials */
	shamblerplayerd->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerd->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerd->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerd->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerd->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerd->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerd->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerd->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerd->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerd->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerd->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerd->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerd->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerd->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerd->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayere->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayere->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayere->ac = rn2(21)-10;				/* any AC */
	shamblerplayere->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayere->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayere->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayere->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayere->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayere->cnutrit = rnd(2000);					/* see above */
	shamblerplayere->msound = randmonsound();			/* any but the specials */
	shamblerplayere->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayere->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayere->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayere->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayere->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayere->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayere->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayere->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayere->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayere->mflags2 |= (1 << rn2(31));
	}
	shamblerplayere->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayere->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayere->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayere->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayere->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayerf->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerf->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerf->ac = rn2(21)-10;				/* any AC */
	shamblerplayerf->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerf->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerf->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerf->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerf->cnutrit = rnd(2000);					/* see above */
	shamblerplayerf->msound = randmonsound();			/* any but the specials */
	shamblerplayerf->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerf->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerf->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerf->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerf->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerf->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerf->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerf->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerf->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerf->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerf->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerf->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerf->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerg->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerg->ac = rn2(21)-10;				/* any AC */
	shamblerplayerg->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerg->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerg->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerg->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerg->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerg->cnutrit = rnd(2000);					/* see above */
	shamblerplayerg->msound = randmonsound();			/* any but the specials */
	shamblerplayerg->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerg->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerg->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerg->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerg->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerg->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerg->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerg->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerg->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerg->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerg->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerg->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerh->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerh->ac = rn2(21)-10;				/* any AC */
	shamblerplayerh->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerh->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerh->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerh->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerh->cnutrit = rnd(2000);					/* see above */
	shamblerplayerh->msound = randmonsound();			/* any but the specials */
	shamblerplayerh->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerh->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerh->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerh->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerh->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerh->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerh->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerh->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerh->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerh->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerh->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerh->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerh->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermso->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermso->ac = rn2(21)-10;				/* any AC */
	shamblerplayermso->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermso->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermso->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermso->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermso->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermso->cnutrit = rnd(2000);					/* see above */
	shamblerplayermso->msound = randmonsound();			/* any but the specials */
	shamblerplayermso->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermso->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermso->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermso->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermso->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermso->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermso->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermso->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermso->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermso->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermso->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermso->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermso->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermsp->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermsp->ac = rn2(21)-10;				/* any AC */
	shamblerplayermsp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermsp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermsp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermsp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermsp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermsp->cnutrit = rnd(2000);					/* see above */
	shamblerplayermsp->msound = randmonsound();			/* any but the specials */
	shamblerplayermsp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermsp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermsp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermsp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermsp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermsp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermsp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermsp->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermsp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermsp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermsp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermsp->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermsp->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayeri->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayeri->ac = rn2(21)-10;				/* any AC */
	shamblerplayeri->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeri->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayeri->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayeri->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeri->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeri->cnutrit = rnd(2000);					/* see above */
	shamblerplayeri->msound = randmonsound();			/* any but the specials */
	shamblerplayeri->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeri->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayeri->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeri->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeri->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeri->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeri->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeri->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeri->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeri->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeri->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeri->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeri->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeri->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeri->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerj->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerj->ac = rn2(21)-10;				/* any AC */
	shamblerplayerj->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerj->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerj->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerj->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerj->cnutrit = rnd(2000);					/* see above */
	shamblerplayerj->msound = randmonsound();			/* any but the specials */
	shamblerplayerj->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerj->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerj->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerj->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerj->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerj->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerj->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerj->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerj->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerj->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerj->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerj->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerj->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerk->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerk->ac = rn2(31)-20;				/* any AC */
	shamblerplayerk->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerk->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerk->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerk->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerk->cnutrit = rnd(2000);					/* see above */
	shamblerplayerk->msound = randmonsound();			/* any but the specials */
	shamblerplayerk->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerk->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerk->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerk->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerk->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerk->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerk->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerk->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerk->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerk->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerk->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerk->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerk->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerl->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerl->ac = rn2(31)-20;				/* any AC */
	shamblerplayerl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerl->cnutrit = rnd(2000);					/* see above */
	shamblerplayerl->msound = randmonsound();			/* any but the specials */
	shamblerplayerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerl->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerl->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerl->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerl->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerl->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerm->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerm->ac = rn2(31)-20;				/* any AC */
	shamblerplayerm->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerm->cnutrit = rnd(2000);					/* see above */
	shamblerplayerm->msound = randmonsound();			/* any but the specials */
	shamblerplayerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerm->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerm->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerm->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerm->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerm->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerm->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayern->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayern->ac = rn2(31)-20;				/* any AC */
	shamblerplayern->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayern->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayern->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayern->cnutrit = rnd(2000);					/* see above */
	shamblerplayern->msound = randmonsound();			/* any but the specials */
	shamblerplayern->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayern->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayern->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayern->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayern->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayern->mflags2 |= (1 << rn2(31));
	}
	shamblerplayern->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayern->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayern->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayero->mmove = rn3(18)+9;				/* slow to very fast */
	shamblerplayero->ac = rn2(35)-24;				/* any AC */
	shamblerplayero->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayero->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayero->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(20)+2;				/* either too high or too low */
	}
	shamblerplayero->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayero->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayero->cnutrit = rnd(2000);					/* see above */
	shamblerplayero->msound = randmonsound();			/* any but the specials */
	shamblerplayero->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayero->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayero->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayero->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayero->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayero->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayero->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayero->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayero->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayero->mflags2 |= (1 << rn2(31));
	}
	shamblerplayero->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayero->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayero->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayero->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayero->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerp->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerp->ac = rn2(40)-29;				/* any AC */
	shamblerplayerp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerp->cnutrit = rnd(2000);					/* see above */
	shamblerplayerp->msound = randmonsound();			/* any but the specials */
	shamblerplayerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerp->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerp->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerp->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerp->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerq->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerq->ac = rn2(40)-29;				/* any AC */
	shamblerplayerq->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerq->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerq->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerq->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerq->cnutrit = rnd(2000);					/* see above */
	shamblerplayerq->msound = randmonsound();			/* any but the specials */
	shamblerplayerq->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerq->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerq->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerq->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerq->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerq->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerq->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerq->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerq->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerq->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerq->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerq->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */



	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerr->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerr->ac = rn2(40)-29;				/* any AC */
	shamblerplayerr->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerr->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerr->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerr->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerr->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerr->cnutrit = rnd(2000);					/* see above */
	shamblerplayerr->msound = randmonsound();			/* any but the specials */
	shamblerplayerr->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerr->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerr->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerr->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerr->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerr->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerr->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerr->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerr->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerr->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerr->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerr->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerr->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */



	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayers->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayers->ac = rn2(40)-29;				/* any AC */
	shamblerplayers->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayers->cnutrit = rnd(2000);					/* see above */
	shamblerplayers->msound = randmonsound();			/* any but the specials */
	shamblerplayers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayers->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayers->mflags2 |= (1 << rn2(31));
	}
	shamblerplayers->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayers->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayers->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */


	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayert->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayert->ac = rn2(41)-30;				/* any AC */
	shamblerplayert->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayert->cnutrit = rnd(2000);					/* see above */
	shamblerplayert->msound = randmonsound();			/* any but the specials */
	shamblerplayert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayert->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayert->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayert->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayert->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayert->mflags2 |= (1 << rn2(31));
	}
	shamblerplayert->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayert->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayert->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayeru->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayeru->ac = rn2(42)-31;				/* any AC */
	shamblerplayeru->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeru->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayeru->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayeru->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeru->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeru->cnutrit = rnd(2000);					/* see above */
	shamblerplayeru->msound = randmonsound();			/* any but the specials */
	shamblerplayeru->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeru->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayeru->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeru->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeru->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeru->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeru->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeru->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeru->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeru->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeru->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeru->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeru->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeru->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeru->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerv->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerv->ac = rn2(42)-31;				/* any AC */
	shamblerplayerv->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerv->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerv->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerv->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerv->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerv->cnutrit = rnd(2000);					/* see above */
	shamblerplayerv->msound = randmonsound();			/* any but the specials */
	shamblerplayerv->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerv->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerv->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerv->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerv->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerv->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerv->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerv->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerv->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerv->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerv->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerv->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerv->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerv->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerv->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerflum->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerflum->ac = rn2(42)-31;				/* any AC */
	shamblerplayerflum->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerflum->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerflum->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerflum->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerflum->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerflum->cnutrit = rnd(2000);					/* see above */
	shamblerplayerflum->msound = randmonsound();			/* any but the specials */
	shamblerplayerflum->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerflum->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerflum->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerflum->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerflum->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerflum->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerflum->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerflum->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerflum->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerflum->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerflum->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerflum->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerflum->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerflum->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerflum->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerw->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerw->ac = rn2(42)-31;				/* any AC */
	shamblerplayerw->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerw->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerw->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerw->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerw->cnutrit = rnd(2000);					/* see above */
	shamblerplayerw->msound = randmonsound();			/* any but the specials */
	shamblerplayerw->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerw->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerw->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerw->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerw->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerw->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerw->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerw->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerw->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerw->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerw->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerw->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerw->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerx->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerx->ac = rn2(42)-31;				/* any AC */
	shamblerplayerx->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerx->cnutrit = rnd(2000);					/* see above */
	shamblerplayerx->msound = randmonsound();			/* any but the specials */
	shamblerplayerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerx->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerx->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerx->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerx->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerx->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayery->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayery->ac = rn2(42)-31;				/* any AC */
	shamblerplayery->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayery->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayery->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayery->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayery->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayery->cnutrit = rnd(2000);					/* see above */
	shamblerplayery->msound = randmonsound();			/* any but the specials */
	shamblerplayery->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayery->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayery->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayery->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayery->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayery->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayery->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayery->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayery->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayery->mflags2 |= (1 << rn2(31));
	}
	shamblerplayery->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayery->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayery->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayery->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayery->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerz->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerz->ac = rn2(42)-31;				/* any AC */
	shamblerplayerz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerz->cnutrit = rnd(2000);					/* see above */
	shamblerplayerz->msound = randmonsound();			/* any but the specials */
	shamblerplayerz->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerz->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerz->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerz->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerz->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayeraa->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayeraa->ac = rn2(43)-32;				/* any AC */
	shamblerplayeraa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeraa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayeraa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayeraa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeraa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeraa->cnutrit = rnd(2000);					/* see above */
	shamblerplayeraa->msound = randmonsound();			/* any but the specials */
	shamblerplayeraa->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayeraa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeraa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeraa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeraa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeraa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeraa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeraa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeraa->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeraa->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeraa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeraa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeraa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeraa->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeraa->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerab->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerab->ac = rn2(44)-33;				/* any AC */
	shamblerplayerab->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerab->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerab->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayerab->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerab->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerab->cnutrit = rnd(2000);					/* see above */
	shamblerplayerab->msound = randmonsound();			/* any but the specials */
	shamblerplayerab->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerab->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerab->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerab->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerab->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerab->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerab->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerab->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerab->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerab->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerab->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerab->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerab->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerab->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerac->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerac->ac = rn2(44)-33;				/* any AC */
	shamblerplayerac->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerac->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerac->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(26)+2;				/* either too high or too low */
	}
	shamblerplayerac->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerac->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerac->cnutrit = rnd(2000);					/* see above */
	shamblerplayerac->msound = randmonsound();			/* any but the specials */
	shamblerplayerac->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerac->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerac->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerac->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerac->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerac->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerac->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerac->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerac->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerac->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerac->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerac->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerac->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerac->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerad->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerad->ac = rn2(46)-36;				/* any AC */
	shamblerplayerad->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerad->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerad->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(26)+2;				/* either too high or too low */
	}
	shamblerplayerad->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerad->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerad->cnutrit = rnd(2000);					/* see above */
	shamblerplayerad->msound = randmonsound();			/* any but the specials */
	shamblerplayerad->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerad->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerad->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerad->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerad->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerad->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerad->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerad->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerad->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerad->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerad->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerad->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerad->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerad->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerad->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerae->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerae->ac = rn2(46)-36;				/* any AC */
	shamblerplayerae->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerae->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(27)+2;				/* either too high or too low */
	}
	shamblerplayerae->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerae->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerae->cnutrit = rnd(2000);					/* see above */
	shamblerplayerae->msound = randmonsound();			/* any but the specials */
	shamblerplayerae->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerae->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerae->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerae->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerae->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerae->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerae->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerae->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerae->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerae->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerae->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerae->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerae->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	splicemona->mmove = rn2(9)+9;				/* slow to very fast */
	splicemona->ac = rn2(18)-7;				/* any AC */
	splicemona->mr = rn2(5)*25;				/* varying amounts of MR */
	splicemona->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &splicemona->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	splicemona->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	splicemona->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	splicemona->cnutrit = rnd(2000);					/* see above */
	splicemona->msound = randmonsound();			/* any but the specials */
	splicemona->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		splicemona->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		splicemona->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	splicemona->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	splicemona->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		splicemona->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*splicemona->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*splicemona->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	splicemona->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		splicemona->mflags2 |= (1 << rn2(31));
	}
	splicemona->mflags2 &= ~M2_MERC;				/* no guards */
	splicemona->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	splicemona->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	splicemona->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	splicemonb->mmove = rn2(14)+9;				/* slow to very fast */
	splicemonb->ac = rn2(31)-20;				/* any AC */
	splicemonb->mr = rn2(5)*25;				/* varying amounts of MR */
	splicemonb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &splicemonb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	splicemonb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	splicemonb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	splicemonb->cnutrit = rnd(2000);					/* see above */
	splicemonb->msound = randmonsound();			/* any but the specials */
	splicemonb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		splicemonb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		splicemonb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	splicemonb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	splicemonb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		splicemonb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	splicemonb->mflags1 &= ~M1_HIDE;				/* no hiding */

	splicemonb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		splicemonb->mflags2 |= (1 << rn2(31));
	}
	splicemonb->mflags2 &= ~M2_MERC;				/* no guards */
	splicemonb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	splicemonb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	splicemonb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	if (!rn2(10)) {
	attkptr = &deathraylord->mattk[4]; /* Yeenoghu gets finger of death */
	attkptr->aatyp = AT_MAGC; /* well, at least one out of ten games he does */
	attkptr->adtyp = AD_DISN; /* as a tribute to that fallthrough "bug" where he got a touch of death --Amy */
	attkptr->damn = 2;
	attkptr->damd = 6;
	}

	lolirace->msound = !rn2(3) ? MS_FART_NORMAL : !rn2(2) ? MS_FART_QUIET : MS_FART_LOUD;

	if (!rn2(10)) {
	attkptr = &coldlord->mattk[1]; /* evil patch idea by irinya: because nobody actually knows how much damage Asmodeus's cold attack does, it's been bumped up to 60d6 */
	attkptr->damn = 60;
	}

	/* evil patch idea by hackedhead: rider-gating */
	/* evil patch idea by Wooble: make the riders covetous */

	if (!rn2(10)) riderone->mflags2 |= M2_DEMON;
	if (!rn2(10)) riderone->mflags3 |= M3_WANTSBOOK;
	if (!rn2(10)) ridertwo->mflags2 |= M2_DEMON;
	if (!rn2(10)) ridertwo->mflags3 |= M3_WANTSBOOK;
	if (!rn2(10)) riderthree->mflags2 |= M2_DEMON;
	if (!rn2(10)) riderthree->mflags3 |= M3_WANTSBOOK;

	/* the multicolor grue has a AD_RBRE breath attack, but there is no AD_RBRE for melee attacks (yet).
	 * So we're just giving it some random damage types for its melee and passive attack. --Amy */
	for (i = 0; i < 2; i++) {
		attkptr = &multigrue->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	/* similar stuff for some other monsters */

	for (i = 0; i < 2; i++) {
		attkptr = &randomeye->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandommimic, buf, sizeof(buf) );
	rrandommimic->mname = u.strandommimic;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandommimicb, buf, sizeof(buf) );
	rrandommimicb->mname = u.strandommimicb;

	randommimic->mmove = rnd(10)+2;
	randommimic->ac = 5-rnd(20);
	randommimic->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randommimic->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randommimicb->mmove = rnd(10)+2;
	randommimicb->ac = 5-rnd(20);
	randommimicb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randommimicb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randompiercer->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomvortex->mmove = rnd(10)+6;
	randomvortex->ac = 0-rnd(16);
	randomvortex->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomvortex->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungus->ac = 10-rnd(25);
	randomfungus->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungus->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusb->mmove = rnd(12);
	randomfungusb->ac = 10-rnd(25);
	randomfungusb->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusba->mmove = rnd(12);
	randomfungusba->ac = 10-rnd(25);
	randomfungusba->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusba->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbb->mmove = rnd(12);
	randomfungusbb->ac = 10-rnd(25);
	randomfungusbb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbbe->mmove = rnd(12);
	randomfungusbbe->ac = 10-rnd(25);
	randomfungusbbe->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbbe->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbc->mmove = rnd(12);
	randomfungusbc->ac = 10-rnd(25);
	randomfungusbc->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbd->mmove = rnd(12);
	randomfungusbd->ac = 10-rnd(25);
	randomfungusbd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbe->mmove = rnd(12);
	randomfungusbe->ac = 10-rnd(25);
	randomfungusbe->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbe->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusc->ac = 10-rnd(35);
	randomfungusc->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungusc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusd->mmove = rnd(15);
	randomfungusd->ac = 10-rnd(35);
	randomfungusd->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusda->mmove = rnd(15);
	randomfungusda->ac = 10-rnd(35);
	randomfungusda->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusda->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdb->mmove = rnd(15);
	randomfungusdb->ac = 10-rnd(35);
	randomfungusdb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdbx->mmove = rnd(15);
	randomfungusdbx->ac = 10-rnd(35);
	randomfungusdbx->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdbx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdc->mmove = rnd(15);
	randomfungusdc->ac = 10-rnd(35);
	randomfungusdc->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdd->mmove = rnd(15);
	randomfungusdd->ac = 10-rnd(35);
	randomfungusdd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusde->mmove = rnd(15);
	randomfungusde->ac = 10-rnd(35);
	randomfungusde->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusde->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfunguse->ac = 10-rnd(25);
	randomfunguse->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfunguse->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusf->mmove = rnd(12);
	randomfungusf->ac = 10-rnd(25);
	randomfungusf->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusg->mmove = rnd(12);
	randomfungusg->ac = 10-rnd(25);
	randomfungusg->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungush->mmove = rnd(12);
	randomfungush->ac = 10-rnd(25);
	randomfungush->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungush->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusi->mmove = rnd(12);
	randomfungusi->ac = 10-rnd(25);
	randomfungusi->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusj->ac = 10-rnd(35);
	randomfungusj->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungusj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusk->mmove = rnd(15);
	randomfungusk->ac = 10-rnd(35);
	randomfungusk->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusl->mmove = rnd(15);
	randomfungusl->ac = 10-rnd(35);
	randomfungusl->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusm->mmove = rnd(15);
	randomfungusm->ac = 10-rnd(35);
	randomfungusm->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusm->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusn->mmove = rnd(15);
	randomfungusn->ac = 10-rnd(35);
	randomfungusn->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusn->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	rrandomfungusa->ac = 10-rnd(30);
	rrandomfungusa->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &rrandomfungusa->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungus, buf, sizeof(buf) );
	rrandomfungusa->mname = u.strandomfungus;

	rrandomfungusb->mmove = rnd(12);
	rrandomfungusb->ac = 10-rnd(30);
	rrandomfungusb->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusb, buf, sizeof(buf) );
	rrandomfungusb->mname = u.strandomfungusb;

	rrandomfungusc->mmove = rnd(12);
	rrandomfungusc->ac = 10-rnd(30);
	rrandomfungusc->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusc, buf, sizeof(buf) );
	rrandomfungusc->mname = u.strandomfungusc;

	rrandomfungusd->mmove = rnd(12);
	rrandomfungusd->ac = 10-rnd(30);
	rrandomfungusd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusd, buf, sizeof(buf) );
	rrandomfungusd->mname = u.strandomfungusd;

	rrandomfungusdx->mmove = rnd(12);
	rrandomfungusdx->ac = 10-rnd(30);
	rrandomfungusdx->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusdx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusdx, buf, sizeof(buf) );
	rrandomfungusdx->mname = u.strandomfungusd;

	rrandomfunguse->mmove = rnd(12);
	rrandomfunguse->ac = 10-rnd(30);
	rrandomfunguse->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfunguse->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfunguse, buf, sizeof(buf) );
	rrandomfunguse->mname = u.strandomfunguse;

	rrandomfungusf->mmove = rnd(12);
	rrandomfungusf->ac = 10-rnd(30);
	rrandomfungusf->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusf, buf, sizeof(buf) );
	rrandomfungusf->mname = u.strandomfungusf;

	rrandomfungusg->mmove = rnd(12);
	rrandomfungusg->ac = 10-rnd(30);
	rrandomfungusg->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusg, buf, sizeof(buf) );
	rrandomfungusg->mname = u.strandomfungusg;

	rrandomfungush->ac = 10-rnd(30);
	rrandomfungush->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &rrandomfungush->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungush, buf, sizeof(buf) );
	rrandomfungush->mname = u.strandomfungush;

	rrandomfungusi->mmove = rnd(12);
	rrandomfungusi->ac = 10-rnd(30);
	rrandomfungusi->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusi, buf, sizeof(buf) );
	rrandomfungusi->mname = u.strandomfungusi;

	rrandomfungusj->mmove = rnd(12);
	rrandomfungusj->ac = 10-rnd(30);
	rrandomfungusj->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusj, buf, sizeof(buf) );
	rrandomfungusj->mname = u.strandomfungusj;

	rrandomfungusk->mmove = rnd(12);
	rrandomfungusk->ac = 10-rnd(30);
	rrandomfungusk->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusk, buf, sizeof(buf) );
	rrandomfungusk->mname = u.strandomfungusk;

	rrandomfungusl->mmove = rnd(12);
	rrandomfungusl->ac = 10-rnd(30);
	rrandomfungusl->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusl, buf, sizeof(buf) );
	rrandomfungusl->mname = u.strandomfungusl;

	randomtroll->mmove = rnd(6)+10;
	randomtroll->ac = 0-rnd(20);
	randomtroll->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomtroll->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randomeel->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragon->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilera->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoileri->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}

	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerl->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerl->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerl->ac = rn2(26)-15;				/* any AC */
	randspoilerl->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerl->maligntyp = rn2(21)-10;			/* any alignment */
	randspoilerl->msound = randmonsound();			/* any but the specials */

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerm->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerm->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerm->ac = rn2(26)-15;				/* any AC */
	randspoilerm->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerm->maligntyp = rn2(21)-10;			/* any alignment */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilern->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilern->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilern->ac = rn2(36)-15;				/* any AC */
	randspoilern->mr = rn2(5)*25;				/* varying amounts of MR */

	randspoilern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilern->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilern->mflags2 |= (1 << rn2(31));
	}
	randspoilern->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilern->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilern->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilero->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilero->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilero->ac = rn2(36)-15;				/* any AC */
	randspoilero->mr = rn2(5)*25;				/* varying amounts of MR */

	randspoilero->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilero->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilero->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilero->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilero->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilero->mflags2 |= (1 << rn2(31));
	}
	randspoilero->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilero->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilero->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilero->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilero->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilerp->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerp->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilerp->ac = rn2(36)-15;				/* any AC */
	randspoilerp->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerp->msound = randmonsound();	

	randspoilerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerp->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilerp->mflags2 |= (1 << rn2(31));
	}
	randspoilerp->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilerp->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilerp->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilerq->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerq->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilerq->ac = rn2(36)-15;				/* any AC */
	randspoilerq->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerq->msound = randmonsound();	

	randspoilerq->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerq->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerq->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilerq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilerq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilerq->mflags2 |= (1 << rn2(31));
	}
	randspoilerq->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerq->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilerq->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilerq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 2; i++) {
		attkptr = &randfluidator->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
	}
	randfluidator->mmove = rn2(9)+9;				/* slow to very fast */
	randfluidator->ac = rn2(18)-7;				/* any AC */
	randfluidator->mr = rn2(5)*25;				/* varying amounts of MR */
	randfluidator->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randfluidator->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		attkptr = &randfluidatorb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
	}
	randfluidatorb->mmove = rn2(14)+9;				/* slow to very fast */
	randfluidatorb->ac = rn2(31)-20;				/* any AC */
	randfluidatorb->mr = rn2(5)*25;				/* varying amounts of MR */
	randfluidatorb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randfluidatorb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxya->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 4; i++) {
		attkptr = &randxyd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 3; i++) {
		attkptr = &randxye->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

		attkptr = &randxyf->mattk[1];
		attkptr->adtyp = randxyf->mattk[0].adtyp;


	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randxyi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 4; i++) {
		attkptr = &randxyj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxym->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyn->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyo->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyp->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyq->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyr->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxys->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyt->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxytX->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxytY->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyu->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyv->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyw->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 3; i < 4; i++) {
		attkptr = &randxyx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyy->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 3; i++) {
		attkptr = &randxyz->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randhybrid->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyaa->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randxyab->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyac->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomsphere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomlight->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomlightB->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightC->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightD->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightE->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightF->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randomlightG->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &shadowwarrior->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &shadowwarriorX->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonb->mcolor = rnd(15);
		if (randomdragonb->mcolor == 4) randomdragonb->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonc->mcolor = rnd(15);
		if (randomdragonc->mcolor == 4) randomdragonc->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragond->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragond->mcolor = rnd(15);
		if (randomdragond->mcolor == 4) randomdragond->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragone->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragone->mcolor = rnd(15);
		if (randomdragone->mcolor == 4) randomdragone->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonf->mcolor = rnd(15);
		if (randomdragonf->mcolor == 4) randomdragonf->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragong->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragong->mcolor = rnd(15);
		if (randomdragong->mcolor == 4) randomdragong->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonh->mcolor = rnd(15);
		if (randomdragonh->mcolor == 4) randomdragonh->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragoni->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragoni->mcolor = rnd(15);
		if (randomdragoni->mcolor == 4) randomdragoni->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonj->mcolor = rnd(15);
		if (randomdragonj->mcolor == 4) randomdragonj->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonk->mcolor = rnd(15);
		if (randomdragonk->mcolor == 4) randomdragonk->mcolor = 12;
	}

	randombdragonb->mcolor = randomdragonb->mcolor;
	randombdragonc->mcolor = randomdragonc->mcolor;
	randombdragond->mcolor = randomdragond->mcolor;
	randombdragone->mcolor = randomdragone->mcolor;
	randombdragonf->mcolor = randomdragonf->mcolor;
	randombdragong->mcolor = randomdragong->mcolor;
	randombdragonh->mcolor = randomdragonh->mcolor;
	randombdragoni->mcolor = randomdragoni->mcolor;
	randombdragonj->mcolor = randomdragonj->mcolor;
	randombdragonk->mcolor = randomdragonk->mcolor;

	for (i = 0; i < 1; i++) {
		attkptr = &rrandomdragonb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		rrandomdragonb->mcolor = rnd(15);
		if (rrandomdragonb->mcolor == 4) rrandomdragonb->mcolor = 12;

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomdragonb, buf, sizeof(buf) );
	rrandomdragonb->mname = u.strandomdragonb;

	for (i = 0; i < 1; i++) {
		attkptr = &rrandomdragonc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		rrandomdragonc->mcolor = rnd(15);
		if (rrandomdragonc->mcolor == 4) rrandomdragonc->mcolor = 12;

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomdragonc, buf, sizeof(buf) );
	rrandomdragonc->mname = u.strandomdragonc;

	rrandombdragonb->mcolor = rrandomdragonb->mcolor;
	rrandombdragonc->mcolor = rrandomdragonc->mcolor;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandombdragonb, buf, sizeof(buf) );
	rrandombdragonb->mname = u.strandombdragonb;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandombdragonc, buf, sizeof(buf) );
	rrandombdragonc->mname = u.strandombdragonc;

	for (i = 1; i < 2; i++) {
		attkptr = &randomflyfish->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randomturret->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomkop->mmove = rn2(10)+9;				/* slow to very fast */
	randomkop->ac = rn2(21)-10;				/* any AC */
	randomkop->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &randomkop->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	randomkop->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkop->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkop->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkop->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkop->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkop->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkop->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkop->mflags2 |= (1 << rn2(31));
	}
	randomkop->mflags2 &= ~M2_MERC;				/* no guards */
	randomkop->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkop->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkop->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randomkopb->mmove = rn2(14)+9;				/* slow to very fast */
	randomkopb->ac = rn2(31)-20;				/* any AC */
	randomkopb->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randomkopb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	randomkopb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkopb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkopb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkopb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkopb->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkopb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkopb->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkopb->mflags2 |= (1 << rn2(31));
	}
	randomkopb->mflags2 &= ~M2_MERC;				/* no guards */
	randomkopb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkopb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkopb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	rrandomkopb->mmove = rn2(14)+9;				/* slow to very fast */
	rrandomkopb->ac = rn2(31)-20;				/* any AC */
	rrandomkopb->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rrandomkopb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rrandomkopb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rrandomkopb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rrandomkopb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rrandomkopb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rrandomkopb->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		rrandomkopb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	rrandomkopb->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rrandomkopb->mflags2 |= (1 << rn2(31));
	}
	rrandomkopb->mflags2 &= ~M2_MERC;				/* no guards */
	rrandomkopb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rrandomkopb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rrandomkopb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomkopb, buf, sizeof(buf) );
	rrandomkopb->mname = u.strandomkopb;

	randomkopc->mmove = rn2(20)+9;				/* slow to very fast */
	randomkopc->ac = rn2(40)-29;				/* any AC */
	randomkopc->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &randomkopc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	randomkopc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkopc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkopc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkopc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkopc->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkopc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkopc->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkopc->mflags2 |= (1 << rn2(31));
	}
	randomkopc->mflags2 &= ~M2_MERC;				/* no guards */
	randomkopc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkopc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkopc->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompeji->mmove = rn2(15)+9;				/* slow to very fast */
	randompompeji->ac = rn2(26)-15;				/* any AC */
	randompompeji->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &randompompeji->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+2;				/* either too high or too low */
	}
	randompompeji->mresists = 0;
	for (i = 0; i < rnd(8); i++) {
		randompompeji->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompeji->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompeji->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompeji->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompeji->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompeji->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompeji->mflags2 |= (1 << rn2(31));
	}
	randompompeji->mflags2 &= ~M2_MERC;				/* no guards */
	randompompeji->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompeji->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompeji->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompejib->mmove = rn2(20)+9;				/* slow to very fast */
	randompompejib->ac = rn2(41)-30;				/* any AC */
	randompompejib->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randompompejib->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+2;				/* either too high or too low */
	}
	randompompejib->mresists = 0;
	for (i = 0; i < rnd(10); i++) {
		randompompejib->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompejib->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompejib->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompejib->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompejib->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompejib->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompejib->mflags2 |= (1 << rn2(31));
	}
	randompompejib->mflags2 &= ~M2_MERC;				/* no guards */
	randompompejib->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompejib->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompejib->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompejic->mmove = rn2(27)+9;				/* slow to very fast */
	randompompejic->ac = rn2(55)-44;				/* any AC */
	randompompejic->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &randompompejic->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(32)+2;				/* either too high or too low */
	}
	randompompejic->mresists = 0;
	for (i = 0; i < rnd(12); i++) {
		randompompejic->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompejic->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompejic->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompejic->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompejic->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompejic->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompejic->mflags2 |= (1 << rn2(31));
	}
	randompompejic->mflags2 &= ~M2_MERC;				/* no guards */
	randompompejic->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompejic->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompejic->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* Starlit sky monsters are an invention of my roommate. It's a name that she gave to a glitch monster
	 * in Castle of the Winds. --Amy */

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel > 5)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlita->mmove = mons[starlitmonster].mmove;
	starlita->ac = mons[starlitmonster].ac;
	starlita->mr = mons[starlitmonster].mr;
	starlita->maligntyp = mons[starlitmonster].maligntyp;
	starlita->mattk[0] = mons[starlitmonster].mattk[0];
	starlita->mattk[1] = mons[starlitmonster].mattk[1];
	starlita->mattk[2] = mons[starlitmonster].mattk[2];
	starlita->mattk[3] = mons[starlitmonster].mattk[3];
	starlita->mattk[4] = mons[starlitmonster].mattk[4];
	starlita->mattk[5] = mons[starlitmonster].mattk[5];
	starlita->cwt = mons[starlitmonster].cwt;
	starlita->cnutrit = mons[starlitmonster].cnutrit;
	starlita->msound = mons[starlitmonster].msound;
	starlita->msize = mons[starlitmonster].msize;
	starlita->mresists = mons[starlitmonster].mresists;
	starlita->mflags1 = mons[starlitmonster].mflags1;
	starlita->mflags2 = mons[starlitmonster].mflags2;
	starlita->mflags3 = mons[starlitmonster].mflags3;

	starlita->mflags2 &= ~M2_NOPOLY;
	starlita->mflags2 &= ~M2_MERC;
	starlita->mflags2 &= ~M2_WERE;
	starlita->mflags2 &= ~M2_PNAME;
	starlita->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 5) || (mons[starlitmonster].mlevel > 10)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitb->mmove = mons[starlitmonster].mmove;
	starlitb->ac = mons[starlitmonster].ac;
	starlitb->mr = mons[starlitmonster].mr;
	starlitb->maligntyp = mons[starlitmonster].maligntyp;
	starlitb->mattk[0] = mons[starlitmonster].mattk[0];
	starlitb->mattk[1] = mons[starlitmonster].mattk[1];
	starlitb->mattk[2] = mons[starlitmonster].mattk[2];
	starlitb->mattk[3] = mons[starlitmonster].mattk[3];
	starlitb->mattk[4] = mons[starlitmonster].mattk[4];
	starlitb->mattk[5] = mons[starlitmonster].mattk[5];
	starlitb->cwt = mons[starlitmonster].cwt;
	starlitb->cnutrit = mons[starlitmonster].cnutrit;
	starlitb->msound = mons[starlitmonster].msound;
	starlitb->msize = mons[starlitmonster].msize;
	starlitb->mresists = mons[starlitmonster].mresists;
	starlitb->mflags1 = mons[starlitmonster].mflags1;
	starlitb->mflags2 = mons[starlitmonster].mflags2;
	starlitb->mflags3 = mons[starlitmonster].mflags3;

	starlitb->mflags2 &= ~M2_NOPOLY;
	starlitb->mflags2 &= ~M2_MERC;
	starlitb->mflags2 &= ~M2_WERE;
	starlitb->mflags2 &= ~M2_PNAME;
	starlitb->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 10) || (mons[starlitmonster].mlevel > 15)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitc->mmove = mons[starlitmonster].mmove;
	starlitc->ac = mons[starlitmonster].ac;
	starlitc->mr = mons[starlitmonster].mr;
	starlitc->maligntyp = mons[starlitmonster].maligntyp;
	starlitc->mattk[0] = mons[starlitmonster].mattk[0];
	starlitc->mattk[1] = mons[starlitmonster].mattk[1];
	starlitc->mattk[2] = mons[starlitmonster].mattk[2];
	starlitc->mattk[3] = mons[starlitmonster].mattk[3];
	starlitc->mattk[4] = mons[starlitmonster].mattk[4];
	starlitc->mattk[5] = mons[starlitmonster].mattk[5];
	starlitc->cwt = mons[starlitmonster].cwt;
	starlitc->cnutrit = mons[starlitmonster].cnutrit;
	starlitc->msound = mons[starlitmonster].msound;
	starlitc->msize = mons[starlitmonster].msize;
	starlitc->mresists = mons[starlitmonster].mresists;
	starlitc->mflags1 = mons[starlitmonster].mflags1;
	starlitc->mflags2 = mons[starlitmonster].mflags2;
	starlitc->mflags3 = mons[starlitmonster].mflags3;

	starlitc->mflags2 &= ~M2_NOPOLY;
	starlitc->mflags2 &= ~M2_MERC;
	starlitc->mflags2 &= ~M2_WERE;
	starlitc->mflags2 &= ~M2_PNAME;
	starlitc->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 15) || (mons[starlitmonster].mlevel > 20)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitd->mmove = mons[starlitmonster].mmove;
	starlitd->ac = mons[starlitmonster].ac;
	starlitd->mr = mons[starlitmonster].mr;
	starlitd->maligntyp = mons[starlitmonster].maligntyp;
	starlitd->mattk[0] = mons[starlitmonster].mattk[0];
	starlitd->mattk[1] = mons[starlitmonster].mattk[1];
	starlitd->mattk[2] = mons[starlitmonster].mattk[2];
	starlitd->mattk[3] = mons[starlitmonster].mattk[3];
	starlitd->mattk[4] = mons[starlitmonster].mattk[4];
	starlitd->mattk[5] = mons[starlitmonster].mattk[5];
	starlitd->cwt = mons[starlitmonster].cwt;
	starlitd->cnutrit = mons[starlitmonster].cnutrit;
	starlitd->msound = mons[starlitmonster].msound;
	starlitd->msize = mons[starlitmonster].msize;
	starlitd->mresists = mons[starlitmonster].mresists;
	starlitd->mflags1 = mons[starlitmonster].mflags1;
	starlitd->mflags2 = mons[starlitmonster].mflags2;
	starlitd->mflags3 = mons[starlitmonster].mflags3;

	starlitd->mflags2 &= ~M2_NOPOLY;
	starlitd->mflags2 &= ~M2_MERC;
	starlitd->mflags2 &= ~M2_WERE;
	starlitd->mflags2 &= ~M2_PNAME;
	starlitd->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 20) || (mons[starlitmonster].mlevel > 25)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlite->mmove = mons[starlitmonster].mmove;
	starlite->ac = mons[starlitmonster].ac;
	starlite->mr = mons[starlitmonster].mr;
	starlite->maligntyp = mons[starlitmonster].maligntyp;
	starlite->mattk[0] = mons[starlitmonster].mattk[0];
	starlite->mattk[1] = mons[starlitmonster].mattk[1];
	starlite->mattk[2] = mons[starlitmonster].mattk[2];
	starlite->mattk[3] = mons[starlitmonster].mattk[3];
	starlite->mattk[4] = mons[starlitmonster].mattk[4];
	starlite->mattk[5] = mons[starlitmonster].mattk[5];
	starlite->cwt = mons[starlitmonster].cwt;
	starlite->cnutrit = mons[starlitmonster].cnutrit;
	starlite->msound = mons[starlitmonster].msound;
	starlite->msize = mons[starlitmonster].msize;
	starlite->mresists = mons[starlitmonster].mresists;
	starlite->mflags1 = mons[starlitmonster].mflags1;
	starlite->mflags2 = mons[starlitmonster].mflags2;
	starlite->mflags3 = mons[starlitmonster].mflags3;

	starlite->mflags2 &= ~M2_NOPOLY;
	starlite->mflags2 &= ~M2_MERC;
	starlite->mflags2 &= ~M2_WERE;
	starlite->mflags2 &= ~M2_PNAME;
	starlite->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 25) || (mons[starlitmonster].mlevel > 30)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitf->mmove = mons[starlitmonster].mmove;
	starlitf->ac = mons[starlitmonster].ac;
	starlitf->mr = mons[starlitmonster].mr;
	starlitf->maligntyp = mons[starlitmonster].maligntyp;
	starlitf->mattk[0] = mons[starlitmonster].mattk[0];
	starlitf->mattk[1] = mons[starlitmonster].mattk[1];
	starlitf->mattk[2] = mons[starlitmonster].mattk[2];
	starlitf->mattk[3] = mons[starlitmonster].mattk[3];
	starlitf->mattk[4] = mons[starlitmonster].mattk[4];
	starlitf->mattk[5] = mons[starlitmonster].mattk[5];
	starlitf->cwt = mons[starlitmonster].cwt;
	starlitf->cnutrit = mons[starlitmonster].cnutrit;
	starlitf->msound = mons[starlitmonster].msound;
	starlitf->msize = mons[starlitmonster].msize;
	starlitf->mresists = mons[starlitmonster].mresists;
	starlitf->mflags1 = mons[starlitmonster].mflags1;
	starlitf->mflags2 = mons[starlitmonster].mflags2;
	starlitf->mflags3 = mons[starlitmonster].mflags3;

	starlitf->mflags2 &= ~M2_NOPOLY;
	starlitf->mflags2 &= ~M2_MERC;
	starlitf->mflags2 &= ~M2_WERE;
	starlitf->mflags2 &= ~M2_PNAME;
	starlitf->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 30) || (mons[starlitmonster].mlevel > 35)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitg->mmove = mons[starlitmonster].mmove;
	starlitg->ac = mons[starlitmonster].ac;
	starlitg->mr = mons[starlitmonster].mr;
	starlitg->maligntyp = mons[starlitmonster].maligntyp;
	starlitg->mattk[0] = mons[starlitmonster].mattk[0];
	starlitg->mattk[1] = mons[starlitmonster].mattk[1];
	starlitg->mattk[2] = mons[starlitmonster].mattk[2];
	starlitg->mattk[3] = mons[starlitmonster].mattk[3];
	starlitg->mattk[4] = mons[starlitmonster].mattk[4];
	starlitg->mattk[5] = mons[starlitmonster].mattk[5];
	starlitg->cwt = mons[starlitmonster].cwt;
	starlitg->cnutrit = mons[starlitmonster].cnutrit;
	starlitg->msound = mons[starlitmonster].msound;
	starlitg->msize = mons[starlitmonster].msize;
	starlitg->mresists = mons[starlitmonster].mresists;
	starlitg->mflags1 = mons[starlitmonster].mflags1;
	starlitg->mflags2 = mons[starlitmonster].mflags2;
	starlitg->mflags3 = mons[starlitmonster].mflags3;

	starlitg->mflags2 &= ~M2_NOPOLY;
	starlitg->mflags2 &= ~M2_MERC;
	starlitg->mflags2 &= ~M2_WERE;
	starlitg->mflags2 &= ~M2_PNAME;
	starlitg->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 35) || (mons[starlitmonster].mlevel > 40)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlith->mmove = mons[starlitmonster].mmove;
	starlith->ac = mons[starlitmonster].ac;
	starlith->mr = mons[starlitmonster].mr;
	starlith->maligntyp = mons[starlitmonster].maligntyp;
	starlith->mattk[0] = mons[starlitmonster].mattk[0];
	starlith->mattk[1] = mons[starlitmonster].mattk[1];
	starlith->mattk[2] = mons[starlitmonster].mattk[2];
	starlith->mattk[3] = mons[starlitmonster].mattk[3];
	starlith->mattk[4] = mons[starlitmonster].mattk[4];
	starlith->mattk[5] = mons[starlitmonster].mattk[5];
	starlith->cwt = mons[starlitmonster].cwt;
	starlith->cnutrit = mons[starlitmonster].cnutrit;
	starlith->msound = mons[starlitmonster].msound;
	starlith->msize = mons[starlitmonster].msize;
	starlith->mresists = mons[starlitmonster].mresists;
	starlith->mflags1 = mons[starlitmonster].mflags1;
	starlith->mflags2 = mons[starlitmonster].mflags2;
	starlith->mflags3 = mons[starlitmonster].mflags3;

	starlith->mflags2 &= ~M2_NOPOLY;
	starlith->mflags2 &= ~M2_MERC;
	starlith->mflags2 &= ~M2_WERE;
	starlith->mflags2 &= ~M2_PNAME;
	starlith->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 40) || (mons[starlitmonster].mlevel > 50)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starliti->mmove = mons[starlitmonster].mmove;
	starliti->ac = mons[starlitmonster].ac;
	starliti->mr = mons[starlitmonster].mr;
	starliti->maligntyp = mons[starlitmonster].maligntyp;
	starliti->mattk[0] = mons[starlitmonster].mattk[0];
	starliti->mattk[1] = mons[starlitmonster].mattk[1];
	starliti->mattk[2] = mons[starlitmonster].mattk[2];
	starliti->mattk[3] = mons[starlitmonster].mattk[3];
	starliti->mattk[4] = mons[starlitmonster].mattk[4];
	starliti->mattk[5] = mons[starlitmonster].mattk[5];
	starliti->cwt = mons[starlitmonster].cwt;
	starliti->cnutrit = mons[starlitmonster].cnutrit;
	starliti->msound = mons[starlitmonster].msound;
	starliti->msize = mons[starlitmonster].msize;
	starliti->mresists = mons[starlitmonster].mresists;
	starliti->mflags1 = mons[starlitmonster].mflags1;
	starliti->mflags2 = mons[starlitmonster].mflags2;
	starliti->mflags3 = mons[starlitmonster].mflags3;

	starliti->mflags2 &= ~M2_NOPOLY;
	starliti->mflags2 &= ~M2_MERC;
	starliti->mflags2 &= ~M2_WERE;
	starliti->mflags2 &= ~M2_PNAME;
	starliti->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 50) || (mons[starlitmonster].mlevel > 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitj->mmove = mons[starlitmonster].mmove;
	starlitj->ac = mons[starlitmonster].ac;
	starlitj->mr = mons[starlitmonster].mr;
	starlitj->maligntyp = mons[starlitmonster].maligntyp;
	starlitj->mattk[0] = mons[starlitmonster].mattk[0];
	starlitj->mattk[1] = mons[starlitmonster].mattk[1];
	starlitj->mattk[2] = mons[starlitmonster].mattk[2];
	starlitj->mattk[3] = mons[starlitmonster].mattk[3];
	starlitj->mattk[4] = mons[starlitmonster].mattk[4];
	starlitj->mattk[5] = mons[starlitmonster].mattk[5];
	starlitj->cwt = mons[starlitmonster].cwt;
	starlitj->cnutrit = mons[starlitmonster].cnutrit;
	starlitj->msound = mons[starlitmonster].msound;
	starlitj->msize = mons[starlitmonster].msize;
	starlitj->mresists = mons[starlitmonster].mresists;
	starlitj->mflags1 = mons[starlitmonster].mflags1;
	starlitj->mflags2 = mons[starlitmonster].mflags2;
	starlitj->mflags3 = mons[starlitmonster].mflags3;

	starlitj->mflags2 &= ~M2_NOPOLY;
	starlitj->mflags2 &= ~M2_MERC;
	starlitj->mflags2 &= ~M2_WERE;
	starlitj->mflags2 &= ~M2_PNAME;
	starlitj->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 50) || (mons[starlitmonster].mlevel > 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitffx->mmove = mons[starlitmonster].mmove;
	starlitffx->ac = mons[starlitmonster].ac;
	starlitffx->mr = mons[starlitmonster].mr;
	starlitffx->maligntyp = mons[starlitmonster].maligntyp;
	starlitffx->mattk[0] = mons[starlitmonster].mattk[0];
	starlitffx->mattk[1] = mons[starlitmonster].mattk[1];
	starlitffx->mattk[2] = mons[starlitmonster].mattk[2];
	starlitffx->mattk[3] = mons[starlitmonster].mattk[3];
	starlitffx->mattk[4] = mons[starlitmonster].mattk[4];
	starlitffx->mattk[5] = mons[starlitmonster].mattk[5];
	starlitffx->cwt = mons[starlitmonster].cwt;
	starlitffx->cnutrit = mons[starlitmonster].cnutrit;
	starlitffx->msound = mons[starlitmonster].msound;
	starlitffx->msize = mons[starlitmonster].msize;
	starlitffx->mresists = mons[starlitmonster].mresists;
	starlitffx->mflags1 = mons[starlitmonster].mflags1;
	starlitffx->mflags2 = mons[starlitmonster].mflags2;
	starlitffx->mflags3 = mons[starlitmonster].mflags3;

	starlitffx->mflags2 &= ~M2_NOPOLY;
	starlitffx->mflags2 &= ~M2_MERC;
	starlitffx->mflags2 &= ~M2_WERE;
	starlitffx->mflags2 &= ~M2_PNAME;
	starlitffx->mflags2 &= ~M2_PEACEFUL;

	starlitffx->mflags3 |= M3_NOPLRPOLY;
	starlitffx->mflags3 |= M3_NOTAME;
	starlitffx->mflags3 |= M3_MIMIC;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitk->mmove = mons[starlitmonster].mmove;
	starlitk->ac = mons[starlitmonster].ac;
	starlitk->mr = mons[starlitmonster].mr;
	starlitk->maligntyp = mons[starlitmonster].maligntyp;
	starlitk->mattk[0] = mons[starlitmonster].mattk[0];
	starlitk->mattk[1] = mons[starlitmonster].mattk[1];
	starlitk->mattk[2] = mons[starlitmonster].mattk[2];
	starlitk->mattk[3] = mons[starlitmonster].mattk[3];
	starlitk->mattk[4] = mons[starlitmonster].mattk[4];
	starlitk->mattk[5] = mons[starlitmonster].mattk[5];
	starlitk->cwt = mons[starlitmonster].cwt;
	starlitk->cnutrit = mons[starlitmonster].cnutrit;
	starlitk->msound = mons[starlitmonster].msound;
	starlitk->msize = mons[starlitmonster].msize;
	starlitk->mresists = mons[starlitmonster].mresists;
	starlitk->mflags1 = mons[starlitmonster].mflags1;
	starlitk->mflags2 = mons[starlitmonster].mflags2;
	starlitk->mflags3 = mons[starlitmonster].mflags3;

	starlitk->mflags2 &= ~M2_NOPOLY;
	starlitk->mflags2 &= ~M2_MERC;
	starlitk->mflags2 &= ~M2_WERE;
	starlitk->mflags2 &= ~M2_PNAME;
	starlitk->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel > 5)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitl->mmove = mons[starlitmonster].mmove;
	starlitl->ac = mons[starlitmonster].ac;
	starlitl->mr = mons[starlitmonster].mr;
	starlitl->maligntyp = mons[starlitmonster].maligntyp;
	starlitl->mattk[0] = mons[starlitmonster].mattk[0];
	starlitl->mattk[1] = mons[starlitmonster].mattk[1];
	starlitl->mattk[2] = mons[starlitmonster].mattk[2];
	starlitl->mattk[3] = mons[starlitmonster].mattk[3];
	starlitl->mattk[4] = mons[starlitmonster].mattk[4];
	starlitl->mattk[5] = mons[starlitmonster].mattk[5];
	starlitl->cwt = mons[starlitmonster].cwt;
	starlitl->cnutrit = mons[starlitmonster].cnutrit;
	starlitl->msound = mons[starlitmonster].msound;
	starlitl->msize = mons[starlitmonster].msize;
	starlitl->mresists = mons[starlitmonster].mresists;
	starlitl->mflags1 = mons[starlitmonster].mflags1;
	starlitl->mflags2 = mons[starlitmonster].mflags2;
	starlitl->mflags3 = mons[starlitmonster].mflags3;

	starlitl->mflags2 &= ~M2_NOPOLY;
	starlitl->mflags2 &= ~M2_MERC;
	starlitl->mflags2 &= ~M2_WERE;
	starlitl->mflags2 &= ~M2_PNAME;
	starlitl->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit1, buf, sizeof(buf) );
	starlitl->mname = u.starlit1;

	starlitm->mmove = mons[starlitmonster].mmove;
	starlitm->ac = mons[starlitmonster].ac;
	starlitm->mr = mons[starlitmonster].mr;
	starlitm->maligntyp = mons[starlitmonster].maligntyp;
	starlitm->mattk[0] = mons[starlitmonster].mattk[0];
	starlitm->mattk[1] = mons[starlitmonster].mattk[1];
	starlitm->mattk[2] = mons[starlitmonster].mattk[2];
	starlitm->mattk[3] = mons[starlitmonster].mattk[3];
	starlitm->mattk[4] = mons[starlitmonster].mattk[4];
	starlitm->mattk[5] = mons[starlitmonster].mattk[5];
	starlitm->cwt = mons[starlitmonster].cwt;
	starlitm->cnutrit = mons[starlitmonster].cnutrit;
	starlitm->msound = mons[starlitmonster].msound;
	starlitm->msize = mons[starlitmonster].msize;
	starlitm->mresists = mons[starlitmonster].mresists;
	starlitm->mflags1 = mons[starlitmonster].mflags1;
	starlitm->mflags2 = mons[starlitmonster].mflags2;
	starlitm->mflags3 = mons[starlitmonster].mflags3;

	starlitm->mflags2 &= ~M2_NOPOLY;
	starlitm->mflags2 &= ~M2_MERC;
	starlitm->mflags2 &= ~M2_WERE;
	starlitm->mflags2 &= ~M2_PNAME;
	starlitm->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit2, buf, sizeof(buf) );
	starlitm->mname = u.starlit2;

	starlitn->mmove = mons[starlitmonster].mmove;
	starlitn->ac = mons[starlitmonster].ac;
	starlitn->mr = mons[starlitmonster].mr;
	starlitn->maligntyp = mons[starlitmonster].maligntyp;
	starlitn->mattk[0] = mons[starlitmonster].mattk[0];
	starlitn->mattk[1] = mons[starlitmonster].mattk[1];
	starlitn->mattk[2] = mons[starlitmonster].mattk[2];
	starlitn->mattk[3] = mons[starlitmonster].mattk[3];
	starlitn->mattk[4] = mons[starlitmonster].mattk[4];
	starlitn->mattk[5] = mons[starlitmonster].mattk[5];
	starlitn->cwt = mons[starlitmonster].cwt;
	starlitn->cnutrit = mons[starlitmonster].cnutrit;
	starlitn->msound = mons[starlitmonster].msound;
	starlitn->msize = mons[starlitmonster].msize;
	starlitn->mresists = mons[starlitmonster].mresists;
	starlitn->mflags1 = mons[starlitmonster].mflags1;
	starlitn->mflags2 = mons[starlitmonster].mflags2;
	starlitn->mflags3 = mons[starlitmonster].mflags3;

	starlitn->mflags2 &= ~M2_NOPOLY;
	starlitn->mflags2 &= ~M2_MERC;
	starlitn->mflags2 &= ~M2_WERE;
	starlitn->mflags2 &= ~M2_PNAME;
	starlitn->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit3, buf, sizeof(buf) );
	starlitn->mname = u.starlit3;

	/* and a total train wreck... */
	starlitmonster = -1;
	starlitattempts = 0;
	while ((starlitmonster == -1) && starlitattempts < 50000 ) {
		starlitmonster = /*(NUMMONS + rnd(MISSINGNORANGE));*/PM_HUMAN;
		starlitattempts++;
	}

	starlitu->mmove = mons[starlitmonster].mmove;
	starlitu->ac = mons[starlitmonster].ac;
	starlitu->mr = mons[starlitmonster].mr;
	starlitu->maligntyp = mons[starlitmonster].maligntyp;
	starlitu->mattk[0] = mons[starlitmonster].mattk[0];
	starlitu->mattk[1] = mons[starlitmonster].mattk[1];
	starlitu->mattk[2] = mons[starlitmonster].mattk[2];
	starlitu->mattk[3] = mons[starlitmonster].mattk[3];
	starlitu->mattk[4] = mons[starlitmonster].mattk[4];
	starlitu->mattk[5] = mons[starlitmonster].mattk[5];
	starlitu->cwt = mons[starlitmonster].cwt;
	starlitu->cnutrit = mons[starlitmonster].cnutrit;
	starlitu->msound = mons[starlitmonster].msound;
	starlitu->msize = mons[starlitmonster].msize;
	starlitu->mresists = mons[starlitmonster].mresists;
	starlitu->mflags1 = mons[starlitmonster].mflags1;
	starlitu->mflags2 = mons[starlitmonster].mflags2;
	starlitu->mflags3 = mons[starlitmonster].mflags3;

	starlitu->mflags2 &= ~M2_NOPOLY;
	starlitu->mflags2 &= ~M2_MERC;
	starlitu->mflags2 &= ~M2_WERE;
	starlitu->mflags2 &= ~M2_PNAME;
	starlitu->mflags2 &= ~M2_PEACEFUL;

	starlitu->mflags3 |= 0x40000000L;
	starlitu->mflags3 |= 0x80000000L;

	starlitattempts = 0;

	ptr = rndmonst();
polyinitredo:
	do {
		ptr = rndmonst();
		starlitattempts++;
	} while (!ptr && starlitattempts < 50000);

	if (ptr) {
		starlitmonster = monsndx(ptr);

		if ( (!attacktype(&mons[starlitmonster], AT_WEAP) && rn2(10)) || (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) ) goto polyinitredo;

		polyinitor->mmove = mons[starlitmonster].mmove;
		polyinitor->ac = mons[starlitmonster].ac;
		polyinitor->mr = mons[starlitmonster].mr;
		polyinitor->maligntyp = mons[starlitmonster].maligntyp;
		polyinitor->mattk[0] = mons[starlitmonster].mattk[0];
		polyinitor->mattk[1] = mons[starlitmonster].mattk[1];
		polyinitor->mattk[2] = mons[starlitmonster].mattk[2];
		polyinitor->mattk[3] = mons[starlitmonster].mattk[3];
		polyinitor->mattk[4] = mons[starlitmonster].mattk[4];
		polyinitor->mattk[5] = mons[starlitmonster].mattk[5];
		polyinitor->cwt = mons[starlitmonster].cwt;
		polyinitor->cnutrit = mons[starlitmonster].cnutrit;
		polyinitor->msound = mons[starlitmonster].msound;
		polyinitor->msize = mons[starlitmonster].msize;
		polyinitor->mresists = mons[starlitmonster].mresists;
		polyinitor->mflags1 = mons[starlitmonster].mflags1;
		polyinitor->mflags2 = mons[starlitmonster].mflags2;
		polyinitor->mflags3 = mons[starlitmonster].mflags3;

		polyinitor->mflags2 &= ~M2_NOPOLY;
		polyinitor->mflags2 &= ~M2_MERC;
		polyinitor->mflags2 &= ~M2_WERE;
		polyinitor->mflags2 &= ~M2_PNAME;
		polyinitor->mflags2 &= ~M2_PEACEFUL;

		polyinitor->mflags3 |= 0x40000000L;
		polyinitor->mflags3 |= 0x80000000L;
	}

	starlitmonster = rn2(NUMMONS);
	do {
		starlitmonster = rn2(NUMMONS);
	} while ( (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) );

	destabilizer->mmove = mons[starlitmonster].mmove;
	destabilizer->ac = mons[starlitmonster].ac;
	destabilizer->mr = mons[starlitmonster].mr;
	destabilizer->maligntyp = mons[starlitmonster].maligntyp;
	destabilizer->mattk[0] = mons[starlitmonster].mattk[0];
	destabilizer->mattk[1] = mons[starlitmonster].mattk[1];
	destabilizer->mattk[2] = mons[starlitmonster].mattk[2];
	destabilizer->mattk[3] = mons[starlitmonster].mattk[3];
	destabilizer->mattk[4] = mons[starlitmonster].mattk[4];
	destabilizer->mattk[5] = mons[starlitmonster].mattk[5];
	destabilizer->cwt = mons[starlitmonster].cwt;
	destabilizer->cnutrit = mons[starlitmonster].cnutrit;
	destabilizer->msound = mons[starlitmonster].msound;
	destabilizer->msize = mons[starlitmonster].msize;
	destabilizer->mresists = mons[starlitmonster].mresists;
	destabilizer->mflags1 = mons[starlitmonster].mflags1;
	destabilizer->mflags2 = mons[starlitmonster].mflags2;
	destabilizer->mflags3 = mons[starlitmonster].mflags3;

	destabilizer->mflags2 &= ~M2_NOPOLY;
	destabilizer->mflags2 &= ~M2_MERC;
	destabilizer->mflags2 &= ~M2_WERE;
	destabilizer->mflags2 &= ~M2_PNAME;
	destabilizer->mflags2 &= ~M2_PEACEFUL;

	destabilizer->mflags3 |= 0x40000000L;
	destabilizer->mflags3 |= 0x80000000L;

	/* idea by BarclayII: on-the-fly generation of a missingno */

	starlitv->mname = "ethereal missingno";

	starlitv->mmove = rn2(256);
	starlitv->ac = rn2(256);
	starlitv->mr = rn2(256);
	starlitv->maligntyp = rn2(256);

	attkptr = &starlitv->mattk[0];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[1];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[2];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[3];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[4];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[5];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);

	starlitv->cwt = rn2(32768);
	starlitv->cnutrit = rn2(32768);
	starlitv->msound = rn2(256);
	starlitv->mresists = rn2(1073741824);
	starlitv->mconveys = rn2(32768);
	starlitv->mflags1 = rn2(1073741824);
	starlitv->mflags2 = rn2(1073741824);
	starlitv->mflags3 = rn2(1073741824);

	if (rn2(2)) starlitv->mresists |= 0x80000000L;
	if (rn2(2)) starlitv->mflags1 |= 0x80000000L;
	if (rn2(2)) starlitv->mflags2 |= 0x80000000L;

	starlitv->mflags2 &= ~M2_NOPOLY;
	starlitv->mflags2 &= ~M2_MERC;
	starlitv->mflags2 &= ~M2_WERE;
	starlitv->mflags2 &= ~M2_PNAME;
	starlitv->mflags2 &= ~M2_PEACEFUL;

	starlitv->mflags3 |= 0x20000000L;
	starlitv->mflags3 |= 0x40000000L;
	starlitv->mflags3 |= 0x80000000L;

	randbossa->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossa->ac = 10 - rn2(16);				/* any AC */
	randbossa->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossa->mflags2 |= (1 << rn2(31));
	}
	randbossa->mflags2 &= ~M2_MERC;				/* no guards */
	randbossa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossa->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossb->mmove = 9 + rn2(4);				/* slow to very fast */
	randbossb->ac = 10 - rn2(6);				/* any AC */
	randbossb->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossb->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mflags2 |= (1 << rn2(31));
	}
	randbossb->mflags2 &= ~M2_MERC;				/* no guards */
	randbossb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossb->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossc->mmove = 12 + rn2(8);				/* slow to very fast */
	randbossc->ac = 10 - rn2(10);				/* any AC */
	randbossc->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossc->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossc->mflags2 |= (1 << rn2(31));
	}
	randbossc->mflags2 &= ~M2_MERC;				/* no guards */
	randbossc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossc->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossc->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossc->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossd->mmove = 10 + rn2(3);				/* slow to very fast */
	randbossd->ac = 10 - rn2(14);				/* any AC */
	randbossd->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossd->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossd->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossd->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randbosse->mmove = 15 + rn2(10);				/* slow to very fast */
	randbosse->ac = 10 - rn2(11);				/* any AC */
	randbosse->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosse->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbosse->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosse->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosse->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbosse->mflags2 |= (1 << rn2(31));
	}
	randbosse->mflags2 &= ~M2_MERC;				/* no guards */
	randbosse->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbosse->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbosse->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosse->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossf->mmove = 12 + rn2(7);				/* slow to very fast */
	randbossf->ac = 10 - rn2(15);				/* any AC */
	randbossf->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossg->mmove = 12 + rn2(5);				/* slow to very fast */
	randbossg->ac = 10 - rn2(14);				/* any AC */
	randbossg->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossg->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossg->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossg->mflags2 |= (1 << rn2(31));
	}
	randbossg->mflags2 &= ~M2_MERC;				/* no guards */
	randbossg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossg->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossh->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossh->ac = 10 - rn2(16);				/* any AC */
	randbossh->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossh->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossh->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossh->mflags2 |= (1 << rn2(31));
	}
	randbossh->mflags2 &= ~M2_MERC;				/* no guards */
	randbossh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossh->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossh->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossh->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossi->mmove = 14 + rn2(5);				/* slow to very fast */
	randbossi->ac = 10 - rn2(16);				/* any AC */
	randbossi->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossi->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossi->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mflags2 |= (1 << rn2(31));
	}
	randbossi->mflags2 &= ~M2_MERC;				/* no guards */
	randbossi->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossi->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossj->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossj->ac = 10 - rn2(13);				/* any AC */
	randbossj->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossj->mflags2 |= (1 << rn2(31));
	}
	randbossj->mflags2 &= ~M2_MERC;				/* no guards */
	randbossj->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossj->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossk->mmove = 12;				/* slow to very fast */
	randbossk->ac = 10 - rn2(17);				/* any AC */
	randbossk->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossk->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossk->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbossk->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossk->mflags2 |= (1 << rn2(31));
	}
	randbossk->mflags2 &= ~M2_MERC;				/* no guards */
	randbossk->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossk->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossk->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossk->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossl->mmove = 15 + rn2(6);				/* slow to very fast */
	randbossl->ac = 10 - rn2(15);				/* any AC */
	randbossl->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossl->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(19)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(19)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbossl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossm->mmove = 15 + rn2(9);				/* slow to very fast */
	randbossm->ac = 10 - rn2(12);				/* any AC */
	randbossm->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossm->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randbossn->mmove = 12 + rn2(2);				/* slow to very fast */
	randbossn->ac = 10 - rn2(21);				/* any AC */
	randbossn->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossn->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(25)+1;				/* either too high or too low */
	}

	for (i = 2; i < 6; i++) {
		attkptr = &randbossn->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(25)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossn->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossn->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossn->mflags2 |= (1 << rn2(31));
	}
	randbossn->mflags2 &= ~M2_MERC;				/* no guards */
	randbossn->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossn->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossn->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossn->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbosso->mmove = 14 + rn2(3);				/* slow to very fast */
	randbosso->ac = 10 - rn2(16);				/* any AC */
	randbosso->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosso->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbosso->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosso->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbosso->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbosso->mflags2 |= (1 << rn2(31));
	}
	randbosso->mflags2 &= ~M2_MERC;				/* no guards */
	randbosso->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbosso->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbosso->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosso->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossp->mmove = 15 + rn2(11);				/* slow to very fast */
	randbossp->ac = 10 - rn2(7);				/* any AC */
	randbossp->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossp->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossp->mflags2 |= (1 << rn2(31));
	}
	randbossp->mflags2 &= ~M2_MERC;				/* no guards */
	randbossp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossp->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossq->mmove = 12 + rn2(6);				/* slow to very fast */
	randbossq->ac = 10 - rn2(11);				/* any AC */
	randbossq->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossr->mmove = 12 + rn2(5);				/* slow to very fast */
	randbossr->ac = 10 - rn2(9);				/* any AC */
	randbossr->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossr->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbosss->mmove = 15 + rn2(5);				/* slow to very fast */
	randbosss->ac = 10 - rn2(16);				/* any AC */
	randbosss->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosss->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbosss->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbosss->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosss->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosss->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbosst->mmove = 10 + rn2(4);				/* slow to very fast */
	randbosst->ac = 10 - rn2(16);				/* any AC */
	randbosst->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosst->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbosst->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosst->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosst->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossu->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossu->ac = 10 - rn2(8);				/* any AC */
	randbossu->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossu->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossu->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossu->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossu->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossu->mflags2 |= (1 << rn2(31));
	}
	randbossu->mflags2 &= ~M2_MERC;				/* no guards */
	randbossu->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossu->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossv->mmove = 15 + rn2(7);				/* slow to very fast */
	randbossv->ac = 10 - rn2(6);				/* any AC */
	randbossv->mr = rn2(16);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossv->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossv->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossv->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossv->mflags2 |= (1 << rn2(31));
	}
	randbossv->mflags2 &= ~M2_MERC;				/* no guards */
	randbossv->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossv->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossw->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossw->ac = 10 - rn2(12);				/* any AC */
	randbossw->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossw->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossw->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossw->mflags2 |= (1 << rn2(31));
	}
	randbossw->mflags2 &= ~M2_MERC;				/* no guards */
	randbossw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossw->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossx->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossx->ac = 10 - rn2(13);				/* any AC */
	randbossx->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossx->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossx->mflags2 |= (1 << rn2(31));
	}
	randbossx->mflags2 &= ~M2_MERC;				/* no guards */
	randbossx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossx->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossy->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossy->ac = 10 - rn2(12);				/* any AC */
	randbossy->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossy->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossy->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossy->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossy->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossz->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossz->ac = 10 - rn2(17);				/* any AC */
	randbossz->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossz->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossz->mflags2 |= (1 << rn2(31));
	}
	randbossz->mflags2 &= ~M2_MERC;				/* no guards */
	randbossz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossz->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossz->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossz->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaa->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossaa->ac = 10 - rn2(18);				/* any AC */
	randbossaa->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossaa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossaa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossaa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossaa->mflags2 |= (1 << rn2(31));
	}
	randbossaa->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaa->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossaa->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossaa->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossab->mmove = 13 + rn2(6);				/* slow to very fast */
	randbossab->ac = 10 - rn2(13);				/* any AC */
	randbossab->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossab->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossab->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randbossab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossab->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossac->mmove = 10 + rn2(3);				/* slow to very fast */
	randbossac->ac = 10 - rn2(11);				/* any AC */
	randbossac->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossac->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossac->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossac->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossac->mflags2 |= (1 << rn2(31));
	}
	randbossac->mflags2 &= ~M2_MERC;				/* no guards */
	randbossac->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossac->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossad->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossad->ac = 10 - rn2(15);				/* any AC */
	randbossad->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossad->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossad->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossad->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossad->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossad->mflags2 |= (1 << rn2(31));
	}
	randbossad->mflags2 &= ~M2_MERC;				/* no guards */
	randbossad->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossad->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossae->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossae->ac = 10 - rn2(9);				/* any AC */
	randbossae->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossae->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossaf->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossaf->ac = 10 - rn2(13);				/* any AC */
	randbossaf->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randbossaf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossaf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossag->mmove = 15 + rn2(4);				/* slow to very fast */
	randbossag->ac = 10 - rn2(10);				/* any AC */
	randbossag->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossag->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossag->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossag->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossag->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossah->mmove = 13 + rn2(3);				/* slow to very fast */
	randbossah->ac = 10 - rn2(17);				/* any AC */
	randbossah->mr = rn2(21);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossah->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossah->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossah->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossah->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossai->mmove = 10 + rn2(2);				/* slow to very fast */
	randbossai->ac = 10 - rn2(21);				/* any AC */
	randbossai->mr = rn2(21);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossai->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(35)+1;				/* either too high or too low */
	}

	for (i = 2; i < 6; i++) {
		attkptr = &randbossai->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(35)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossai->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 7; i++) {
		randbossai->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossai->mflags2 |= (1 << rn2(31));
	}
	randbossai->mflags2 &= ~M2_MERC;				/* no guards */
	randbossai->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossai->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossai->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossai->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaj->mmove = 11 + rn2(4);				/* slow to very fast */
	randbossaj->ac = 10 - rn2(11);				/* any AC */
	randbossaj->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossaj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossaj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossak->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossak->ac = 10 - rn2(9);				/* any AC */
	randbossak->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossak->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossak->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossak->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossal->mmove = 13 + rn2(3);				/* slow to very fast */
	randbossal->ac = 10 - rn2(9);				/* any AC */
	randbossal->mr = rn2(16);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossal->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossal->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossal->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 6; i++) {
		randbossal->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossal->mflags2 |= (1 << rn2(31));
	}
	randbossal->mflags2 &= ~M2_MERC;				/* no guards */
	randbossal->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossal->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossal->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossal->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossam->mmove = 15 + rn2(5);				/* slow to very fast */
	randbossam->ac = 10 - rn2(15);				/* any AC */
	randbossam->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossam->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossam->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossam->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossam->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossam->mflags2 |= (1 << rn2(31));
	}
	randbossam->mflags2 &= ~M2_MERC;				/* no guards */
	randbossam->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossam->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossan->mmove = 18 + rn2(8);				/* slow to very fast */
	randbossan->ac = 10 - rn2(19);				/* any AC */
	randbossan->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossan->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 2; i < 2; i++) {
		attkptr = &randbossan->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossan->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossao->mmove = 8 + rn2(3);				/* slow to very fast */
	randbossao->ac = 10 - rn2(15);				/* any AC */
	randbossao->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossao->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossao->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossao->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 6; i++) {
		randbossao->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossao->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossao->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossap->mmove = 12;				/* slow to very fast */
	randbossap->ac = 10 - rn2(11);				/* any AC */
	randbossap->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossap->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 10; i++) {
		randbossap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossap->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossap->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaq->mmove = 16 + rn2(5);				/* slow to very fast */
	randbossaq->ac = 10 - rn2(3);				/* any AC */
	randbossaq->mr = rn2(11);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossaq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossaq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossaq->mflags2 |= (1 << rn2(31));
	}
	randbossaq->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossar->mmove = 15 + rn2(3);				/* slow to very fast */
	randbossar->ac = 10 - rn2(5);				/* any AC */
	randbossar->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossar->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossar->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossar->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossas->mmove = 14 + rn2(3);				/* slow to very fast */
	randbossas->ac = 10 - rn2(6);				/* any AC */
	randbossas->mr = rn2(6);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossas->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossas->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossas->mflags2 |= (1 << rn2(31));
	}
	randbossas->mflags2 &= ~M2_MERC;				/* no guards */
	randbossas->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossas->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossat->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossat->ac = 10 - rn2(15);				/* any AC */
	randbossat->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossat->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(17)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossat->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(17)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossat->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossat->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 5; i++) {
		randbossat->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossat->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossau->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossau->ac = 10 - rn2(10);				/* any AC */
	randbossau->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossau->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossau->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossau->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossau->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossau->mflags2 |= (1 << rn2(31));
	}
	randbossau->mflags2 &= ~M2_MERC;				/* no guards */
	randbossau->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossau->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossau->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossau->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossav->mmove = 15 + rn2(5);				/* slow to very fast */
	randbossav->ac = 10 - rn2(5);				/* any AC */
	randbossav->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossav->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossav->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossav->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossav->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossaw->mmove = 15 + rn2(4);				/* slow to very fast */
	randbossaw->ac = 10 - rn2(7);				/* any AC */
	randbossaw->mr = rn2(3);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaw->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossaw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossaw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossaw->mflags2 |= (1 << rn2(31));
	}
	randbossaw->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaw->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossax->mmove = 12 + rn2(7);				/* slow to very fast */
	randbossax->ac = 10 - rn2(15);				/* any AC */
	randbossax->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossax->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossax->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossax->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossax->mflags2 |= (1 << rn2(31));
	}
	randbossax->mflags2 &= ~M2_MERC;				/* no guards */
	randbossax->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossax->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossax->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossax->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwea->mmove = 12 + rn2(2);				/* slow to very fast */
	randfwea->ac = 10 - rn2(11);				/* any AC */
	randfwea->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwea->geno |= G_SGROUP;
	else if (!rn2(200)) randfwea->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwea->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwea->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwea->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwea->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwea->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweb->mmove = 12 + rn2(8);				/* slow to very fast */
	randfweb->ac = 10 - rn2(17);				/* any AC */
	randfweb->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfweb->geno |= G_SGROUP;
	else if (!rn2(200)) randfweb->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweb->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweb->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randfweb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweb->mflags2 |= (1 << rn2(31));
	}
	randfweb->mflags2 &= ~M2_MERC;				/* no guards */
	randfweb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweb->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweb->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweb->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwec->mmove = 15 + rn2(4);				/* slow to very fast */
	randfwec->ac = 10 - rn2(13);				/* any AC */
	randfwec->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwec->geno |= G_SGROUP;
	else if (!rn2(200)) randfwec->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwec->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwec->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfwec->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	randfwed->mmove = 10 + rn2(3);				/* slow to very fast */
	randfwed->ac = 10 - rn2(16);				/* any AC */
	randfwed->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwed->geno |= G_SGROUP;
	else if (!rn2(200)) randfwed->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwed->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwed->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwed->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfwee->mmove = 12 + rn2(3);				/* slow to very fast */
	randfwee->ac = 10 - rn2(10);				/* any AC */
	randfwee->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfwee->geno |= G_SGROUP;
	else if (!rn2(200)) randfwee->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwee->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwee->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwee->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwef->mmove = 13 + rn2(3);				/* slow to very fast */
	randfwef->ac = 10 - rn2(11);				/* any AC */
	randfwef->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwef->geno |= G_SGROUP;
	else if (!rn2(200)) randfwef->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwef->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwef->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwef->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwef->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwef->mflags2 |= (1 << rn2(31));
	}
	randfwef->mflags2 &= ~M2_MERC;				/* no guards */
	randfwef->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwef->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwef->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwef->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweg->mmove = 13 + rn2(5);				/* slow to very fast */
	randfweg->ac = 10 - rn2(12);				/* any AC */
	randfweg->mr = rn2(76);				/* varying amounts of MR */

	if (!rn2(20)) randfweg->geno |= G_SGROUP;
	else if (!rn2(200)) randfweg->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweg->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweg->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfweg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweg->mflags2 |= (1 << rn2(31));
	}
	randfweg->mflags2 &= ~M2_MERC;				/* no guards */
	randfweg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweg->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweh->mmove = 12 + rn2(5);				/* slow to very fast */
	randfweh->ac = 10 - rn2(14);				/* any AC */
	randfweh->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweh->geno |= G_SGROUP;
	else if (!rn2(200)) randfweh->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweh->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweh->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweh->mflags2 |= (1 << rn2(31));
	}
	randfweh->mflags2 &= ~M2_MERC;				/* no guards */
	randfweh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweh->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfweh->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweh->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwei->mmove = 15 + rn2(5);				/* slow to very fast */
	randfwei->ac = 10 - rn2(15);				/* any AC */
	randfwei->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfwei->geno |= G_SGROUP;
	else if (!rn2(200)) randfwei->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwei->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwei->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwei->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwei->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwei->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwej->mmove = 15 + rn2(10);				/* slow to very fast */
	randfwej->ac = 10 - rn2(5);				/* any AC */
	randfwej->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfwej->geno |= G_SGROUP;
	else if (!rn2(200)) randfwej->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwej->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwej->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfwej->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwej->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwej->mflags2 |= (1 << rn2(31));
	}
	randfwej->mflags2 &= ~M2_MERC;				/* no guards */
	randfwej->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwej->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfwek->mmove = 13 + rn2(11);				/* slow to very fast */
	randfwek->ac = 10 - rn2(15);				/* any AC */
	randfwek->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfwek->geno |= G_SGROUP;
	else if (!rn2(200)) randfwek->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwek->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwek->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwek->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfwek->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwek->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwek->mflags2 |= (1 << rn2(31));
	}
	randfwek->mflags2 &= ~M2_MERC;				/* no guards */
	randfwek->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwek->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfwel->mmove = 11 + rn2(3);				/* slow to very fast */
	randfwel->ac = 10 - rn2(15);				/* any AC */
	randfwel->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfwel->geno |= G_SGROUP;
	else if (!rn2(200)) randfwel->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwel->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwel->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randfwel->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfwel->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfwel->mflags2 |= (1 << rn2(31));
	}
	randfwel->mflags2 &= ~M2_MERC;				/* no guards */
	randfwel->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwel->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 4; i++) {
		randfwel->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwel->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwem->mmove = 16 + rn2(10);				/* slow to very fast */
	randfwem->ac = 10 - rn2(6);				/* any AC */
	randfwem->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfwem->geno |= G_SGROUP;
	else if (!rn2(200)) randfwem->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwem->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwem->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfwem->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwem->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwen->mmove = 16 + rn2(5);				/* slow to very fast */
	randfwen->ac = 10 - rn2(13);				/* any AC */
	randfwen->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwen->geno |= G_SGROUP;
	else if (!rn2(200)) randfwen->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwen->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwen->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwen->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwen->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwen->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwen->mflags2 |= (1 << rn2(31));
	}
	randfwen->mflags2 &= ~M2_MERC;				/* no guards */
	randfwen->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwen->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfwen->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwen->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweo->mmove = 18 + rn2(8);				/* slow to very fast */
	randfweo->ac = 10 - rn2(7);				/* any AC */
	randfweo->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweo->geno |= G_SGROUP;
	else if (!rn2(200)) randfweo->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweo->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweo->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweo->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweo->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweo->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweo->mflags2 |= (1 << rn2(31));
	}
	randfweo->mflags2 &= ~M2_MERC;				/* no guards */
	randfweo->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweo->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweo->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweo->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwep->mmove = 6 + rn2(7);				/* slow to very fast */
	randfwep->ac = 10 - rn2(21);				/* any AC */
	randfwep->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfwep->geno |= G_SGROUP;
	else if (!rn2(200)) randfwep->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwep->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwep->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwep->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfweq->mmove = 16 + rn2(15);				/* slow to very fast */
	randfweq->ac = 10 - rn2(15);				/* any AC */
	randfweq->mr = rn2(11);				/* varying amounts of MR */

	if (!rn2(20)) randfweq->geno |= G_SGROUP;
	else if (!rn2(200)) randfweq->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweq->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 1; i < 3; i++) {
		attkptr = &randfweq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfweq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweq->mflags2 |= (1 << rn2(31));
	}
	randfweq->mflags2 &= ~M2_MERC;				/* no guards */
	randfweq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweq->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwer->mmove = 12 + rn2(5);				/* slow to very fast */
	randfwer->ac = 10 - rn2(11);				/* any AC */
	randfwer->mr = rn2(31);				/* varying amounts of MR */

	if (!rn2(20)) randfwer->geno |= G_SGROUP;
	else if (!rn2(200)) randfwer->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwer->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwer->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwer->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwer->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwes->mmove = 10 + rn2(6);				/* slow to very fast */
	randfwes->ac = 10 - rn2(16);				/* any AC */
	randfwes->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwes->geno |= G_SGROUP;
	else if (!rn2(200)) randfwes->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwes->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwes->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwes->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwes->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwes->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwes->mflags2 |= (1 << rn2(31));
	}
	randfwes->mflags2 &= ~M2_MERC;				/* no guards */
	randfwes->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwes->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwes->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwes->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwet->mmove = 10 + rn2(9);				/* slow to very fast */
	randfwet->ac = 10 - rn2(15);				/* any AC */
	randfwet->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwet->geno |= G_SGROUP;
	else if (!rn2(200)) randfwet->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwet->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwet->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(11)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwet->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwet->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwet->mflags2 |= (1 << rn2(31));
	}
	randfwet->mflags2 &= ~M2_MERC;				/* no guards */
	randfwet->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwet->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweu->mmove = 15 + rn2(5);				/* slow to very fast */
	randfweu->ac = 10 - rn2(5);				/* any AC */
	randfweu->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfweu->geno |= G_SGROUP;
	else if (!rn2(200)) randfweu->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweu->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweu->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweu->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweu->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwev->mmove = 15 + rn2(5);				/* slow to very fast */
	randfwev->ac = 10 - rn2(11);				/* any AC */
	randfwev->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfwev->geno |= G_SGROUP;
	else if (!rn2(200)) randfwev->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwev->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwev->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwev->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwev->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 4; i++) {
		randfwev->mflags2 |= (1 << rn2(31));
	}
	randfwev->mflags2 &= ~M2_MERC;				/* no guards */
	randfwev->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwev->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfwev->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwev->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwew->mmove = 12 + rn2(3);				/* slow to very fast */
	randfwew->ac = 10 - rn2(12);				/* any AC */
	randfwew->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfwew->geno |= G_SGROUP;
	else if (!rn2(200)) randfwew->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwew->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwew->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwew->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwew->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwex->mmove = 11 + rn2(5);				/* slow to very fast */
	randfwex->ac = 10 - rn2(17);				/* any AC */
	randfwex->mr = rn2(66);				/* varying amounts of MR */

	if (!rn2(20)) randfwex->geno |= G_SGROUP;
	else if (!rn2(200)) randfwex->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwex->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwex->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwex->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwex->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwey->mmove = 12 + rn2(4);				/* slow to very fast */
	randfwey->ac = 10 - rn2(15);				/* any AC */
	randfwey->mr = rn2(31);				/* varying amounts of MR */

	if (!rn2(20)) randfwey->geno |= G_SGROUP;
	else if (!rn2(200)) randfwey->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwey->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwey->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwey->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mflags2 |= (1 << rn2(31));
	}
	randfwey->mflags2 &= ~M2_MERC;				/* no guards */
	randfwey->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwey->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwey->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwey->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwez->mmove = 15 + rn2(8);				/* slow to very fast */
	randfwez->ac = 10 - rn2(6);				/* any AC */
	randfwez->mr = rn2(11);				/* varying amounts of MR */

	if (!rn2(20)) randfwez->geno |= G_SGROUP;
	else if (!rn2(200)) randfwez->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwez->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwez->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwez->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwez->mflags2 |= (1 << rn2(31));
	}
	randfwez->mflags2 &= ~M2_MERC;				/* no guards */
	randfwez->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwez->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaa->mmove = 14 + rn2(3);				/* slow to very fast */
	randfweaa->ac = 10 - rn2(14);				/* any AC */
	randfweaa->mr = rn2(66);				/* varying amounts of MR */

	if (!rn2(20)) randfweaa->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaa->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaa->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweaa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweaa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaa->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweaa->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweab->mmove = 12 + rn2(2);				/* slow to very fast */
	randfweab->ac = 10 - rn2(13);				/* any AC */
	randfweab->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweab->geno |= G_SGROUP;
	else if (!rn2(200)) randfweab->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweab->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweab->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfweac->mmove = 11 + rn2(3);				/* slow to very fast */
	randfweac->ac = 10 - rn2(13);				/* any AC */
	randfweac->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfweac->geno |= G_SGROUP;
	else if (!rn2(200)) randfweac->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweac->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweac->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(21)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwead->mmove = 14 + rn2(3);				/* slow to very fast */
	randfwead->ac = 10 - rn2(7);				/* any AC */
	randfwead->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfwead->geno |= G_SGROUP;
	else if (!rn2(200)) randfwead->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwead->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwead->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwead->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwead->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweae->mmove = 15 + rn2(5);				/* slow to very fast */
	randfweae->ac = 10 - rn2(9);				/* any AC */
	randfweae->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweae->geno |= G_SGROUP;
	else if (!rn2(200)) randfweae->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweae->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweae->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweaf->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweaf->ac = 10 - rn2(4);				/* any AC */
	randfweaf->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfweaf->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaf->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaf->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweaf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweaf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randfweaf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweag->mmove = 12 + rn2(4);				/* slow to very fast */
	randfweag->ac = 10 - rn2(9);				/* any AC */
	randfweag->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfweag->geno |= G_SGROUP;
	else if (!rn2(200)) randfweag->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweag->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweag->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(11)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweag->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweag->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweag->mflags2 |= (1 << rn2(31));
	}
	randfweag->mflags2 &= ~M2_MERC;				/* no guards */
	randfweag->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweag->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweah->mmove = 14 + rn2(4);				/* slow to very fast */
	randfweah->ac = 10 - rn2(11);				/* any AC */
	randfweah->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweah->geno |= G_SGROUP;
	else if (!rn2(200)) randfweah->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweah->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweah->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweah->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweah->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweah->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweah->mflags2 |= (1 << rn2(31));
	}
	randfweah->mflags2 &= ~M2_MERC;				/* no guards */
	randfweah->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweah->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfweah->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweah->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweai->mmove = 15 + rn2(6);				/* slow to very fast */
	randfweai->ac = 10 - rn2(13);				/* any AC */
	randfweai->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweai->geno |= G_SGROUP;
	else if (!rn2(200)) randfweai->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweai->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweai->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweai->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweai->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweai->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweai->mflags2 |= (1 << rn2(31));
	}
	randfweai->mflags2 &= ~M2_MERC;				/* no guards */
	randfweai->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweai->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaj->mmove = 13 + rn2(4);				/* slow to very fast */
	randfweaj->ac = 10 - rn2(13);				/* any AC */
	randfweaj->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfweaj->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaj->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaj->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweaj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfweaj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweaj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweaj->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweaj->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweak->mmove = 14 + rn2(7);				/* slow to very fast */
	randfweak->ac = 10 - rn2(14);				/* any AC */
	randfweak->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweak->geno |= G_SGROUP;
	else if (!rn2(200)) randfweak->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweak->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweak->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweak->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweak->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweak->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweak->mflags2 |= (1 << rn2(31));
	}
	randfweak->mflags2 &= ~M2_MERC;				/* no guards */
	randfweak->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweak->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweak->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweak->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweal->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweal->ac = 10 - rn2(7);				/* any AC */
	randfweal->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfweal->geno |= G_SGROUP;
	else if (!rn2(200)) randfweal->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweal->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweal->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweal->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweal->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweam->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweam->ac = 10 - rn2(7);				/* any AC */
	randfweam->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfweam->geno |= G_SGROUP;
	else if (!rn2(200)) randfweam->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweam->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweam->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweam->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweam->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwean->mmove = 14 + rn2(3);				/* slow to very fast */
	randfwean->ac = 10 - rn2(16);				/* any AC */
	randfwean->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwean->geno |= G_SGROUP;
	else if (!rn2(200)) randfwean->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwean->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwean->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfwean->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwean->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwean->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwean->mflags2 |= (1 << rn2(31));
	}
	randfwean->mflags2 &= ~M2_MERC;				/* no guards */
	randfwean->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwean->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweao->mmove = 8 + rn2(5);				/* slow to very fast */
	randfweao->ac = 10 - rn2(22);				/* any AC */
	randfweao->mr = rn2(71);				/* varying amounts of MR */

	if (!rn2(20)) randfweao->geno |= G_SGROUP;
	else if (!rn2(200)) randfweao->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweao->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweao->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweao->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweao->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweao->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweao->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 3; i++) {
		randfweao->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweao->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweao->mflags2 &= ~M2_MERC;				/* no guards */
	randfweao->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweao->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweap->mmove = 14 + rn2(7);				/* slow to very fast */
	randfweap->ac = 10 - rn2(7);				/* any AC */
	randfweap->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweap->geno |= G_SGROUP;
	else if (!rn2(200)) randfweap->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweap->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweap->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweap->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweap->mflags2 &= ~M2_MERC;				/* no guards */
	randfweap->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweap->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaq->mmove = 11 + rn2(3);				/* slow to very fast */
	randfweaq->ac = 10 - rn2(41);				/* any AC */
	randfweaq->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfweaq->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaq->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaq->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(37)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfweaq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweaq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweaq->mflags2 &= ~M2_MERC;				/* no guards */
	randfweaq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweaq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	return;
}


/* skills aren't initialized, so we use the role-specific skill lists */
STATIC_OVL boolean
restricted_spell_discipline(otyp)
int otyp;
{
    const struct def_skill *skills;
    int this_skill = spell_skilltype(otyp);

    switch (Role_switch) {
     case PM_ARCHEOLOGIST:	skills = Skill_A; break;
     case PM_ANACHRONIST:	skills = Skill_Ana; break;  
     case PM_LIBRARIAN:	skills = Skill_Lib; break;
     case PM_SUPERMARKET_CASHIER:	skills = Skill_Sup; break;
     case PM_INTEL_SCRIBE:	skills = Skill_Scr; break;
     case PM_GAMER:	skills = Skill_Gam; break;
     case PM_ARTIST:	skills = Skill_Art; break;
     case PM_AUGURER:	skills = Skill_Aug; break;
     case PM_BARBARIAN:		skills = Skill_B; break;
     case PM_NOOB_MODE_BARB:		skills = Skill_Noo; break;
     case PM_BARD:		skills = Skill_Bard; break;
     case PM_BINDER:			skills = Skill_Bin; break;
     case PM_POLITICIAN:			skills = Skill_Pol; break;
     case PM_DQ_SLIME:			skills = Skill_Sli; break;
     case PM_ALLTECHER:			skills = Skill_All; break;
     case PM_SPELLMASTER:			skills = Skill_Spe; break;
     case PM_ERDRICK:			skills = Skill_Erd; break;
     case PM_BLEEDER:			skills = Skill_Ble; break;
     case PM_COOK:			skills = Skill_Coo; break;
     case PM_CAVEMAN:		skills = Skill_C; break;
     case PM_CONVICT:		skills = Skill_Con; break;
     case PM_MURDERER:		skills = Skill_Mur; break;
     case PM_DEMAGOGUE:		skills = Skill_Dem; break;
     case PM_WALSCHOLAR:		skills = Skill_Wal; break;
     case PM_SINGSLAVE:		skills = Skill_Sin; break;
     case PM_CELLAR_CHILD:		skills = Skill_Cel; break;
     case PM_SOCIAL_JUSTICE_WARRIOR:		skills = Skill_Soc; break;
     case PM_GRENADONIN:		skills = Skill_Gre; break;
     case PM_COURIER:		skills = Skill_Cou; break;
     case PM_SPACEWARS_FIGHTER:		skills = Skill_Spa; break;
     case PM_CAMPERSTRIKER:		skills = Skill_Cam; break;
     case PM_NUCLEAR_PHYSICIST:		skills = Skill_Nuc; break;
     case PM_FORM_CHANGER:		skills = Skill_For; break;
     case PM_TRACER:		skills = Skill_Trc; break;
     case PM_FEMINIST:		skills = Skill_Fem; break;
     case PM_GANG_SCHOLAR:		skills = Skill_Sco; break;
     case PM_ROCKER:		skills = Skill_Roc; break;
     case PM_ZYBORG:		skills = Skill_Zyb; break;
     case PM_LUNATIC:		skills = Skill_Lun; break;
     case PM_CHEVALIER:		skills = Skill_Che; break;
     case PM_ELECTRIC_MAGE:		skills = Skill_Ele; break;
     case PM_POISON_MAGE:		skills = Skill_Poi; break;
     case PM_CRUEL_ABUSER:		skills = Skill_Abu; break;
     case PM_SLAVE_MASTER:		skills = Skill_Sla; break;
     case PM_MYSTIC:		skills = Skill_Mys; break;
     case PM_BLOODSEEKER:		skills = Skill_Blo; break;
     case PM_LADIESMAN:		skills = Skill_Lad; break;
     case PM_FENCER:		skills = Skill_Fen; break;
     case PM_FIGHTER:		skills = Skill_Fig; break;
     case PM_MEDIUM:		skills = Skill_Med; break;
     case PM_STAND_USER:		skills = Skill_Sta; break;
     case PM_JUSTICE_KEEPER:		skills = Skill_Jus; break;
     case PM_SEXYMATE:		skills = Skill_Sex; break;
     case PM_JESTER:		skills = Skill_Jes; break;
     case PM_ACID_MAGE:		skills = Skill_Aci; break;
     case PM_FLAME_MAGE:		skills = Skill_F; break;
     case PM_TRANSVESTITE:	skills = Skill_Tra; break;
     case PM_PROSTITUTE:	skills = Skill_Pro; break;
     case PM_KURWA:	skills = Skill_Kur; break;
     case PM_TRANSSYLVANIAN:	skills = Skill_Trs; break;
     case PM_SOFTWARE_ENGINEER:	skills = Skill_Sof; break;
     case PM_CRACKER:	skills = Skill_Cra; break;
     case PM_JANITOR:	skills = Skill_Jan; break;
     case PM_SPACE_MARINE:	skills = Skill_Sma; break;
     case PM_STORMBOY:	skills = Skill_Sto; break;
     case PM_YAUTJA:	skills = Skill_Yau; break;
     case PM_JOCKEY:	skills = Skill_Joc; break;
     case PM_QUARTERBACK:	skills = Skill_Qua; break;
     case PM_PSYKER:	skills = Skill_Psy; break;
     case PM_EMPATH:	skills = Skill_Emp; break;
     case PM_MASTERMIND:	skills = Skill_Mam; break;
     case PM_WEIRDBOY:	skills = Skill_Wei; break;
     case PM_ASTRONAUT:	skills = Skill_Ast; break;
     case PM_CYBERNINJA:	skills = Skill_Cyb; break;
     case PM_DISSIDENT:	skills = Skill_Dis; break;
     case PM_XELNAGA:	skills = Skill_Xel; break;
     case PM_UNBELIEVER:	skills = Skill_Unb; break;
     case PM_TOPMODEL:	skills = Skill_Top; break;
     case PM_FAILED_EXISTENCE:	skills = Skill_Fai; break;
     case PM_GEEK:		skills = Skill_G; break;
     case PM_SCIENTIST:		skills = Skill_Sci; break;
     case PM_GANGSTER:		skills = Skill_Gan; break;
     case PM_GUNNER:		skills = Skill_Gun; break;
     case PM_DOOM_MARINE:		skills = Skill_Mar; break;
     case PM_HEALER:		skills = Skill_H; break;
     case PM_JEDI:		skills = Skill_J; break;
     case PM_SHADOW_JEDI:		skills = Skill_Sdw; break;
     case PM_HEDDERJEDI:		skills = Skill_Hed; break;
     case PM_KNIGHT:		skills = Skill_K; break;
     case PM_WANDKEEPER:		skills = Skill_Wan; break;
     case PM_PALADIN:		skills = Skill_Pal; break;
     case PM_FEAT_MASTER:		skills = Skill_Stu; break;
     case PM_FOXHOUND_AGENT:		skills = Skill_Fox; break;
     case PM_WARRIOR:		skills = Skill_War; break;
     case PM_DOLL_MISTRESS:		skills = Skill_Dol; break;
     case PM_MAHOU_SHOUJO:		skills = Skill_Mah; break;
     case PM_MONK:		skills = Skill_Mon; break;
     case PM_HALF_BAKED:		skills = Skill_Hba; break;
     case PM_SAIYAN:		skills = Skill_Sai; break;
     case PM_PSION:		skills = Skill_Psi; break;
	 case PM_PIRATE:		skills = Skill_Pir; break;
	 case PM_KORSAIR:		skills = Skill_Kor; break;
	 case PM_GLADIATOR:		skills = Skill_Gla; break;
	 case PM_GOFF:		skills = Skill_Gof; break;
	 case PM_AMAZON:		skills = Skill_Ama; break;
	 case PM_DRUID:		skills = Skill_Drd; break;
	 case PM_ALTMER:		skills = Skill_Alt; break;
	 case PM_BOSMER:		skills = Skill_Bos; break;
	 case PM_DUNMER:		skills = Skill_Dun; break;
	 case PM_ORDINATOR:		skills = Skill_Ord; break;
	 case PM_THALMOR:		skills = Skill_Tha; break;
	 case PM_DIVER:		skills = Skill_Div; break;
     case PM_POKEMON:		skills = Skill_Pok; break;
     case PM_PRIEST:		skills = Skill_P; break;
     case PM_RANGER:		skills = Skill_Ran; break;
     case PM_ELPH:		skills = Skill_Elp; break;
     case PM_TWELPH:		skills = Skill_Elp; break;
     case PM_GOLDMINER:		skills = Skill_Gol; break;
     case PM_SHAPESHIFTER:		skills = Skill_Sha; break;
     case PM_MIDGET:		skills = Skill_Mid; break;
     case PM_RINGSEEKER:		skills = Skill_Rin; break;
     case PM_ROGUE:		skills = Skill_R; break;
     case PM_PICKPOCKET:		skills = Skill_Pic; break;
     case PM_BULLY:		skills = Skill_Bul; break;
     case PM_ASSASSIN:		skills = Skill_Ass; break;
     case PM_SAMURAI:		skills = Skill_S; break;
     case PM_TOURIST:		skills = Skill_T; break;
     case PM_OTAKU:		skills = Skill_Ota; break;
     case PM_VALKYRIE:		skills = Skill_V; break;
     case PM_VANILLA_VALK:		skills = Skill_Van; break;
     case PM_WIZARD:		skills = Skill_W; break;
     case PM_SAGE:		skills = Skill_Sag; break;
     case PM_ELEMENTALIST:		skills = Skill_Elm; break;
     case PM_OCCULT_MASTER:		skills = Skill_Occ; break;
     case PM_CHAOS_SORCEROR:		skills = Skill_Cha; break;
     case PM_WILD_TALENT:		skills = Skill_Wil; break;
     case PM_MASON:		skills = Skill_Mas; break;
     case PM_HUSSY:		skills = Skill_Hus; break;
     case PM_ANACHRONOUNBINDER:		skills = Skill_Acu; break;

     case PM_DRUNK:		skills = Skill_Dru; break;
     case PM_MUSICIAN:		skills = Skill_Mus; break;
     case PM_LOCKSMITH:		skills = Skill_Loc; break;
     case PM_FIREFIGHTER:		skills = Skill_Fir; break;
     case PM_OFFICER:		skills = Skill_Off; break;
     case PM_ZOOKEEPER:		skills = Skill_Zoo; break;
     case PM_CLIMACTERIAL:		skills = Skill_Cli; break;
     case PM_WOMANIZER:		skills = Skill_Wom; break;
     case PM_NINJA:		skills = Skill_Nin; break;
     case PM_UNDERTAKER:		skills = Skill_Unt; break;
     case PM_GRADUATE:		skills = Skill_Gra; break;
     case PM_CARTOMANCER:		skills = Skill_Car; break;
     case PM_DRAGONMASTER:		skills = Skill_Dra; break;
     case PM_COMBATANT:		skills = Skill_Com; break;
     case PM_FJORDE:		skills = Skill_Fjo; break;
     case PM_PRACTICANT:		skills = Skill_Pra; break;
     case PM_EMERA:		skills = Skill_Eme; break;
     case PM_TOSSER:		skills = Skill_Tos; break;
     case PM_AKLYST:		skills = Skill_Akl; break;
     case PM_MILL_SWALLOWER:		skills = Skill_Mil; break;
     case PM_SYMBIANT:		skills = Skill_Sym; break;
     case PM_GENDERSTARIST:		skills = Skill_Gen; break;
     case PM_BUTT_LOVER:		skills = Skill_But; break;
     case PM_DANCER:		skills = Skill_Dan; break;
     case PM_DIABLIST:		skills = Skill_Dia; break;
     case PM_PREVERSIONER:		skills = Skill_Pre; break;
     case PM_SECRET_ADVICE_MEMBER:		skills = Skill_Sec; break;
     case PM_SHOE_FETISHIST:		skills = Skill_Sho; break;

     default:			skills = 0; break;	/* lint suppression */
    }

    while (skills->skill != P_NONE) {
	if (skills->skill == this_skill) return FALSE;
	++skills;
    }
    return TRUE;
}

STATIC_OVL void
ini_inv(trop)
register struct trobj *trop;
{
	struct obj *obj;
	struct obj *objX;
	int otyp, i;

	while (trop->trclass) {
		if (trop->trotyp != UNDEF_TYP && ((trop->trotyp == SCR_PHASE_DOOR || trop->trotyp == SCR_HEALING || trop->trotyp == SCR_EXTRA_HEALING || trop->trotyp == SCR_HEAL_OTHER || trop->trotyp == SCR_MANA || trop->trotyp == SCR_GREATER_MANA_RESTORATION || trop->trotyp == SCR_STANDARD_ID || trop->trotyp == SCR_CURE || (trop->trotyp == SCR_IDENTIFY && flags.lostsoul) || (trop->trotyp == TORCH && flags.lostsoul) || (trop->trotyp == FOOD_RATION && flags.lostsoul) || (trop->trotyp == SCR_IDENTIFY && flags.uberlostsoul) || (trop->trotyp == TORCH && flags.uberlostsoul) || (trop->trotyp == FOOD_RATION && flags.uberlostsoul) || (trop->trotyp == POT_FRUIT_JUICE && flags.uberlostsoul) || (trop->trotyp == TALLOW_CANDLE && flags.uberlostsoul) ) || !Race_if(PM_UNDEFINED_CREATURE) ) ) {
			otyp = (int)trop->trotyp;
			if (urace.malenum != PM_HUMAN) {
			    /* substitute specific items for generic ones */
			    for (i = 0; inv_subs[i].race_pm != NON_PM; ++i)
				if (inv_subs[i].race_pm == urace.malenum &&
					otyp == inv_subs[i].item_otyp) {
				    otyp = inv_subs[i].subs_otyp;
				    break;
				}
			}
			for (i = 0; inv_asubs[i].align != A_NONE; ++i)
			    if (inv_asubs[i].align == u.ualign.type &&
				    otyp == inv_asubs[i].item_otyp) {
				otyp = inv_asubs[i].subs_otyp;
				break;
			    }
			obj = mksobj(otyp, TRUE, Race_if(PM_STARTSCUMMER) ? TRUE : 2, FALSE);
			if (Race_if(PM_HAXOR)) objX = mksobj(otyp, TRUE, Race_if(PM_STARTSCUMMER) ? TRUE : 2, FALSE);
		} else {	/* UNDEF_TYP */
			static NEARDATA short nocreate = STRANGE_OBJECT;
			static NEARDATA short nocreate2 = STRANGE_OBJECT;
			static NEARDATA short nocreate3 = STRANGE_OBJECT;
			static NEARDATA short nocreate4 = STRANGE_OBJECT;
		/*
		 * For random objects, do not create certain overly powerful
		 * items: wand of wishing, ring of levitation, or the
		 * polymorph/polymorph control combination.  Specific objects,
		 * i.e. the discovery wishing, are still OK.
		 * Also, don't get a couple of really useless items.  (Note:
		 * punishment isn't "useless".  Some players who start out with
		 * one will immediately read it and use the iron ball as a
		 * weapon.)
		 */
			obj = mkobj(trop->trclass, FALSE, FALSE);
			if (Race_if(PM_HAXOR)) objX = mkobj(trop->trclass, FALSE, FALSE);
			otyp = obj->otyp;
			while (otyp == WAN_WISHING
				|| otyp == WAN_ACQUIREMENT
				|| otyp == SCR_WISHING
				|| otyp == SCR_RAGNAROK
				|| otyp == SCR_ASTRALCENSION
				|| otyp == TREASURE_CHEST
				|| otyp == SCR_ARTIFACT_CREATION
				|| otyp == SCR_ARTIFACT_JACKPOT
				|| otyp == SCR_RESURRECTION
				|| otyp == SCR_EXTRA_SKILL_POINT
				|| otyp == SCR_ACQUIREMENT
				|| otyp == SCR_ENTHRONIZATION
				|| otyp == SCR_MAKE_PENTAGRAM
				|| otyp == SCR_FOUNTAIN_BUILDING
				|| otyp == SCR_SINKING
				|| otyp == SCR_WC
				|| otyp == nocreate
				|| otyp == nocreate2
				|| otyp == nocreate3
				|| otyp == nocreate4
	/*			|| otyp == RIN_LEVITATION */
	/*			|| ((Role_if(PM_FLAME_MAGE) || Role_if(PM_ICE_MAGE))
						&&
				    (otyp == RIN_FIRE_RESISTANCE || 
				     otyp == RIN_COLD_RESISTANCE ||
				     otyp == SPE_ENDURE_HEAT ||
				     otyp == SPE_ENDURE_COLD)) */

				/* KMH -- Hobbits shouldn't get ring of invis. */
				/* || (Role_if(PM_HOBBIT) && otyp == RIN_INVISIBILITY) */

				/* KMH, balance patch -- now an amulet */
				/*|| (Role_if(PM_NECROMANCER) &&
						otyp == AMULET_OF_DRAIN_RESISTANCE)*/
				/* 'useless' or over powerful items */
				/*|| otyp == POT_HALLUCINATION
				|| otyp == POT_ACID
				|| otyp == SCR_AMNESIA
				|| otyp == SCR_FIRE
				|| otyp == SCR_BLANK_PAPER
				|| otyp == SPE_BLANK_PAPER
				|| otyp == RIN_AGGRAVATE_MONSTER
				|| otyp == RIN_HUNGER
				|| otyp == RIN_SLEEPING
				|| otyp == WAN_NOTHING*/
				/* Monks don't use weapons */
				/*|| (otyp == SCR_ENCHANT_WEAPON &&
				    Role_if(PM_MONK))*/
				/* wizard patch -- they already have one */
				/*|| (otyp == SPE_FORCE_BOLT &&
				    Role_if(PM_WIZARD))*/
				/* powerful spells are either useless to
				   low level players or unbalancing; also
				   spells in restricted skill categories */
				/*|| (obj->oclass == SPBOOK_CLASS &&
				    (objects[otyp].oc_level > 3 ||
				    restricted_spell_discipline(otyp)))*/
							) {
				dealloc_obj(obj);
				obj = mkobj(trop->trclass, FALSE, FALSE);
				otyp = obj->otyp;
			} /* re-enabled a lot of stuff. Startscum if you really have to. --Amy */

			if (Race_if(PM_HAXOR)) {

			if (!Hallucination) {

			if (!Race_if(PM_BASTARD)) obj->dknown = obj->bknown = obj->rknown = 1;
			if (objects[otyp].oc_uses_known && !Race_if(PM_BASTARD) ) obj->known = 1;
			obj->cursed = obj->hvycurse = obj->prmcurse = obj->morgcurse = obj->evilcurse = obj->bbrcurse = obj->stckcurse = obj->enchantment = 0;
			if (obj->opoisoned && u.ualign.type != A_CHAOTIC)
			    obj->opoisoned = 0;
			if (obj->oclass == WEAPON_CLASS ||
				obj->oclass == TOOL_CLASS || Race_if(PM_UNDEFINED_CREATURE) ) {
			    if (trop->trquan < 1) trop->trquan = 1; /* fail safe */
			    obj->quan = (long) trop->trquan;
			    if (Race_if(PM_UNDEFINED_CREATURE) && !objects[obj->otyp].oc_merge) obj->quan = 1;
			    trop->trquan = 1;
			} else if (obj->oclass == GEM_CLASS &&
				is_graystone(obj) && obj->otyp != FLINT) {
			    obj->quan = 1L;
			}
			if (OBJ_DESCR(objects[otyp]) && obj->known && !Race_if(PM_BASTARD) )
			discover_object(otyp, TRUE, FALSE);

			}

			otyp = objX->otyp;
			while (otyp == WAN_WISHING
				|| otyp == WAN_ACQUIREMENT
				|| otyp == SCR_WISHING
				|| otyp == SCR_RAGNAROK
				|| otyp == SCR_ASTRALCENSION
				|| otyp == TREASURE_CHEST
				|| otyp == SCR_ARTIFACT_CREATION
				|| otyp == SCR_ARTIFACT_JACKPOT
				|| otyp == SCR_RESURRECTION
				|| otyp == SCR_EXTRA_SKILL_POINT
				|| otyp == SCR_ACQUIREMENT
				|| otyp == SCR_ENTHRONIZATION
				|| otyp == SCR_MAKE_PENTAGRAM
				|| otyp == SCR_FOUNTAIN_BUILDING
				|| otyp == SCR_SINKING
				|| otyp == SCR_WC
				|| otyp == nocreate
				|| otyp == nocreate2
				|| otyp == nocreate3
				|| otyp == nocreate4
	/*			|| otyp == RIN_LEVITATION */
	/*			|| ((Role_if(PM_FLAME_MAGE) || Role_if(PM_ICE_MAGE))
						&&
				    (otyp == RIN_FIRE_RESISTANCE || 
				     otyp == RIN_COLD_RESISTANCE ||
				     otyp == SPE_ENDURE_HEAT ||
				     otyp == SPE_ENDURE_COLD)) */

				/* KMH -- Hobbits shouldn't get ring of invis. */
				/* || (Role_if(PM_HOBBIT) && otyp == RIN_INVISIBILITY) */

				/* KMH, balance patch -- now an amulet */
				/*|| (Role_if(PM_NECROMANCER) &&
						otyp == AMULET_OF_DRAIN_RESISTANCE)*/
				/* 'useless' or over powerful items */
				/*|| otyp == POT_HALLUCINATION
				|| otyp == POT_ACID
				|| otyp == SCR_AMNESIA
				|| otyp == SCR_FIRE
				|| otyp == SCR_BLANK_PAPER
				|| otyp == SPE_BLANK_PAPER
				|| otyp == RIN_AGGRAVATE_MONSTER
				|| otyp == RIN_HUNGER
				|| otyp == RIN_SLEEPING
				|| otyp == WAN_NOTHING*/
				/* Monks don't use weapons */
				/*|| (otyp == SCR_ENCHANT_WEAPON &&
				    Role_if(PM_MONK))*/
				/* wizard patch -- they already have one */
				/*|| (otyp == SPE_FORCE_BOLT &&
				    Role_if(PM_WIZARD))*/
				/* powerful spells are either useless to
				   low level players or unbalancing; also
				   spells in restricted skill categories */
				/*|| (objX->oclass == SPBOOK_CLASS &&
				    (objects[otyp].oc_level > 3 ||
				    restricted_spell_discipline(otyp)))*/
							) {
				dealloc_obj(objX);
				objX = mkobj(trop->trclass, FALSE, FALSE);
				otyp = objX->otyp;
			}
			}
			if (is_lightsaber(obj))
				obj->age = 1500;
			if (Race_if(PM_HAXOR)) {
			if (is_lightsaber(objX))
				objX->age = 1500;
			}
			/* start with maxed lightsaber
			only Jedi start with one, so no need to check
			Role_if here */

			/* Don't start with +0 or negative rings */
			/* Amy edit: why not? Randomness ftw! */
			/*if (objects[otyp].oc_charged && obj->spe <= 0)
				obj->spe = rne(2);*/

			/*if ((obj->oclass == WEAPON_CLASS || obj->oclass == ARMOR_CLASS) && !rn2(3))
				obj->spe = rne(2);*/

			/*if (Race_if(PM_HAXOR)) {
			if ((objX->oclass == WEAPON_CLASS || objX->oclass == ARMOR_CLASS) && !rn2(3))
				objX->spe = rne(2);
			}*/

			/* Heavily relies on the fact that 1) we create wands
			 * before rings, 2) that we create rings before
			 * spellbooks, and that 3) not more than 1 object of a
			 * particular symbol is to be prohibited.  (For more
			 * objects, we need more nocreate variables...)
			 */
			/*switch (otyp) {
			    case WAN_POLYMORPH:
			    case RIN_POLYMORPH:
			    case POT_POLYMORPH:
				nocreate = RIN_POLYMORPH_CONTROL;
				break;
			    case RIN_POLYMORPH_CONTROL:
				nocreate = RIN_POLYMORPH;
				nocreate2 = SPE_POLYMORPH;
				nocreate3 = POT_POLYMORPH;
			}*/
			/* Don't have 2 of the same ring or spellbook */
			/*if (obj->oclass == RING_CLASS ||
			    obj->oclass == SPBOOK_CLASS)
				nocreate4 = otyp;*/
		}

#ifdef GOLDOBJ
		if (trop->trclass == COIN_CLASS) {
			/* no "blessed" or "identified" money */
			obj->quan = u.umoney0;
		} else {
#endif
			if (!Race_if(PM_BASTARD)) obj->dknown = obj->bknown = obj->rknown = 1;
			if (objects[otyp].oc_uses_known && !Race_if(PM_BASTARD) ) obj->known = 1;
			obj->cursed = obj->hvycurse = obj->prmcurse = obj->morgcurse = obj->evilcurse = obj->bbrcurse = obj->stckcurse = obj->enchantment = 0;
			if (obj->opoisoned && u.ualign.type != A_CHAOTIC)
			    obj->opoisoned = 0;
			if (obj->oclass == WEAPON_CLASS ||
				obj->oclass == TOOL_CLASS || Race_if(PM_UNDEFINED_CREATURE) ) {
			    if (trop->trquan < 1) trop->trquan = 1; /* fail safe */
			    obj->quan = (long) trop->trquan;
			    if (Race_if(PM_UNDEFINED_CREATURE) && !objects[obj->otyp].oc_merge) obj->quan = 1;
			    trop->trquan = 1;
			} else if (obj->oclass == GEM_CLASS &&
				is_graystone(obj) && obj->otyp != FLINT) {
			    obj->quan = 1L;
			}


		if (Race_if(PM_HAXOR)) {


			if (!Race_if(PM_BASTARD)) objX->dknown = objX->bknown = objX->rknown = 1;
			if (objects[otyp].oc_uses_known && !Race_if(PM_BASTARD)) objX->known = 1;
			objX->cursed = objX->hvycurse = objX->prmcurse = objX->morgcurse = objX->evilcurse = objX->bbrcurse = objX->stckcurse = objX->enchantment = 0;
			if (objX->opoisoned && u.ualign.type != A_CHAOTIC)
			    objX->opoisoned = 0;
			if (objX->oclass == WEAPON_CLASS ||
				objX->oclass == TOOL_CLASS || Race_if(PM_UNDEFINED_CREATURE) ) {
			    if (trop->trquan < 1) trop->trquan = 1; /* fail safe */
			    objX->quan = (long) trop->trquan;
			    if (Race_if(PM_UNDEFINED_CREATURE) && !objects[objX->otyp].oc_merge) objX->quan = 1;
			    trop->trquan = 1;
			} else if (objX->oclass == GEM_CLASS &&
				is_graystone(objX) && objX->otyp != FLINT) {
			    objX->quan = 1L;
			}

            if (objX->otyp == STRIPED_SHIRT ) {
                objX->cursed = TRUE;
            }

	/* "Shirts for roles shouldn't be cursed in init. The only shirt that should be cursed is the striped shirt." In Soviet Russia, tourists want to be able to take off their shirt because they got kind of annoyed at shopkeepers overcharging them. Apparently, they always want things to be as easy as they can be. All the other tourists will have to find another way to deal with the shirt though. --Amy */

            if (objX->otyp == VICTORIAN_UNDERWEAR && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == T_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == HAWAIIAN_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BLACK_DRESS && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == CHANTER_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BAD_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BODYGLOVE && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == CASTSHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BEAUTIFUL_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == TOILET_ROLL && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == PETA_COMPLIANT_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == RADIOACTIVE_UNDERGARMENT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == KYRT_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == WOOLEN_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == METAL_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == RED_STRING && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == YOGA_PANTS && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == GREEN_GOWN && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == PRINTED_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == WAISTCLOTH && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == REINFORCED_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == FOAM_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == CRUMBLED_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == CANDY_BRA && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == ICHCAHUIPILLI && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == PETRIFYIUM_BRA && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == FLEECY_CORSET && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == FISHNET && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BATH_TOWEL && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == PLUGSUIT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == SWIMSUIT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == MEN_S_UNDERWEAR && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == RUFFLED_SHIRT && !issoviet ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == LOADSTONE ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == LOADBOULDER ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == STARLIGHTSTONE ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == SLEEPSTONE ) {
                objX->cursed = TRUE;
            }
            if (is_nastygraystone(objX) ) {
                objX->cursed = TRUE;
            }
            if (is_feminismstone(objX) ) {
                objX->cursed = TRUE;
            }

		if ((objX->otyp == SNIPER_RIFLE || objX->otyp == SHOTGUN_SHELL || objX->otyp == ROCK || objX->otyp == CYAN_DRAGON_SCALE_MAIL || objX->otyp == CLOAK_OF_LUCK_NEGATION || objX->otyp == ANTI_CASTER_CLOAK || objX->otyp == SADO_MASO_GLOVES || objX->otyp == STAIRWELL_STOMPING_BOOTS || objX->otyp == HELM_OF_THIRST || objX->otyp == HELM_OF_BAD_ALIGNMENT || objX->otyp == UNDROPPABLE_GLOVES || objX->otyp == GAUNTLETS_OF_TRAP_CREATION || objX->otyp == BOOTS_OF_WEAKNESS || objX->otyp == HEALTHSTONE || objX->otyp == STONE_OF_MAGIC_RESISTANCE || objX->otyp == SHADES_OF_GREY_STONE || objX->otyp == DSTW_STONE || objX->otyp == CONFUSION_STONE || objX->otyp == STONE_OF_INTRINSIC_LOSS || objX->otyp == ALIGNMENT_STONE || objX->otyp == TRAP_CREATION_STONE || objX->otyp == STONE_OF_VULNERABILITY || objX->otyp == STONE_OF_CURSING || objX->otyp == STATUS_STONE || objX->otyp == DEAFNESS_STONE || objX->otyp == AMULET_OF_POISON_WARNING || objX->otyp == RIN_SUSTAIN_ABILITY || objX->otyp == RIN_GAIN_INTELLIGENCE || objX->otyp == SPE_DARKNESS || objX->otyp == SPE_AGGRAVATE_MONSTER || objX->otyp == SPE_STUN_SELF || objX->otyp == FORTUNE_COOKIE || objX->otyp == CORPSE || objX->otyp == TIN_WHISTLE || objX->otyp == MIRROR || objX->otyp == TINNING_KIT || objX->otyp == CAN_OF_GREASE) && Role_if(PM_MURDERER) ) {
                objX->cursed = TRUE;
            }

            if (objX->otyp == QUARTERSTAFF && Role_if(PM_CELLAR_CHILD) ) {
                objX->cursed = TRUE;
                objX->stckcurse = TRUE;
            }
            if (objX->otyp == MAGE_PLATE_MAIL && Role_if(PM_CELLAR_CHILD) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
		    objX->enchantment = randnastyenchantment();
            }
            if (objX->otyp == ORCISH_SHORT_SWORD && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
            }
            if (objX->otyp == SHURIKEN && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
		    objX->greased = 1;
            }
            if (objX->otyp == ORCISH_RING_MAIL && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
                objX->enchantment = CONFLICT;
            }
            if (objX->otyp == LEATHER_CLOAK && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->enchantment = FIRE_RES;
            }
            if (objX->otyp == FEDORA && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->enchantment = HALF_PHDAM;
            }
            if (objX->otyp == REGULAR_GLOVES && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->enchantment = WARN_UNDEAD;
            }
            if (objX->otyp == AMULET_OF_QUICK_ATTACK && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
                objX->stckcurse = TRUE;
                objX->prmcurse = TRUE;
            }
            if (objX->otyp == DRAGON_EYEPATCH && Role_if(PM_GRENADONIN) ) {
                objX->cursed = TRUE;
            }

            if (objX->otyp == WAN_DEATH && (Role_if(PM_DEATH_EATER) || Race_if(PM_UNGENOMOLD) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == WAN_TELEPORTATION && (Race_if(PM_MAIA) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == KNIFE && (Role_if(PM_FAILED_EXISTENCE) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == COLLUSION_KNIFE && (Role_if(PM_KURWA) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BLOCK_HEELED_COMBAT_BOOT && (Role_if(PM_TRANSSYLVANIAN) ) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
            }
            if (objX->otyp == HIPPIE_HEELS && (Role_if(PM_TRANSSYLVANIAN) ) ) {
                objX->cursed = TRUE;
                objX->hvycurse = TRUE;
		    objX->enchantment = randnastyenchantment();
            }
            if (objX->otyp == DAGGER && (Role_if(PM_CAMPERSTRIKER) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == LEATHER_ARMOR && (Role_if(PM_CAMPERSTRIKER) ) ) {
                objX->cursed = objX->hvycurse = TRUE;
            }
            if (objX->otyp == SENTIENT_HIGH_HEELED_SHOES && (Role_if(PM_FAILED_EXISTENCE) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == UNICORN_HORN && (Race_if(PM_LEVITATOR) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == LUMP_OF_ROYAL_JELLY && (Race_if(PM_INSECTOID) ) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == AMULET_OF_LIFE_SAVING && (Role_if(PM_DEATH_EATER)) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == AMULET_OF_LIFE_SAVING && (Race_if(PM_DEVELOPER)) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == AMULET_OF_COVETOUS_WARNING && (Role_if(PM_GOFF)) ) {
                objX->cursed = TRUE;
            }
            if (objX->otyp == BLACK_DRAGON_SCALE_MAIL && (Role_if(PM_GOFF)) ) {
                objX->cursed = TRUE;
            }
		if (objX->oclass == SPBOOK_CLASS && objX->otyp != SPE_BLANK_PAPER) {
		    initialspell(objX);
		}

			if (trop->trspe != UNDEF_SPE)
			    objX->spe = trop->trspe;
			if (trop->trbless != UNDEF_BLESS)
			    objX->blessed = trop->trbless;

		objX->owt = weight(objX);

		} /* haxor, i.e. objX code */



            if (obj->otyp == STRIPED_SHIRT ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == VICTORIAN_UNDERWEAR && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == T_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == HAWAIIAN_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BLACK_DRESS && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BAD_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == CHANTER_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BODYGLOVE && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == CASTSHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BEAUTIFUL_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == PETA_COMPLIANT_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == TOILET_ROLL && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == RADIOACTIVE_UNDERGARMENT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == KYRT_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == WOOLEN_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == METAL_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == RED_STRING && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == YOGA_PANTS && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == GREEN_GOWN && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == PRINTED_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == WAISTCLOTH && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == REINFORCED_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == FOAM_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == CRUMBLED_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == CANDY_BRA && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == ICHCAHUIPILLI && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == PETRIFYIUM_BRA && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == FLEECY_CORSET && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == FISHNET && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BATH_TOWEL && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == PLUGSUIT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == SWIMSUIT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == MEN_S_UNDERWEAR && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == RUFFLED_SHIRT && !issoviet ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == LOADSTONE ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == LOADBOULDER ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == STARLIGHTSTONE ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == SLEEPSTONE ) {
                obj->cursed = TRUE;
            }
            if (is_nastygraystone(obj) ) {
                obj->cursed = TRUE;
            }
            if (is_feminismstone(obj) ) {
                obj->cursed = TRUE;
            }

            if (obj->otyp == UNICORN_HORN && (Race_if(PM_LEVITATOR) ) ) {
                obj->cursed = TRUE;
            }

		if ((obj->otyp == SNIPER_RIFLE || obj->otyp == SHOTGUN_SHELL || obj->otyp == ROCK || obj->otyp == CYAN_DRAGON_SCALE_MAIL || obj->otyp == CLOAK_OF_LUCK_NEGATION || obj->otyp == ANTI_CASTER_CLOAK || obj->otyp == SADO_MASO_GLOVES || obj->otyp == STAIRWELL_STOMPING_BOOTS || obj->otyp == HELM_OF_THIRST || obj->otyp == HELM_OF_BAD_ALIGNMENT || obj->otyp == UNDROPPABLE_GLOVES || obj->otyp == GAUNTLETS_OF_TRAP_CREATION || obj->otyp == BOOTS_OF_WEAKNESS || obj->otyp == HEALTHSTONE || obj->otyp == STONE_OF_MAGIC_RESISTANCE || obj->otyp == SHADES_OF_GREY_STONE || obj->otyp == DSTW_STONE || obj->otyp == CONFUSION_STONE || obj->otyp == STONE_OF_INTRINSIC_LOSS || obj->otyp == ALIGNMENT_STONE || obj->otyp == TRAP_CREATION_STONE || obj->otyp == STONE_OF_VULNERABILITY || obj->otyp == STONE_OF_CURSING || obj->otyp == STATUS_STONE || obj->otyp == DEAFNESS_STONE || obj->otyp == AMULET_OF_POISON_WARNING || obj->otyp == RIN_SUSTAIN_ABILITY || obj->otyp == RIN_GAIN_INTELLIGENCE || obj->otyp == SPE_DARKNESS || obj->otyp == SPE_AGGRAVATE_MONSTER || obj->otyp == SPE_STUN_SELF || obj->otyp == FORTUNE_COOKIE || obj->otyp == CORPSE || obj->otyp == TIN_WHISTLE || obj->otyp == MIRROR || obj->otyp == TINNING_KIT || obj->otyp == CAN_OF_GREASE) && Role_if(PM_MURDERER) ) {
                obj->cursed = TRUE;
            }

            if (obj->otyp == QUARTERSTAFF && Role_if(PM_CELLAR_CHILD) ) {
                obj->cursed = TRUE;
                obj->stckcurse = TRUE;
            }
            if (obj->otyp == MAGE_PLATE_MAIL && Role_if(PM_CELLAR_CHILD) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
		    obj->enchantment = randnastyenchantment();
            }
            if (obj->otyp == ORCISH_SHORT_SWORD && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
            }
            if (obj->otyp == SHURIKEN && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
		    obj->greased = 1;
            }
            if (obj->otyp == ORCISH_RING_MAIL && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
                obj->enchantment = CONFLICT;
            }
            if (obj->otyp == LEATHER_CLOAK && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->enchantment = FIRE_RES;
            }
            if (obj->otyp == FEDORA && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->enchantment = HALF_PHDAM;
            }
            if (obj->otyp == REGULAR_GLOVES && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->enchantment = WARN_UNDEAD;
            }
            if (obj->otyp == AMULET_OF_QUICK_ATTACK && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
                obj->stckcurse = TRUE;
                obj->prmcurse = TRUE;
            }
            if (obj->otyp == DRAGON_EYEPATCH && Role_if(PM_GRENADONIN) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == WAN_DEATH && (Role_if(PM_DEATH_EATER) || Race_if(PM_UNGENOMOLD) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == WAN_TELEPORTATION && (Race_if(PM_MAIA) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == KNIFE && (Role_if(PM_FAILED_EXISTENCE) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == COLLUSION_KNIFE && (Role_if(PM_KURWA) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BLOCK_HEELED_COMBAT_BOOT && (Role_if(PM_TRANSSYLVANIAN) ) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
            }
            if (obj->otyp == HIPPIE_HEELS && (Role_if(PM_TRANSSYLVANIAN) ) ) {
                obj->cursed = TRUE;
                obj->hvycurse = TRUE;
		    obj->enchantment = randnastyenchantment();
            }
            if (obj->otyp == DAGGER && (Role_if(PM_CAMPERSTRIKER) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == LEATHER_ARMOR && (Role_if(PM_CAMPERSTRIKER) ) ) {
                obj->cursed = obj->hvycurse = TRUE;
            }
            if (obj->otyp == SENTIENT_HIGH_HEELED_SHOES && (Role_if(PM_FAILED_EXISTENCE) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == LUMP_OF_ROYAL_JELLY && (Race_if(PM_INSECTOID) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == ASIAN_PEAR && (Role_if(PM_FOXHOUND_AGENT) ) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == AMULET_OF_LIFE_SAVING && (Role_if(PM_DEATH_EATER)) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == AMULET_OF_LIFE_SAVING && (Race_if(PM_DEVELOPER)) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == AMULET_OF_COVETOUS_WARNING && (Role_if(PM_GOFF)) ) {
                obj->cursed = TRUE;
            }
            if (obj->otyp == BLACK_DRAGON_SCALE_MAIL && (Role_if(PM_GOFF)) ) {
                obj->cursed = TRUE;
            }
			if (trop->trspe != UNDEF_SPE)
			    obj->spe = trop->trspe;
			if (trop->trbless != UNDEF_BLESS)
			    obj->blessed = trop->trbless;
#ifdef GOLDOBJ
		}
#endif
		/* defined after setting otyp+quan + blessedness */
		obj->owt = weight(obj);
				
		obj = addinv(obj);
		if (Race_if(PM_HAXOR)) objX = addinv(objX);

		/* Make the type known if necessary */
		if (OBJ_DESCR(objects[otyp]) && obj->known && !Race_if(PM_BASTARD) )
			discover_object(otyp, TRUE, FALSE);

		if (Race_if(PM_HAXOR)) {
		if (OBJ_DESCR(objects[otyp]) && objX->known && !Race_if(PM_BASTARD) )
			discover_object(otyp, TRUE, FALSE);
		}

		if (otyp == OIL_LAMP && !Race_if(PM_BASTARD) )
			discover_object(POT_OIL, TRUE, FALSE);

		if(obj->oclass == ARMOR_CLASS){
			if (is_shield(obj) && !uarms) {
				setworn(obj, W_ARMS);
				if (uswapwep) 
				  setuswapwep((struct obj *) 0, TRUE);
			} else if (is_helmet(obj) && !uarmh)
				setworn(obj, W_ARMH);
			else if (is_gloves(obj) && !uarmg)
				setworn(obj, W_ARMG);
			else if (is_shirt(obj) && !uarmu)
				setworn(obj, W_ARMU);
			else if (is_cloak(obj) && !uarmc)
				setworn(obj, W_ARMC);
			else if (is_boots(obj) && !uarmf)
				setworn(obj, W_ARMF);
			else if (is_suit(obj) && !uarm)
				setworn(obj, W_ARM);
		}

		if(obj->otyp == AMULET_OF_POISON_WARNING && (Role_if(PM_MURDERER)) ) {
				setworn(obj, W_AMUL);
			}

		if(obj->otyp == AMULET_OF_QUICK_ATTACK && (Role_if(PM_GRENADONIN)) ) {
				setworn(obj, W_AMUL);
			}

		if(obj->otyp == RIN_SUSTAIN_ABILITY && (Role_if(PM_MURDERER)) ) {
				setworn(obj, W_RINGL);
			}

		if(obj->otyp == RIN_GAIN_INTELLIGENCE && (Role_if(PM_MURDERER)) ) {
				setworn(obj, W_RINGR);
			}

		if(obj->otyp == AMULET_OF_LIFE_SAVING && (Role_if(PM_DEATH_EATER)) ) {
				setworn(obj, W_AMUL);
			}

		if(obj->otyp == AMULET_OF_LIFE_SAVING && (Race_if(PM_DEVELOPER)) ) {
				setworn(obj, W_AMUL);
			}

            if (obj->otyp == AMULET_OF_COVETOUS_WARNING && (Role_if(PM_GOFF)) ) {
				setworn(obj, W_AMUL);
            }


		if (obj->oclass == WEAPON_CLASS || is_weptool(obj) ||
			otyp == TIN_OPENER || otyp == FLINT || otyp == ROCK) {
		    if (is_ammo(obj) || is_missile(obj)) {
			if (!uquiver) setuqwep(obj);
		    } else if (!uwep) setuwep(obj, FALSE, TRUE);
		    else if (!uswapwep) setuswapwep(obj, FALSE);
		}
		if (obj->oclass == SPBOOK_CLASS &&
				obj->otyp != SPE_BLANK_PAPER)
		    initialspell(obj);

		if(trop->trquan) {		/* check if zero first */
			--trop->trquan;
			if(trop->trquan)
				continue;	/* make a similar object */
		}

		trop++;
	}

	if (plalias[0]) (void) strncpy(u.aliasname, plalias, sizeof(plalias));

	/*if (!strncmpi(plname, "lostsoul", 8)) { 
	goto_level(&medusa_level, FALSE, FALSE, FALSE); inspired by Tome, an Angband mod --Amy
	}*/

}

/* Alter reality: the flag controls which messages you get.
 * -1 = never give a message
 * 0 = "The power of Eru flows through you"
 * 1 = 90% chance of no message, 10% chance of "Suddenly, the reality is altered"
 */
void
alter_reality(realityflag)
int realityflag;
{

	register int i, temp, racebounus, rolebounus, alignbounus, genderbounus, maxbounus, randpantheon, starlitmonster, starlitattempts;
	register struct permonst *ptr;
	struct permonst* shamblerm = &mons[PM_NITROHACK_HORROR];
	struct permonst* shamblerma = &mons[PM_SPEEDHACK_HORROR];
	struct permonst* shamblern = &mons[PM_NETHACKFOUR_HORROR];
	struct permonst* shamblerna = &mons[PM_DEVTEAM_HORROR];
	struct permonst* shamblerl = &mons[PM_DNETHACK_HORROR];
	struct permonst* shamblerln = &mons[PM_BEGINNER_HORROR];
	struct permonst* shamblerlo = &mons[PM_NOOB_HORROR];
	struct permonst* shamblerla = &mons[PM_NETHACKBRASS_HORROR];
	struct permonst* shamblerx = &mons[PM_INTERHACK_HORROR];
	struct permonst* shamblerxz = &mons[PM_VERBOTEN_SIGN];
	struct permonst* gloshamblerx = &mons[PM_GLORKUM];
	struct permonst* gloshamblert = &mons[PM_MASTER_GLORKUM];
	struct permonst* gloshamblerz = &mons[PM_ARCHGLORKUM];
	struct permonst* shamblerxa = &mons[PM_NHTNG_HORROR];
	struct permonst* shambler = &mons[PM_UNNETHACK_HORROR];
	struct permonst* shamblerp = &mons[PM_UNNETHACKPLUS_HORROR];
	struct permonst* shamblera = &mons[PM_ANGBAND_HORROR];
	struct permonst* shamblerap = &mons[PM_ADOM_HORROR];
	struct permonst* shamblerb = &mons[PM_PETTY_ANGBAND_HORROR];
	struct permonst* shamblerbp = &mons[PM_PETTY_ADOM_HORROR];
	struct permonst* shamblers = &mons[PM_SPORKHACK_HORROR];
	struct permonst* shamblersp = &mons[PM_SLASHEM_HORROR];
	struct permonst* shamblerr = &mons[PM_NETHACK_HORROR];
	struct permonst* shamblerrp = &mons[PM_ROGUE_HORROR];	
	struct permonst* shamblert = &mons[PM_GRUNTHACK_HORROR];
	struct permonst* shamblerta = &mons[PM_ACEHACK_HORROR];
	struct permonst* shamblery = &mons[PM_MAIDENHACK_HORROR];
	struct permonst* shamblerya = &mons[PM_YASD_HORROR];
	struct permonst* shamblertp = &mons[PM_PETTY_GRUNTHACK_HORROR];
	struct permonst* shamblertpa = &mons[PM_PETTY_ACEHACK_HORROR];

	struct permonst* rshamblerx = &mons[PM_INTERHACK_HORROR_X];
	struct permonst* rshamblerxa = &mons[PM_NHTNG_HORROR_X];
	struct permonst* rpokshamblert = &mons[PM_SUIKUN_X];
	struct permonst* rpokshamblertp = &mons[PM_HOUOU_X];
	struct permonst* rshamblerz = &mons[PM_STONE_COLD_HORROR_X];
	struct permonst* rshamblerza = &mons[PM_PETROGRAPHY_HORROR_X];

	struct permonst* shamblerz = &mons[PM_STONE_COLD_HORROR];
	struct permonst* shamblerza = &mons[PM_PETROGRAPHY_HORROR];

	struct permonst* shamblernl = &mons[PM_NAMELESS_HORROR];
	struct permonst* shamblernla = &mons[PM_FACELESS_HORROR];

	struct permonst* shamblerplayer = &mons[PM_AK_THIEF_IS_DEAD_];
	struct permonst* shamblerplayerb = &mons[PM_UN_IN_PROTECT_MODE];

	struct permonst* shamblerplayergl = &mons[PM_PLAYER_GLORKUM];

	struct permonst* shamblerplayerc = &mons[PM_BROWN_MISSINGNO];
	struct permonst* shamblerplayerd = &mons[PM_RED_MISSINGNO];
	struct permonst* shamblerplayere = &mons[PM_BLACK_MISSINGNO];
	struct permonst* shamblerplayerf = &mons[PM_CYAN_MISSINGNO];
	struct permonst* shamblerplayerg = &mons[PM_GRAY_MISSINGNO];
	struct permonst* shamblerplayerh = &mons[PM_WHITE_MISSINGNO];
	struct permonst* shamblerplayeri = &mons[PM_GREEN_MISSINGNO];
	struct permonst* shamblerplayerj = &mons[PM_MAGENTA_MISSINGNO];
	struct permonst* shamblerplayerk = &mons[PM_YELLOW_MISSINGNO];
	struct permonst* shamblerplayerl = &mons[PM_ORANGE_MISSINGNO];
	struct permonst* shamblerplayerm = &mons[PM_BRIGHT_CYAN_MISSINGNO];
	struct permonst* shamblerplayern = &mons[PM_BRIGHT_MAGENTA_MISSINGNO];
	struct permonst* shamblerplayero = &mons[PM_BRIGHT_BLUE_MISSINGNO];
	struct permonst* shamblerplayerp = &mons[PM_BRIGHT_GREEN_MISSINGNO];

	struct permonst* shamblerplayerq = &mons[PM_BEIGE_MISSINGNO];
	struct permonst* shamblerplayerr = &mons[PM_SHADY_MISSINGNO];
	struct permonst* shamblerplayers = &mons[PM_DARK_MISSINGNO];
	struct permonst* shamblerplayert = &mons[PM_SCARLET_MISSINGNO];
	struct permonst* shamblerplayeru = &mons[PM_VIRIDIAN_MISSINGNO];
	struct permonst* shamblerplayerv = &mons[PM_UMBRA_MISSINGNO];
	struct permonst* shamblerplayerflum = &mons[PM_FLUMBUGUS];
	struct permonst* shamblerplayerw = &mons[PM_PURPLE_MISSINGNO];
	struct permonst* shamblerplayerx = &mons[PM_STEEL_MISSINGNO];
	struct permonst* shamblerplayery = &mons[PM_VIVID_MISSINGNO];
	struct permonst* shamblerplayerz = &mons[PM_POISONOUS_MISSINGNO];
	struct permonst* shamblerplayeraa = &mons[PM_TOPAZ_MISSINGNO];
	struct permonst* shamblerplayerab = &mons[PM_ULTRAMARINE_MISSINGNO];
	struct permonst* shamblerplayerac = &mons[PM_PINK_MISSINGNO];
	struct permonst* shamblerplayerad = &mons[PM_AZURE_MISSINGNO];
	struct permonst* shamblerplayerae = &mons[PM_MULTICOLORED_MISSINGNO];

	struct permonst* shamblerplayermso = &mons[PM_MISSINGNO];
	struct permonst* shamblerplayermsp = &mons[PM_POLYMORPHED_MISSINGNO];

	struct permonst* deathraylord = &mons[PM_YEENOGHU];
	struct permonst* coldlord = &mons[PM_ASMODEUS];
	struct permonst* multigrue = &mons[PM_MULTICOLOR_GRUE];

	struct permonst* lolirace = &mons[PM_LOLI];

	struct permonst* riderone = &mons[PM_DEATH];
	struct permonst* ridertwo = &mons[PM_FAMINE];
	struct permonst* riderthree = &mons[PM_PESTILENCE];

	struct permonst* randomeye = &mons[PM_MYSTIC_EYE];
	struct permonst* randommimic = &mons[PM_UNKNOWN_MIMIC];
	struct permonst* randommimicb = &mons[PM_UNKNOWN_PERMAMIMIC];
	struct permonst* rrandommimic = &mons[PM_UNKNOWN_MIMIC_X];
	struct permonst* rrandommimicb = &mons[PM_UNKNOWN_PERMAMIMIC_X];
	struct permonst* randompiercer = &mons[PM_SHINING_PIERCER];
	struct permonst* randompiercerb = &mons[PM_SHINING_PENETRATOR];
	struct permonst* randompiercerc = &mons[PM_SHINING_SMASHER];
	struct permonst* randompiercerd = &mons[PM_SHINING_RIPPER];
	struct permonst* randompiercere = &mons[PM_SHINING_CRASHER];
	struct permonst* randomvortex = &mons[PM_SIZZLING_VORTEX];
	struct permonst* randomfungus = &mons[PM_COLORLESS_MOLD];
	struct permonst* randomfungusb = &mons[PM_COLORLESS_FUNGUS];
	struct permonst* randomfungusba = &mons[PM_COLORLESS_PATCH];
	struct permonst* randomfungusbb = &mons[PM_COLORLESS_FORCE_FUNGUS];
	struct permonst* randomfungusbbx = &mons[PM_COLORLESS_WORT];
	struct permonst* randomfungusbc = &mons[PM_COLORLESS_FORCE_PATCH];
	struct permonst* randomfungusbd = &mons[PM_COLORLESS_WARP_FUNGUS];
	struct permonst* randomfungusbe = &mons[PM_COLORLESS_WARP_PATCH];
	struct permonst* randomfungusc = &mons[PM_NONDESCRIPT_MOLD];
	struct permonst* randomfungusd = &mons[PM_NONDESCRIPT_FUNGUS];
	struct permonst* randomfungusda = &mons[PM_NONDESCRIPT_PATCH];
	struct permonst* randomfungusdb = &mons[PM_NONDESCRIPT_FORCE_FUNGUS];
	struct permonst* randomfungusdbx = &mons[PM_NONDESCRIPT_WORT];
	struct permonst* randomfungusdc = &mons[PM_NONDESCRIPT_FORCE_PATCH];
	struct permonst* randomfungusdd = &mons[PM_NONDESCRIPT_WARP_FUNGUS];
	struct permonst* randomfungusde = &mons[PM_NONDESCRIPT_WARP_PATCH];
	struct permonst* randomfunguse = &mons[PM_COLORLESS_GROWTH];
	struct permonst* randomfungusf = &mons[PM_COLORLESS_MUSHROOM];
	struct permonst* randomfungusg = &mons[PM_COLORLESS_STALK];
	struct permonst* randomfungush = &mons[PM_COLORLESS_SPORE];
	struct permonst* randomfungusi = &mons[PM_COLORLESS_COLONY];
	struct permonst* randomfungusj = &mons[PM_NONDESCRIPT_GROWTH];
	struct permonst* randomfungusk = &mons[PM_NONDESCRIPT_MUSHROOM];
	struct permonst* randomfungusl = &mons[PM_NONDESCRIPT_STALK];
	struct permonst* randomfungusm = &mons[PM_NONDESCRIPT_SPORE];
	struct permonst* randomfungusn = &mons[PM_NONDESCRIPT_COLONY];
	struct permonst* rrandomfungusa = &mons[PM_COLORLESS_MOLD_X];
	struct permonst* rrandomfungusb = &mons[PM_COLORLESS_FUNGUS_X];
	struct permonst* rrandomfungusc = &mons[PM_COLORLESS_PATCH_X];
	struct permonst* rrandomfungusd = &mons[PM_COLORLESS_FORCE_FUNGUS_X];
	struct permonst* rrandomfungusdx = &mons[PM_COLORLESS_WORT_X];
	struct permonst* rrandomfunguse = &mons[PM_COLORLESS_FORCE_PATCH_X];
	struct permonst* rrandomfungusf = &mons[PM_COLORLESS_WARP_FUNGUS_X];
	struct permonst* rrandomfungusg = &mons[PM_COLORLESS_WARP_PATCH_X];
	struct permonst* rrandomfungush = &mons[PM_COLORLESS_GROWTH_X];
	struct permonst* rrandomfungusi = &mons[PM_COLORLESS_MUSHROOM_X];
	struct permonst* rrandomfungusj = &mons[PM_COLORLESS_STALK_X];
	struct permonst* rrandomfungusk = &mons[PM_COLORLESS_SPORE_X];
	struct permonst* rrandomfungusl = &mons[PM_COLORLESS_COLONY_X];

	struct permonst* randomkop = &mons[PM_ONG_SEPHIRAH];
	struct permonst* randomkopb = &mons[PM_KRONG_SEPHIRAH];
	struct permonst* rrandomkopb = &mons[PM_KRONG_SEPHIRAH_X];
	struct permonst* randomkopc = &mons[PM_ZAKRONG_SEPHIRAH];
	struct permonst* randomtroll = &mons[PM_SPECIAL_TROLL];
	struct permonst* randomeel = &mons[PM_TEETHFISH];
	struct permonst* randomflyfish = &mons[PM_RAZORFIN_FISH];
	struct permonst* randomturret = &mons[PM_UNKNOWN_TURRET];
	struct permonst* randomdragon = &mons[PM_RAINBOW_MODE_DRAGON];
	struct permonst* randompompeji = &mons[PM_POMPEJI_SHAMBLER];
	struct permonst* randompompejib = &mons[PM_POMPEJI_STUMBLER];
	struct permonst* randompompejic = &mons[PM_POMPEJI_SPILLER];

	struct permonst* randomsphere = &mons[PM_RNG_SPHERE];
	struct permonst* randomlight = &mons[PM_RNG_LIGHT];
	struct permonst* randomlightB = &mons[PM_RNG_LASER];
	struct permonst* randomlightC = &mons[PM_RNG_BEAM];
	struct permonst* randomlightD = &mons[PM_RNG_RAY];
	struct permonst* randomlightE = &mons[PM_RNG_BULB];
	struct permonst* randomlightF = &mons[PM_RNG_STAR];
	struct permonst* randomlightG = &mons[PM_RNG_BOOMER];

	struct permonst* shadowwarrior = &mons[PM_SHADOW_WARRIOR];
	struct permonst* shadowwarriorX = &mons[PM_ROBOT];

	struct permonst* randomdragonb = &mons[PM_ADULT_TATZELWORM];
	struct permonst* randomdragonc = &mons[PM_ADULT_AMPHITERE];
	struct permonst* randomdragond = &mons[PM_ADULT_DRAKEN];
	struct permonst* randomdragone = &mons[PM_ADULT_LINDWORM];
	struct permonst* randomdragonf = &mons[PM_ADULT_SARKANY];
	struct permonst* randomdragong = &mons[PM_ADULT_SIRRUSH];
	struct permonst* randomdragonh = &mons[PM_ADULT_LEVIATHAN];
	struct permonst* randomdragoni = &mons[PM_ADULT_WYVERN];
	struct permonst* randomdragonj = &mons[PM_ADULT_GLOWING_DRAGON];
	struct permonst* randomdragonk = &mons[PM_ADULT_GUIVRE];

	struct permonst* randombdragonb = &mons[PM_BABY_TATZELWORM];
	struct permonst* randombdragonc = &mons[PM_BABY_AMPHITERE];
	struct permonst* randombdragond = &mons[PM_BABY_DRAKEN];
	struct permonst* randombdragone = &mons[PM_BABY_LINDWORM];
	struct permonst* randombdragonf = &mons[PM_BABY_SARKANY];
	struct permonst* randombdragong = &mons[PM_BABY_SIRRUSH];
	struct permonst* randombdragonh = &mons[PM_BABY_LEVIATHAN];
	struct permonst* randombdragoni = &mons[PM_BABY_WYVERN];
	struct permonst* randombdragonj = &mons[PM_BABY_GLOWING_DRAGON];
	struct permonst* randombdragonk = &mons[PM_BABY_GUIVRE];

	struct permonst* rrandomdragonb = &mons[PM_ADULT_TATZELWORM_X];
	struct permonst* rrandomdragonc = &mons[PM_ADULT_AMPHITERE_X];
	struct permonst* rrandombdragonb = &mons[PM_BABY_TATZELWORM_X];
	struct permonst* rrandombdragonc = &mons[PM_BABY_AMPHITERE_X];

	struct permonst* splicemona = &mons[PM_SPLICED_AMALGAMATION];
	struct permonst* splicemonb = &mons[PM_SPLICED_BAD_CLONE];

	struct permonst* pokshamblerl = &mons[PM_PUPURIN];
	struct permonst* pokshamblerla = &mons[PM_SAPUSAUR];
	struct permonst* pokshamblerm = &mons[PM_ODDOSHISHI];
	struct permonst* pokshamblerma = &mons[PM_TSUBOTSUBO];
	struct permonst* pokshamblerx = &mons[PM_OKUTAN];
	struct permonst* pokshamblerxa = &mons[PM_RATICLAW];
	struct permonst* pokshambler = &mons[PM_PSYBUR];
	struct permonst* pokshamblerp = &mons[PM_HARISEN];
	struct permonst* pokshamblert = &mons[PM_SUIKUN];
	struct permonst* pokshamblertp = &mons[PM_HOUOU];
	struct permonst* pokshamblers = &mons[PM_LOCUSTOD];
	struct permonst* pokshamblersp = &mons[PM_FORETOSU];	
	struct permonst* pokshamblerxts = &mons[PM_CHARCOLT];
	struct permonst* pokshamblerxtsp = &mons[PM_MILLENUM];

	struct permonst* starlita = &mons[PM_STARLIT_SKY];
	struct permonst* starlitb = &mons[PM_DARK_STARLIT_SKY];
	struct permonst* starlitc = &mons[PM_BLACK_STARLIT_SKY];
	struct permonst* starlitd = &mons[PM_RED_STARLIT_SKY];
	struct permonst* starlite = &mons[PM_BROWN_STARLIT_SKY];
	struct permonst* starlitf = &mons[PM_GREEN_STARLIT_SKY];
	struct permonst* starlitg = &mons[PM_PURPLE_STARLIT_SKY];
	struct permonst* starlith = &mons[PM_YELLOW_STARLIT_SKY];
	struct permonst* starliti = &mons[PM_ORANGE_STARLIT_SKY];
	struct permonst* starlitj = &mons[PM_CYAN_STARLIT_SKY];
	struct permonst* starlitffx = &mons[PM_ENEMY_FROM_LEVEL___];
	struct permonst* starlitk = &mons[PM_VIOLET_STARLIT_SKY];

	struct permonst* starlitl = &mons[PM_MISNAMED_STARLIT_SKY];
	struct permonst* starlitm = &mons[PM_WRONG_NAMED_STARLIT_SKY];
	struct permonst* starlitn = &mons[PM_ERRONEOUS_STARLIT_SKY];

	struct permonst* starlitu = &mons[PM_TRUE_MISSINGNO];
	struct permonst* starlitv = &mons[PM_ETHEREAL_MISSINGNO];

	struct permonst* polyinitor = &mons[PM_POLYINITOR];
	struct permonst* destabilizer = &mons[PM_DESTABILIZER];

	struct permonst* randbossa = &mons[PM_EXTRA_FLEECY_BUNDLE];
	struct permonst* randbossb = &mons[PM_EMMELIE];
	struct permonst* randbossc = &mons[PM_LUISA];
	struct permonst* randbossd = &mons[PM_SHY_LAURA];
	struct permonst* randbosse = &mons[PM_ANNA];
	struct permonst* randbossf = &mons[PM_LEXI];
	struct permonst* randbossg = &mons[PM_SOFT_SARAH];
	struct permonst* randbossh = &mons[PM_MAREIKE];
	struct permonst* randbossi = &mons[PM_REBECCA];
	struct permonst* randbossj = &mons[PM_ROUGH_TERESA];
	struct permonst* randbossk = &mons[PM_JANINE];
	struct permonst* randbossl = &mons[PM_BITCHY_LARA];
	struct permonst* randbossm = &mons[PM_MARLEEN];
	struct permonst* randbossn = &mons[PM_NONEROTIC_IRINA];
	struct permonst* randbosso = &mons[PM_BUNDLY_ANN];
	struct permonst* randbossp = &mons[PM_LISELOTTE];
	struct permonst* randbossq = &mons[PM_LILLY];
	struct permonst* randbossr = &mons[PM_MIRIAM_THE_SPIRIT_GIRL];
	struct permonst* randbosss = &mons[PM_THE_SWEET_HIGH_HEEL_LOVING_ASIAN_GIRL];
	struct permonst* randbosst = &mons[PM_EMMA];
	struct permonst* randbossu = &mons[PM_ALIDA];
	struct permonst* randbossv = &mons[PM_JOSEFINE];
	struct permonst* randbossw = &mons[PM_VILEA];
	struct permonst* randbossx = &mons[PM_VILEA_S_SISTER];
	struct permonst* randbossy = &mons[PM_HANNAH];
	struct permonst* randbossz = &mons[PM_AMELJE];
	struct permonst* randbossaa = &mons[PM_NON_PRETTY_MELANIE];
	struct permonst* randbossab = &mons[PM_THE_SWEET_REDGUARD_GIRL];
	struct permonst* randbossac = &mons[PM_THE_HEELED_TOPMODEL];
	struct permonst* randbossad = &mons[PM_THE_HUGGING_TOPMODEL];
	struct permonst* randbossae = &mons[PM_MARIE];
	struct permonst* randbossaf = &mons[PM_THE_FAIRY];
	struct permonst* randbossag = &mons[PM_FANNY];
	struct permonst* randbossah = &mons[PM_THE_BASTARD_BROTHER_OF_SHY_LAURA];
	struct permonst* randbossai = &mons[PM_APE_HEAD];
	struct permonst* randbossaj = &mons[PM_BEANPOLE];
	struct permonst* randbossak = &mons[PM_CHEESEHEAD_SIMON];
	struct permonst* randbossal = &mons[PM_MALADJUSTED_LEON];
	struct permonst* randbossam = &mons[PM_MAX_THE_BADASS];
	struct permonst* randbossan = &mons[PM_ANTON];
	struct permonst* randbossao = &mons[PM_JONAS_THE_SCHIZO_AUTIST];
	struct permonst* randbossap = &mons[PM_LARS_THE_SCHIZOPHRENIC];
	struct permonst* randbossaq = &mons[PM_MELVIN];
	struct permonst* randbossar = &mons[PM_THE_BASTARD_BROTHER_OF_LILLY];
	struct permonst* randbossas = &mons[PM_THE_DISGUSTING_FRIEND_OF_LILLY_S_BROTHER];
	struct permonst* randbossat = &mons[PM_THE_DISGUSTING_SMOKER_FRIEND_OF_MARIE];
	struct permonst* randbossau = &mons[PM_SCHALOTTE];
	struct permonst* randbossav = &mons[PM_MAY_BRITT];
	struct permonst* randbossaw = &mons[PM_ROXY_GRETA];
	struct permonst* randbossax = &mons[PM_BUNDLE_NADJA];

	struct permonst* randfwea = &mons[PM_THE_EXTRA_FLEECY_BUNDLE_HER_HUGGING_BOOT];
	struct permonst* randfweb = &mons[PM_EMMELIE_S_SNEAKER];
	struct permonst* randfwec = &mons[PM_LUISA_S_HUGGING_BOOT];
	struct permonst* randfwed = &mons[PM_SHY_LAURA_S_LOVELY_COMBAT_BOOT];
	struct permonst* randfwee = &mons[PM_LEXI_S_WONDERFULLY_SOFT_SNEAKER];
	struct permonst* randfwef = &mons[PM_REBECCA_S_HUGGING_BOOT];
	struct permonst* randfweg = &mons[PM_ROUGH_TERESA_S_SNEAKER];
	struct permonst* randfweh = &mons[PM_JANINE_S_SNEAKER];
	struct permonst* randfwei = &mons[PM_BITCHY_LARA_S_HUGGING_BOOT];
	struct permonst* randfwej = &mons[PM_MARLEEN_S_SNEAKER];
	struct permonst* randfwek = &mons[PM_MARLEEN_S_HUGGING_BOOT];
	struct permonst* randfwel = &mons[PM_NONEROTIC_IRINA_S_WEDGE_SANDAL];
	struct permonst* randfwem = &mons[PM_BUNDLY_ANN_S_SOFT_SANDAL];
	struct permonst* randfwen = &mons[PM_LISELOTTE_S_HUGGING_BOOT];
	struct permonst* randfweo = &mons[PM_LISELOTTE_S_SOFT_SNEAKER];
	struct permonst* randfwep = &mons[PM_LILLY_S_FLEECY_COMBAT_BOOT];
	struct permonst* randfweq = &mons[PM_MAY_BRITT_S_FLUFFY_SANDAL];
	struct permonst* randfwer = &mons[PM_ROXY_GRETA_S_SNEAKER];
	struct permonst* randfwes = &mons[PM_THE_HIGH_HEEL_LOVING_ASIAN_GIRL_HER_HEELS];
	struct permonst* randfwet = &mons[PM_EMMA_S_ANKLE_BOOT];
	struct permonst* randfweu = &mons[PM_ALIDA_S_COLORFUL_SNEAKER];
	struct permonst* randfwev = &mons[PM_JOSEFINE_S_SUPER_SWEET_VELCRO_SNEAKER];
	struct permonst* randfwew = &mons[PM_VILEA_S_HUGGING_BOOT];
	struct permonst* randfwex = &mons[PM_HANNAH_S_COMBAT_BOOT];
	struct permonst* randfwey = &mons[PM_AMELJE_S_HUGGING_BOOT];
	struct permonst* randfwez = &mons[PM_AMELJE_S_SANDAL];
	struct permonst* randfweaa = &mons[PM_MELANIE_S_HUGGING_BOOT];
	struct permonst* randfweab = &mons[PM_THE_HUGGING_TOPMODEL_HER_HUGGING_BOOT];
	struct permonst* randfweac = &mons[PM_MARIE_S_HUGGING_BOOT];
	struct permonst* randfwead = &mons[PM_FANNY_S_VELCRO_SNEAKER];
	struct permonst* randfweae = &mons[PM_FANNY_S_BRAND_NEW_SNEAKER];
	struct permonst* randfweaf = &mons[PM_FANNY_S_BUCKLED_SANDAL];
	struct permonst* randfweag = &mons[PM_BUNDLE_NADJA_S_HUGGING_BOOT];
	struct permonst* randfweah = &mons[PM_ROUGH_TERESA_S_GENTLE_SOFT_SNEAKER];
	struct permonst* randfweai = &mons[PM_MARLEEN_S_BLOCK_HEELED_COMBAT_BOOT];
	struct permonst* randfweaj = &mons[PM_ALIDA_S_HUGGING_BOOT];
	struct permonst* randfweak = &mons[PM_BITCHY_LARA_S_BLOCK_HEELED_BOOT];
	struct permonst* randfweal = &mons[PM_EMMA_S_SEXY_WEDGE_SANDAL];
	struct permonst* randfweam = &mons[PM_THE_HIGH_HEEL_LOVING_ASIAN_GIRL_HER_SEXY_WEDGE_SANDAL];
	struct permonst* randfwean = &mons[PM_FANNY_S_LOVELY_WINTER_BOOT];
	struct permonst* randfweao = &mons[PM_EMMELIE_S_WHITE_HUGGING_BOOT];
	struct permonst* randfweap = &mons[PM_LUISA_S_DANCING_SHOE];
	struct permonst* randfweaq = &mons[PM_LUISA_S_SPUTA_FLOWING_BLOCK_HEEL_BOOT];

	struct permonst* randxya = &mons[PM_RANDO_ANT];
	struct permonst* randxyb = &mons[PM_RNGENERAL];
	struct permonst* randxyc = &mons[PM_VICIOUS_WOLF];
	struct permonst* randxyd = &mons[PM_MYRION];
	struct permonst* randxye = &mons[PM_UNEXPECTED_TIGER];
	struct permonst* randxyf = &mons[PM_CUBED_JELLY];
	struct permonst* randxyg = &mons[PM_KOBOLD_DICEROLLER];
	struct permonst* randxyh = &mons[PM_GYM_LEADER];
	struct permonst* randxyi = &mons[PM_RAINBOW_SENTAI];
	struct permonst* randxyj = &mons[PM_UNFAIR_ARCHON];
	struct permonst* randxyk = &mons[PM_CHAOS_RULECHANGER];
	struct permonst* randxyl = &mons[PM_RNGED_MONSTER];
	struct permonst* randxym = &mons[PM_RNG_KOP];
	struct permonst* randxyn = &mons[PM_RNG_SERGEANT];
	struct permonst* randxyo = &mons[PM_RNG_LIEUTENANT];
	struct permonst* randxyp = &mons[PM_RNG_KAPTAIN];
	struct permonst* randxyq = &mons[PM_RNG_KOMMISSIONER];
	struct permonst* randxyr = &mons[PM_RNG_KCHIEF];
	struct permonst* randxys = &mons[PM_RNG_KATCHER];
	struct permonst* randxyt = &mons[PM_RNG_KRIMINOLOGIST];
	struct permonst* randxytX = &mons[PM_RNG_KEELHAULER];
	struct permonst* randxytY = &mons[PM_RNG_KLEEVER];
	struct permonst* randxyu = &mons[PM_GENERATOR_LICH];
	struct permonst* randxyv = &mons[PM_WHIMLICH];
	struct permonst* randxyw = &mons[PM_RAINBOW_OGRE];
	struct permonst* randxyx = &mons[PM_RANDO];
	struct permonst* randxyy = &mons[PM_RNGHOST];
	struct permonst* randxyz = &mons[PM_RANDOMIZER_DRACONIAN];
	struct permonst* randxyaa = &mons[PM_CENTAUR_RENGER];
	struct permonst* randxyab = &mons[PM_MEGASPOILER_YRUAS];
	struct permonst* randxyac = &mons[PM_SHAMBLING_COUSIN];

	struct permonst* randhybrid = &mons[PM_HYBRIDRAGON];

	struct permonst* randspoilera = &mons[PM_ERROR_BUG];
	struct permonst* randspoilerb = &mons[PM_SPOILERHACK_HORROR];
	struct permonst* randspoilerc = &mons[PM_YOUNGWOMANHACK_HORROR];
	struct permonst* randspoilerd = &mons[PM_CHIPPED_BUG];
	struct permonst* randspoilere = &mons[PM_FLAWED_BUG];
	struct permonst* randspoilerf = &mons[PM_NORMAL_BUG];
	struct permonst* randspoilerg = &mons[PM_FLAWLESS_BUG];
	struct permonst* randspoilerh = &mons[PM_PERFECT_BUG];
	struct permonst* randspoileri = &mons[PM_DIVINE_BUG];
	struct permonst* randspoilerj = &mons[PM_GW_L__F____E_OA_];
	struct permonst* randspoilerk = &mons[PM_AGVZDHVZZXI_DGVZDHBHC_N_B_JK];
	struct permonst* randspoilerl = &mons[PM_BLUE_LICH];
	struct permonst* randspoilerm = &mons[PM_SPOILER_LICH];
	struct permonst* randspoilern = &mons[PM_OBER_PWNOR];
	struct permonst* randspoilero = &mons[PM_PWNERDUDE];
	struct permonst* randspoilerp = &mons[PM_BLONTOR];
	struct permonst* randspoilerq = &mons[PM_BLONGOR];

	struct permonst* randfluidator = &mons[PM_FLUIDATOR_WEGA];
	struct permonst* randfluidatorb = &mons[PM_FLUIDATOR_STARRA];

	static char buf[BUFSZ];

	struct attack* attkptr;

	monst_globals_init();

      u.monstertimeout = rnz(12000)+rnz(18000);
	while (u.monstertimeout < 10) u.monstertimeout = rnz(12000)+rnz(18000);

	if (rn2(3)) u.monstertimeout += rnz(12000)+rnz(18000);

      u.monstertimefinish = rnz(36000)+rnz(72000)+u.monstertimeout;
	while (u.monstertimefinish < 20) u.monstertimefinish = rnz(36000)+rnz(72000)+u.monstertimeout;

	u.ascensiontimelimit = rnz(100) * rnz(1000 + rnd(30000)); /* if you still didn't ascend at this turn count, the game becomes much harder */
	while (u.ascensiontimelimit < (issoviet ? 500000 : 250000)) u.ascensiontimelimit = rnz(100) * rnz(1000 + rnd(9000));
	u.ascensionfirsthint = ( (u.ascensiontimelimit / 10) + rnd(u.ascensiontimelimit / 10)); 
	u.ascensionsecondhint = ( u.ascensiontimelimit - rnd(u.ascensiontimelimit / 2)); 

	u.statuetrapname = rn2(NUMMONS);

	u.shaperoomchance = (rnd(15) + 3);	/* chance of irregular rooms */

	u.ungenocidable = randomgoodmclass(TRUE);
	u.speedymonster = 0;
	u.musemonster = 0;

	if (!rn2(3)) u.speedymonster = randomgoodmclass(TRUE);
	if (!rn2(20)) u.musemonster = randomgoodmclass(TRUE);

	u.alwaysinvisible = 0;
	if (!rn2(20)) u.alwaysinvisible = randomgoodmclass(TRUE);
	u.alwayshidden = 0;
	if (!rn2(500)) u.alwayshidden = randomgoodmclass(TRUE);

	u.frequentmonster = 0;
	u.freqmonsterbonus = 0;

	if (!rn2(2)) {
		u.frequentmonster = randomgoodmclass(FALSE);
		u.freqmonsterbonus = rne(4);
		if (!rn2(5)) u.freqmonsterbonus += rne(3);
		if (!rn2(3)) u.freqmonsterbonus *= 2;
		if (!rn2(5)) u.freqmonsterbonus *= 2;
		if (!rn2(8)) u.freqmonsterbonus += rne(4);
		if (!rn2(12)) u.freqmonsterbonus *= (1 + rne(15));
		if (!rn2(20)) u.freqmonsterbonus *= 3;
		if (!rn2(60)) u.freqmonsterbonus *= (1 + rne(12));
		if (!rn2(200)) u.freqmonsterbonus *= 4;
		if (!rn2(360)) u.freqmonsterbonus *= (1 + rne(10));
		if (!rn2(1360)) u.freqmonsterbonus *= (1 + rne(8));
		if (!rn2(5000)) u.freqmonsterbonus *= 5;
		if (!rn2(6360)) u.freqmonsterbonus *= (1 + rne(7));
		if (!rn2(25000)) u.freqmonsterbonus *= 6;
		if (!rn2(36360)) u.freqmonsterbonus *= (1 + rne(5));
		if (u.freqmonsterbonus > 100) u.freqmonsterbonus = 100; /* fail safe */
	}

	u.frequentcolor = 0;
	u.freqcolorbonus = 0;

	if (!rn2(10)) {
	u.frequentcolor = rnd(15);
	u.freqcolorbonus = rne(4);
	if (!rn2(5)) u.freqcolorbonus += rne(3);
	if (!rn2(3)) u.freqcolorbonus *= 2;
	if (!rn2(5)) u.freqcolorbonus *= 2;
	if (!rn2(8)) u.freqcolorbonus += rne(4);
	if (!rn2(12)) u.freqcolorbonus *= (1 + rne(15));
	if (!rn2(20)) u.freqcolorbonus *= 3;
	if (!rn2(60)) u.freqcolorbonus *= (1 + rne(12));
	if (!rn2(200)) u.freqcolorbonus *= 4;
	if (!rn2(360)) u.freqcolorbonus *= (1 + rne(10));
	if (!rn2(1360)) u.freqcolorbonus *= (1 + rne(8));
	if (!rn2(5000)) u.freqcolorbonus *= 5;
	if (!rn2(6360)) u.freqcolorbonus *= (1 + rne(7));
	if (!rn2(25000)) u.freqcolorbonus *= 6;
	if (!rn2(36360)) u.freqcolorbonus *= (1 + rne(5));
	if (u.freqcolorbonus > 100) u.freqcolorbonus = 100; /* fail safe */
	}

	register int traitamount = rnd(10); /* pick an # of monster traits that are more common --Amy */

	u.frequenttrait1 = rnd(434); /* same as monstercolor function */
	u.freqtraitbonus1 = rne(4);
	if (!rn2(5)) u.freqtraitbonus1 += rne(3);
	if (!rn2(3)) u.freqtraitbonus1 *= 2;
	if (!rn2(5)) u.freqtraitbonus1 *= 2;
	if (!rn2(8)) u.freqtraitbonus1 += rne(4);
	if (!rn2(12)) u.freqtraitbonus1 *= (1 + rne(15));
	if (!rn2(20)) u.freqtraitbonus1 *= 3;
	if (!rn2(60)) u.freqtraitbonus1 *= (1 + rne(12));
	if (!rn2(200)) u.freqtraitbonus1 *= 4;
	if (!rn2(360)) u.freqtraitbonus1 *= (1 + rne(10));
	if (!rn2(1360)) u.freqtraitbonus1 *= (1 + rne(8));
	if (!rn2(5000)) u.freqtraitbonus1 *= 5;
	if (!rn2(6360)) u.freqtraitbonus1 *= (1 + rne(7));
	if (!rn2(25000)) u.freqtraitbonus1 *= 6;
	if (!rn2(36360)) u.freqtraitbonus1 *= (1 + rne(5));
	if (u.freqtraitbonus1 > 100) u.freqtraitbonus1 = 100; /* fail safe */

	u.frequenttrait2 = 0;
	u.frequenttrait3 = 0;
	u.frequenttrait4 = 0;
	u.frequenttrait5 = 0;
	u.frequenttrait6 = 0;
	u.frequenttrait7 = 0;
	u.frequenttrait8 = 0;
	u.frequenttrait9 = 0;
	u.frequenttrait10 = 0;
	u.freqtraitbonus2 = 0;
	u.freqtraitbonus3 = 0;
	u.freqtraitbonus4 = 0;
	u.freqtraitbonus5 = 0;
	u.freqtraitbonus6 = 0;
	u.freqtraitbonus7 = 0;
	u.freqtraitbonus8 = 0;
	u.freqtraitbonus9 = 0;
	u.freqtraitbonus10 = 0;

	if (traitamount >= 2) {

		u.frequenttrait2 = rnd(434);
		u.freqtraitbonus2 = rne(4);
		if (!rn2(5)) u.freqtraitbonus2 += rne(3);
		if (!rn2(3)) u.freqtraitbonus2 *= 2;
		if (!rn2(5)) u.freqtraitbonus2 *= 2;
		if (!rn2(8)) u.freqtraitbonus2 += rne(4);
		if (!rn2(12)) u.freqtraitbonus2 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus2 *= 3;
		if (!rn2(60)) u.freqtraitbonus2 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus2 *= 4;
		if (!rn2(360)) u.freqtraitbonus2 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus2 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus2 *= 5;
		if (!rn2(6360)) u.freqtraitbonus2 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus2 *= 6;
		if (!rn2(36360)) u.freqtraitbonus2 *= (1 + rne(5));
		if (u.freqtraitbonus2 > 100) u.freqtraitbonus2 = 100; /* fail safe */

	}

	if (traitamount >= 3) {

		u.frequenttrait3 = rnd(434);
		u.freqtraitbonus3 = rne(4);
		if (!rn2(5)) u.freqtraitbonus3 += rne(3);
		if (!rn2(3)) u.freqtraitbonus3 *= 2;
		if (!rn2(5)) u.freqtraitbonus3 *= 2;
		if (!rn2(8)) u.freqtraitbonus3 += rne(4);
		if (!rn2(12)) u.freqtraitbonus3 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus3 *= 3;
		if (!rn2(60)) u.freqtraitbonus3 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus3 *= 4;
		if (!rn2(360)) u.freqtraitbonus3 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus3 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus3 *= 5;
		if (!rn2(6360)) u.freqtraitbonus3 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus3 *= 6;
		if (!rn2(36360)) u.freqtraitbonus3 *= (1 + rne(5));
		if (u.freqtraitbonus3 > 100) u.freqtraitbonus3 = 100; /* fail safe */

	}

	if (traitamount >= 4) {

		u.frequenttrait4 = rnd(434);
		u.freqtraitbonus4 = rne(4);
		if (!rn2(5)) u.freqtraitbonus4 += rne(3);
		if (!rn2(3)) u.freqtraitbonus4 *= 2;
		if (!rn2(5)) u.freqtraitbonus4 *= 2;
		if (!rn2(8)) u.freqtraitbonus4 += rne(4);
		if (!rn2(12)) u.freqtraitbonus4 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus4 *= 3;
		if (!rn2(60)) u.freqtraitbonus4 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus4 *= 4;
		if (!rn2(360)) u.freqtraitbonus4 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus4 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus4 *= 5;
		if (!rn2(6360)) u.freqtraitbonus4 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus4 *= 6;
		if (!rn2(36360)) u.freqtraitbonus4 *= (1 + rne(5));
		if (u.freqtraitbonus4 > 100) u.freqtraitbonus4 = 100; /* fail safe */

	}

	if (traitamount >= 5) {

		u.frequenttrait5 = rnd(434);
		u.freqtraitbonus5 = rne(4);
		if (!rn2(5)) u.freqtraitbonus5 += rne(3);
		if (!rn2(3)) u.freqtraitbonus5 *= 2;
		if (!rn2(5)) u.freqtraitbonus5 *= 2;
		if (!rn2(8)) u.freqtraitbonus5 += rne(4);
		if (!rn2(12)) u.freqtraitbonus5 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus5 *= 3;
		if (!rn2(60)) u.freqtraitbonus5 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus5 *= 4;
		if (!rn2(360)) u.freqtraitbonus5 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus5 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus5 *= 5;
		if (!rn2(6360)) u.freqtraitbonus5 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus5 *= 6;
		if (!rn2(36360)) u.freqtraitbonus5 *= (1 + rne(5));
		if (u.freqtraitbonus5 > 100) u.freqtraitbonus5 = 100; /* fail safe */

	}

	if (traitamount >= 6) {

		u.frequenttrait6 = rnd(434);
		u.freqtraitbonus6 = rne(4);
		if (!rn2(5)) u.freqtraitbonus6 += rne(3);
		if (!rn2(3)) u.freqtraitbonus6 *= 2;
		if (!rn2(5)) u.freqtraitbonus6 *= 2;
		if (!rn2(8)) u.freqtraitbonus6 += rne(4);
		if (!rn2(12)) u.freqtraitbonus6 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus6 *= 3;
		if (!rn2(60)) u.freqtraitbonus6 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus6 *= 4;
		if (!rn2(360)) u.freqtraitbonus6 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus6 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus6 *= 5;
		if (!rn2(6360)) u.freqtraitbonus6 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus6 *= 6;
		if (!rn2(36360)) u.freqtraitbonus6 *= (1 + rne(5));
		if (u.freqtraitbonus6 > 100) u.freqtraitbonus6 = 100; /* fail safe */

	}

	if (traitamount >= 7) {

		u.frequenttrait7 = rnd(434);
		u.freqtraitbonus7 = rne(4);
		if (!rn2(5)) u.freqtraitbonus7 += rne(3);
		if (!rn2(3)) u.freqtraitbonus7 *= 2;
		if (!rn2(5)) u.freqtraitbonus7 *= 2;
		if (!rn2(8)) u.freqtraitbonus7 += rne(4);
		if (!rn2(12)) u.freqtraitbonus7 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus7 *= 3;
		if (!rn2(60)) u.freqtraitbonus7 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus7 *= 4;
		if (!rn2(360)) u.freqtraitbonus7 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus7 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus7 *= 5;
		if (!rn2(6360)) u.freqtraitbonus7 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus7 *= 6;
		if (!rn2(36360)) u.freqtraitbonus7 *= (1 + rne(5));
		if (u.freqtraitbonus7 > 100) u.freqtraitbonus7 = 100; /* fail safe */

	}

	if (traitamount >= 8) {

		u.frequenttrait8 = rnd(434);
		u.freqtraitbonus8 = rne(4);
		if (!rn2(5)) u.freqtraitbonus8 += rne(3);
		if (!rn2(3)) u.freqtraitbonus8 *= 2;
		if (!rn2(5)) u.freqtraitbonus8 *= 2;
		if (!rn2(8)) u.freqtraitbonus8 += rne(4);
		if (!rn2(12)) u.freqtraitbonus8 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus8 *= 3;
		if (!rn2(60)) u.freqtraitbonus8 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus8 *= 4;
		if (!rn2(360)) u.freqtraitbonus8 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus8 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus8 *= 5;
		if (!rn2(6360)) u.freqtraitbonus8 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus8 *= 6;
		if (!rn2(36360)) u.freqtraitbonus8 *= (1 + rne(5));
		if (u.freqtraitbonus8 > 100) u.freqtraitbonus8 = 100; /* fail safe */

	}

	if (traitamount >= 9) {

		u.frequenttrait9 = rnd(434);
		u.freqtraitbonus9 = rne(4);
		if (!rn2(5)) u.freqtraitbonus9 += rne(3);
		if (!rn2(3)) u.freqtraitbonus9 *= 2;
		if (!rn2(5)) u.freqtraitbonus9 *= 2;
		if (!rn2(8)) u.freqtraitbonus9 += rne(4);
		if (!rn2(12)) u.freqtraitbonus9 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus9 *= 3;
		if (!rn2(60)) u.freqtraitbonus9 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus9 *= 4;
		if (!rn2(360)) u.freqtraitbonus9 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus9 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus9 *= 5;
		if (!rn2(6360)) u.freqtraitbonus9 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus9 *= 6;
		if (!rn2(36360)) u.freqtraitbonus9 *= (1 + rne(5));
		if (u.freqtraitbonus9 > 100) u.freqtraitbonus9 = 100; /* fail safe */

	}

	if (traitamount >= 10) {

		u.frequenttrait10 = rnd(434);
		u.freqtraitbonus10 = rne(4);
		if (!rn2(5)) u.freqtraitbonus10 += rne(3);
		if (!rn2(3)) u.freqtraitbonus10 *= 2;
		if (!rn2(5)) u.freqtraitbonus10 *= 2;
		if (!rn2(8)) u.freqtraitbonus10 += rne(4);
		if (!rn2(12)) u.freqtraitbonus10 *= (1 + rne(15));
		if (!rn2(20)) u.freqtraitbonus10 *= 3;
		if (!rn2(60)) u.freqtraitbonus10 *= (1 + rne(12));
		if (!rn2(200)) u.freqtraitbonus10 *= 4;
		if (!rn2(360)) u.freqtraitbonus10 *= (1 + rne(10));
		if (!rn2(1360)) u.freqtraitbonus10 *= (1 + rne(8));
		if (!rn2(5000)) u.freqtraitbonus10 *= 5;
		if (!rn2(6360)) u.freqtraitbonus10 *= (1 + rne(7));
		if (!rn2(25000)) u.freqtraitbonus10 *= 6;
		if (!rn2(36360)) u.freqtraitbonus10 *= (1 + rne(5));
		if (u.freqtraitbonus10 > 100) u.freqtraitbonus10 = 100; /* fail safe */

	}

	u.frequentspecies = -1;  
	u.frequentspecies2 = -1;  
	u.frequentspecies3 = -1;  
	u.frequentspecies4 = -1;  
	u.frequentspecies5 = -1;  
	u.frequentspecies6 = -1;  
	u.frequentspecies7 = -1;  
	u.frequentspecies8 = -1;  
	u.frequentspecies9 = -1;  
	u.frequentspecies10 = -1;  
	u.frequentspecies11 = -1;  
	u.frequentspecies12 = -1;  
	u.frequentspecies13 = -1;  
	u.frequentspecies14 = -1;  
	u.frequentspecies15 = -1;  
	u.frequentspecies16 = -1;  
	u.frequentspecies17 = -1;  
	u.frequentspecies18 = -1;  
	u.frequentspecies19 = -1;  
	u.frequentspecies20 = -1;  

	ptr = &mons[-1];
	while ((u.frequentspecies == 1) || (u.frequentspecies == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies];
	}
	u.freqspeciesbonus = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus += rne(2);
	u.freqspeciesbonus *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus *= 2;
	if (!rn2(7)) u.freqspeciesbonus *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus *= (1 + rne(2));
	if (u.freqspeciesbonus > 10000) u.freqspeciesbonus = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies2 == 1) || (u.frequentspecies2 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies2 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies2];
	}
	u.freqspeciesbonus2 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus2 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus2 += rne(2);
	u.freqspeciesbonus2 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus2 *= 2;
	if (!rn2(7)) u.freqspeciesbonus2 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus2 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus2 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus2 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus2 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus2 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus2 *= (1 + rne(2));
	if (u.freqspeciesbonus2 > 10000) u.freqspeciesbonus2 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies3 == 1) || (u.frequentspecies3 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies3 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies3];
	}
	u.freqspeciesbonus3 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus3 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus3 += rne(2);
	u.freqspeciesbonus3 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus3 *= 2;
	if (!rn2(7)) u.freqspeciesbonus3 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus3 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus3 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus3 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus3 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus3 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus3 *= (1 + rne(2));
	if (u.freqspeciesbonus3 > 10000) u.freqspeciesbonus3 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies4 == 1) || (u.frequentspecies4 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies4 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies4];
	}
	u.freqspeciesbonus4 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus4 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus4 += rne(2);
	u.freqspeciesbonus4 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus4 *= 2;
	if (!rn2(7)) u.freqspeciesbonus4 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus4 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus4 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus4 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus4 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus4 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus4 *= (1 + rne(2));
	if (u.freqspeciesbonus4 > 10000) u.freqspeciesbonus4 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies5 == 1) || (u.frequentspecies5 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies5 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies5];
	}
	u.freqspeciesbonus5 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus5 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus5 += rne(2);
	u.freqspeciesbonus5 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus5 *= 2;
	if (!rn2(7)) u.freqspeciesbonus5 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus5 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus5 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus5 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus5 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus5 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus5 *= (1 + rne(2));
	if (u.freqspeciesbonus5 > 10000) u.freqspeciesbonus5 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies6 == 1) || (u.frequentspecies6 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies6 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies6];
	}
	u.freqspeciesbonus6 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus6 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus6 += rne(2);
	u.freqspeciesbonus6 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus6 *= 2;
	if (!rn2(7)) u.freqspeciesbonus6 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus6 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus6 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus6 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus6 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus6 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus6 *= (1 + rne(2));
	if (u.freqspeciesbonus6 > 10000) u.freqspeciesbonus6 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies7 == 1) || (u.frequentspecies7 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies7 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies7];
	}
	u.freqspeciesbonus7 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus7 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus7 += rne(2);
	u.freqspeciesbonus7 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus7 *= 2;
	if (!rn2(7)) u.freqspeciesbonus7 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus7 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus7 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus7 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus7 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus7 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus7 *= (1 + rne(2));
	if (u.freqspeciesbonus7 > 10000) u.freqspeciesbonus7 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies8 == 1) || (u.frequentspecies8 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies8 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies8];
	}
	u.freqspeciesbonus8 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus8 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus8 += rne(2);
	u.freqspeciesbonus8 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus8 *= 2;
	if (!rn2(7)) u.freqspeciesbonus8 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus8 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus8 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus8 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus8 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus8 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus8 *= (1 + rne(2));
	if (u.freqspeciesbonus8 > 10000) u.freqspeciesbonus8 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies9 == 1) || (u.frequentspecies9 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies9 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies9];
	}
	u.freqspeciesbonus9 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus9 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus9 += rne(2);
	u.freqspeciesbonus9 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus9 *= 2;
	if (!rn2(7)) u.freqspeciesbonus9 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus9 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus9 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus9 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus9 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus9 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus9 *= (1 + rne(2));
	if (u.freqspeciesbonus9 > 10000) u.freqspeciesbonus9 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies10 == 1) || (u.frequentspecies10 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies10 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies10];
	}
	u.freqspeciesbonus10 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus10 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus10 += rne(2);
	u.freqspeciesbonus10 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus10 *= 2;
	if (!rn2(7)) u.freqspeciesbonus10 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus10 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus10 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus10 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus10 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus10 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus10 *= (1 + rne(2));
	if (u.freqspeciesbonus10 > 10000) u.freqspeciesbonus10 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies11 == 1) || (u.frequentspecies11 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies11 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies11];
	}
	u.freqspeciesbonus11 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus11 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus11 += rne(2);
	u.freqspeciesbonus11 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus11 *= 2;
	if (!rn2(7)) u.freqspeciesbonus11 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus11 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus11 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus11 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus11 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus11 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus11 *= (1 + rne(2));
	if (u.freqspeciesbonus11 > 10000) u.freqspeciesbonus11 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies12 == 1) || (u.frequentspecies12 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies12 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies12];
	}
	u.freqspeciesbonus12 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus12 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus12 += rne(2);
	u.freqspeciesbonus12 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus12 *= 2;
	if (!rn2(7)) u.freqspeciesbonus12 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus12 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus12 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus12 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus12 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus12 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus12 *= (1 + rne(2));
	if (u.freqspeciesbonus12 > 10000) u.freqspeciesbonus12 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies13 == 1) || (u.frequentspecies13 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies13 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies13];
	}
	u.freqspeciesbonus13 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus13 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus13 += rne(2);
	u.freqspeciesbonus13 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus13 *= 2;
	if (!rn2(7)) u.freqspeciesbonus13 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus13 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus13 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus13 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus13 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus13 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus13 *= (1 + rne(2));
	if (u.freqspeciesbonus13 > 10000) u.freqspeciesbonus13 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies14 == 1) || (u.frequentspecies14 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies14 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies14];
	}
	u.freqspeciesbonus14 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus14 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus14 += rne(2);
	u.freqspeciesbonus14 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus14 *= 2;
	if (!rn2(7)) u.freqspeciesbonus14 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus14 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus14 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus14 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus14 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus14 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus14 *= (1 + rne(2));
	if (u.freqspeciesbonus14 > 10000) u.freqspeciesbonus14 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies15 == 1) || (u.frequentspecies15 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies15 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies15];
	}
	u.freqspeciesbonus15 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus15 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus15 += rne(2);
	u.freqspeciesbonus15 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus15 *= 2;
	if (!rn2(7)) u.freqspeciesbonus15 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus15 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus15 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus15 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus15 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus15 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus15 *= (1 + rne(2));
	if (u.freqspeciesbonus15 > 10000) u.freqspeciesbonus15 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies16 == 1) || (u.frequentspecies16 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies16 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies16];
	}
	u.freqspeciesbonus16 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus16 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus16 += rne(2);
	u.freqspeciesbonus16 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus16 *= 2;
	if (!rn2(7)) u.freqspeciesbonus16 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus16 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus16 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus16 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus16 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus16 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus16 *= (1 + rne(2));
	if (u.freqspeciesbonus16 > 10000) u.freqspeciesbonus16 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies17 == 1) || (u.frequentspecies17 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies17 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies17];
	}
	u.freqspeciesbonus17 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus17 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus17 += rne(2);
	u.freqspeciesbonus17 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus17 *= 2;
	if (!rn2(7)) u.freqspeciesbonus17 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus17 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus17 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus17 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus17 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus17 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus17 *= (1 + rne(2));
	if (u.freqspeciesbonus17 > 10000) u.freqspeciesbonus17 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies18 == 1) || (u.frequentspecies18 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies18 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies18];
	}
	u.freqspeciesbonus18 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus18 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus18 += rne(2);
	u.freqspeciesbonus18 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus18 *= 2;
	if (!rn2(7)) u.freqspeciesbonus18 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus18 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus18 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus18 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus18 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus18 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus18 *= (1 + rne(2));
	if (u.freqspeciesbonus18 > 10000) u.freqspeciesbonus18 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies19 == 1) || (u.frequentspecies19 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies19 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies19];
	}
	u.freqspeciesbonus19 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus19 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus19 += rne(2);
	u.freqspeciesbonus19 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus19 *= 2;
	if (!rn2(7)) u.freqspeciesbonus19 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus19 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus19 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus19 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus19 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus19 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus19 *= (1 + rne(2));
	if (u.freqspeciesbonus19 > 10000) u.freqspeciesbonus19 = 10000; /* fail safe */

	ptr = &mons[-1];
	while ((u.frequentspecies20 == 1) || (u.frequentspecies20 == -1) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.frequentspecies20 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.frequentspecies20];
	}
	u.freqspeciesbonus20 = rn2(2) ? rne(2) : (1+rne(2));
	u.freqspeciesbonus20 += u.freqmonsterbonus;
	if (!rn2(5)) u.freqspeciesbonus20 += rne(2);
	u.freqspeciesbonus20 *= rnd(3);
	if (!rn2(3)) u.freqspeciesbonus20 *= 2;
	if (!rn2(7)) u.freqspeciesbonus20 *= (1 + rne(10));
	if (!rn2(15)) u.freqspeciesbonus20 *= (1 + rne(8));
	if (!rn2(45)) u.freqspeciesbonus20 *= (1 + rne(6));
	if (!rn2(125)) u.freqspeciesbonus20 *= (1 + rne(5));
	if (!rn2(625)) u.freqspeciesbonus20 *= (1 + rne(4));
	if (!rn2(2025)) u.freqspeciesbonus20 *= (1 + rne(3));
	if (!rn2(8025)) u.freqspeciesbonus20 *= (1 + rne(2));
	if (u.freqspeciesbonus20 > 10000) u.freqspeciesbonus20 = 10000; /* fail safe */

	u.nospawnspecies = -1;  
	u.nospawnspecies2 = -1;  
	u.nospawnspecies3 = -1;  
	u.nospawnspecies4 = -1;  
	u.nospawnspecies5 = -1;  
	u.nospawnspecies6 = -1;  
	u.nospawnspecies7 = -1;  
	u.nospawnspecies8 = -1;  
	u.nospawnspecies9 = -1;  
	u.nospawnspecies10 = -1;  

	ptr = &mons[-1];
	while ((u.nospawnspecies == 1) || (u.nospawnspecies == -1) || (u.nospawnspecies == u.frequentspecies) || (u.nospawnspecies == u.frequentspecies2) || (u.nospawnspecies == u.frequentspecies3) || (u.nospawnspecies == u.frequentspecies4) || (u.nospawnspecies == u.frequentspecies5) || (u.nospawnspecies == u.frequentspecies6) || (u.nospawnspecies == u.frequentspecies7) || (u.nospawnspecies == u.frequentspecies8) || (u.nospawnspecies == u.frequentspecies9) || (u.nospawnspecies == u.frequentspecies10) || (u.nospawnspecies == u.frequentspecies11) || (u.nospawnspecies == u.frequentspecies12) || (u.nospawnspecies == u.frequentspecies13) || (u.nospawnspecies == u.frequentspecies14) || (u.nospawnspecies == u.frequentspecies15) || (u.nospawnspecies == u.frequentspecies16) || (u.nospawnspecies == u.frequentspecies17) || (u.nospawnspecies == u.frequentspecies18) || (u.nospawnspecies == u.frequentspecies19) || (u.nospawnspecies == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies2 == 1) || (u.nospawnspecies2 == -1) || (u.nospawnspecies2 == u.frequentspecies) || (u.nospawnspecies2 == u.frequentspecies2) || (u.nospawnspecies2 == u.frequentspecies3) || (u.nospawnspecies2 == u.frequentspecies4) || (u.nospawnspecies2 == u.frequentspecies5) || (u.nospawnspecies2 == u.frequentspecies6) || (u.nospawnspecies2 == u.frequentspecies7) || (u.nospawnspecies2 == u.frequentspecies8) || (u.nospawnspecies2 == u.frequentspecies9) || (u.nospawnspecies2 == u.frequentspecies10) || (u.nospawnspecies2 == u.frequentspecies11) || (u.nospawnspecies2 == u.frequentspecies12) || (u.nospawnspecies2 == u.frequentspecies13) || (u.nospawnspecies2 == u.frequentspecies14) || (u.nospawnspecies2 == u.frequentspecies15) || (u.nospawnspecies2 == u.frequentspecies16) || (u.nospawnspecies2 == u.frequentspecies17) || (u.nospawnspecies2 == u.frequentspecies18) || (u.nospawnspecies2 == u.frequentspecies19) || (u.nospawnspecies2 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies2 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies2];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies3 == 1) || (u.nospawnspecies3 == -1) || (u.nospawnspecies3 == u.frequentspecies) || (u.nospawnspecies3 == u.frequentspecies2) || (u.nospawnspecies3 == u.frequentspecies3) || (u.nospawnspecies3 == u.frequentspecies4) || (u.nospawnspecies3 == u.frequentspecies5) || (u.nospawnspecies3 == u.frequentspecies6) || (u.nospawnspecies3 == u.frequentspecies7) || (u.nospawnspecies3 == u.frequentspecies8) || (u.nospawnspecies3 == u.frequentspecies9) || (u.nospawnspecies3 == u.frequentspecies10) || (u.nospawnspecies3 == u.frequentspecies11) || (u.nospawnspecies3 == u.frequentspecies12) || (u.nospawnspecies3 == u.frequentspecies13) || (u.nospawnspecies3 == u.frequentspecies14) || (u.nospawnspecies3 == u.frequentspecies15) || (u.nospawnspecies3 == u.frequentspecies16) || (u.nospawnspecies3 == u.frequentspecies17) || (u.nospawnspecies3 == u.frequentspecies18) || (u.nospawnspecies3 == u.frequentspecies19) || (u.nospawnspecies3 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies3 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies3];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies4 == 1) || (u.nospawnspecies4 == -1) || (u.nospawnspecies4 == u.frequentspecies) || (u.nospawnspecies4 == u.frequentspecies2) || (u.nospawnspecies4 == u.frequentspecies3) || (u.nospawnspecies4 == u.frequentspecies4) || (u.nospawnspecies4 == u.frequentspecies5) || (u.nospawnspecies4 == u.frequentspecies6) || (u.nospawnspecies4 == u.frequentspecies7) || (u.nospawnspecies4 == u.frequentspecies8) || (u.nospawnspecies4 == u.frequentspecies9) || (u.nospawnspecies4 == u.frequentspecies10) || (u.nospawnspecies4 == u.frequentspecies11) || (u.nospawnspecies4 == u.frequentspecies12) || (u.nospawnspecies4 == u.frequentspecies13) || (u.nospawnspecies4 == u.frequentspecies14) || (u.nospawnspecies4 == u.frequentspecies15) || (u.nospawnspecies4 == u.frequentspecies16) || (u.nospawnspecies4 == u.frequentspecies17) || (u.nospawnspecies4 == u.frequentspecies18) || (u.nospawnspecies4 == u.frequentspecies19) || (u.nospawnspecies4 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies4 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies4];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies5 == 1) || (u.nospawnspecies5 == -1) || (u.nospawnspecies5 == u.frequentspecies) || (u.nospawnspecies5 == u.frequentspecies2) || (u.nospawnspecies5 == u.frequentspecies3) || (u.nospawnspecies5 == u.frequentspecies4) || (u.nospawnspecies5 == u.frequentspecies5) || (u.nospawnspecies5 == u.frequentspecies6) || (u.nospawnspecies5 == u.frequentspecies7) || (u.nospawnspecies5 == u.frequentspecies8) || (u.nospawnspecies5 == u.frequentspecies9) || (u.nospawnspecies5 == u.frequentspecies10) || (u.nospawnspecies5 == u.frequentspecies11) || (u.nospawnspecies5 == u.frequentspecies12) || (u.nospawnspecies5 == u.frequentspecies13) || (u.nospawnspecies5 == u.frequentspecies14) || (u.nospawnspecies5 == u.frequentspecies15) || (u.nospawnspecies5 == u.frequentspecies16) || (u.nospawnspecies5 == u.frequentspecies17) || (u.nospawnspecies5 == u.frequentspecies18) || (u.nospawnspecies5 == u.frequentspecies19) || (u.nospawnspecies5 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies5 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies5];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies6 == 1) || (u.nospawnspecies6 == -1) || (u.nospawnspecies6 == u.frequentspecies) || (u.nospawnspecies6 == u.frequentspecies2) || (u.nospawnspecies6 == u.frequentspecies3) || (u.nospawnspecies6 == u.frequentspecies4) || (u.nospawnspecies6 == u.frequentspecies5) || (u.nospawnspecies6 == u.frequentspecies6) || (u.nospawnspecies6 == u.frequentspecies7) || (u.nospawnspecies6 == u.frequentspecies8) || (u.nospawnspecies6 == u.frequentspecies9) || (u.nospawnspecies6 == u.frequentspecies10) || (u.nospawnspecies6 == u.frequentspecies11) || (u.nospawnspecies6 == u.frequentspecies12) || (u.nospawnspecies6 == u.frequentspecies13) || (u.nospawnspecies6 == u.frequentspecies14) || (u.nospawnspecies6 == u.frequentspecies15) || (u.nospawnspecies6 == u.frequentspecies16) || (u.nospawnspecies6 == u.frequentspecies17) || (u.nospawnspecies6 == u.frequentspecies18) || (u.nospawnspecies6 == u.frequentspecies19) || (u.nospawnspecies6 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies6 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies6];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies7 == 1) || (u.nospawnspecies7 == -1) || (u.nospawnspecies7 == u.frequentspecies) || (u.nospawnspecies7 == u.frequentspecies2) || (u.nospawnspecies7 == u.frequentspecies3) || (u.nospawnspecies7 == u.frequentspecies4) || (u.nospawnspecies7 == u.frequentspecies5) || (u.nospawnspecies7 == u.frequentspecies6) || (u.nospawnspecies7 == u.frequentspecies7) || (u.nospawnspecies7 == u.frequentspecies8) || (u.nospawnspecies7 == u.frequentspecies9) || (u.nospawnspecies7 == u.frequentspecies10) || (u.nospawnspecies7 == u.frequentspecies11) || (u.nospawnspecies7 == u.frequentspecies12) || (u.nospawnspecies7 == u.frequentspecies13) || (u.nospawnspecies7 == u.frequentspecies14) || (u.nospawnspecies7 == u.frequentspecies15) || (u.nospawnspecies7 == u.frequentspecies16) || (u.nospawnspecies7 == u.frequentspecies17) || (u.nospawnspecies7 == u.frequentspecies18) || (u.nospawnspecies7 == u.frequentspecies19) || (u.nospawnspecies7 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies7 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies7];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies8 == 1) || (u.nospawnspecies8 == -1) || (u.nospawnspecies8 == u.frequentspecies) || (u.nospawnspecies8 == u.frequentspecies2) || (u.nospawnspecies8 == u.frequentspecies3) || (u.nospawnspecies8 == u.frequentspecies4) || (u.nospawnspecies8 == u.frequentspecies5) || (u.nospawnspecies8 == u.frequentspecies6) || (u.nospawnspecies8 == u.frequentspecies7) || (u.nospawnspecies8 == u.frequentspecies8) || (u.nospawnspecies8 == u.frequentspecies9) || (u.nospawnspecies8 == u.frequentspecies10) || (u.nospawnspecies8 == u.frequentspecies11) || (u.nospawnspecies8 == u.frequentspecies12) || (u.nospawnspecies8 == u.frequentspecies13) || (u.nospawnspecies8 == u.frequentspecies14) || (u.nospawnspecies8 == u.frequentspecies15) || (u.nospawnspecies8 == u.frequentspecies16) || (u.nospawnspecies8 == u.frequentspecies17) || (u.nospawnspecies8 == u.frequentspecies18) || (u.nospawnspecies8 == u.frequentspecies19) || (u.nospawnspecies8 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies8 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies8];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies9 == 1) || (u.nospawnspecies9 == -1) || (u.nospawnspecies9 == u.frequentspecies) || (u.nospawnspecies9 == u.frequentspecies2) || (u.nospawnspecies9 == u.frequentspecies3) || (u.nospawnspecies9 == u.frequentspecies4) || (u.nospawnspecies9 == u.frequentspecies5) || (u.nospawnspecies9 == u.frequentspecies6) || (u.nospawnspecies9 == u.frequentspecies7) || (u.nospawnspecies9 == u.frequentspecies8) || (u.nospawnspecies9 == u.frequentspecies9) || (u.nospawnspecies9 == u.frequentspecies10) || (u.nospawnspecies9 == u.frequentspecies11) || (u.nospawnspecies9 == u.frequentspecies12) || (u.nospawnspecies9 == u.frequentspecies13) || (u.nospawnspecies9 == u.frequentspecies14) || (u.nospawnspecies9 == u.frequentspecies15) || (u.nospawnspecies9 == u.frequentspecies16) || (u.nospawnspecies9 == u.frequentspecies17) || (u.nospawnspecies9 == u.frequentspecies18) || (u.nospawnspecies9 == u.frequentspecies19) || (u.nospawnspecies9 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies9 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies9];
	}

	ptr = &mons[-1];
	while ((u.nospawnspecies10 == 1) || (u.nospawnspecies10 == -1) || (u.nospawnspecies10 == u.frequentspecies) || (u.nospawnspecies10 == u.frequentspecies2) || (u.nospawnspecies10 == u.frequentspecies3) || (u.nospawnspecies10 == u.frequentspecies4) || (u.nospawnspecies10 == u.frequentspecies5) || (u.nospawnspecies10 == u.frequentspecies6) || (u.nospawnspecies10 == u.frequentspecies7) || (u.nospawnspecies10 == u.frequentspecies8) || (u.nospawnspecies10 == u.frequentspecies9) || (u.nospawnspecies10 == u.frequentspecies10) || (u.nospawnspecies10 == u.frequentspecies11) || (u.nospawnspecies10 == u.frequentspecies12) || (u.nospawnspecies10 == u.frequentspecies13) || (u.nospawnspecies10 == u.frequentspecies14) || (u.nospawnspecies10 == u.frequentspecies15) || (u.nospawnspecies10 == u.frequentspecies16) || (u.nospawnspecies10 == u.frequentspecies17) || (u.nospawnspecies10 == u.frequentspecies18) || (u.nospawnspecies10 == u.frequentspecies19) || (u.nospawnspecies10 == u.frequentspecies20) || ( ((int)(ptr->geno & G_FREQ)) < 1 ) ) {
		u.nospawnspecies10 = rn2(PM_LONG_WORM_TAIL);
		ptr = &mons[u.nospawnspecies10];
	}

	u.minimalism = 1 + rnd(4);
	if (!rn2(10)) u.minimalism += rnd(5);
	if (!rn2(100)) u.minimalism += rnz(5);

	u.femauspices4 = rnd(12);
	u.femauspices6 = rnd(12);
	u.femauspices8 = rnd(13);
	u.femauspices11 = rnd(16);
	u.femauspices13 = rnd(10);
	u.femauspices15 = rnd(10);
	u.femauspices17 = rnd(10);
	u.femauspices20 = rnd(10);
	u.femauspices22 = rnd(12);
	u.femauspices25 = rnd(10);
	u.femauspices28 = rnd(9);
	u.femauspices30 = rnd(10);

	u.feminizeffect = rnd(103); /* amount of feminism trap effects; keyword: "marlena" */
	u.contamjeweleffect = rnd(103); /* amount of feminism trap effects; keyword: "marlena" */

	u.climauspices3 = rnd(103);
	u.climauspices6 = rnd(103);
	u.climauspices9 = rnd(103);
	u.climauspices12 = rnd(103);
	u.climauspices15 = rnd(103);
	u.climauspices18 = rnd(103);
	u.climauspices21 = rnd(103);
	u.climauspices24 = rnd(103);
	u.climauspices27 = rnd(103);
	u.climauspices30 = rnd(103);

	u.sjwL1E1 = rnd(275); /* timerun and stuff */
	u.sjwL2E1 = rnd(275);
	u.sjwL3E1 = rnd(275);
	u.sjwL4E1 = rnd(275);
	u.sjwL5E1 = rnd(275);
	u.sjwL5E2 = rnd(275);
	u.sjwL6E1 = rnd(275);
	u.sjwL6E2 = rnd(275);
	u.sjwL7E1 = rnd(275);
	u.sjwL7E2 = rnd(275);
	u.sjwL8E1 = rnd(275);
	u.sjwL8E2 = rnd(275);
	u.sjwL9E1 = rnd(275);
	u.sjwL9E2 = rnd(275);
	u.sjwL10E1 = rnd(275);
	u.sjwL10E2 = rnd(275);
	u.sjwL10E3 = rnd(275);
	u.sjwL11E1 = rnd(275);
	u.sjwL11E2 = rnd(275);
	u.sjwL11E3 = rnd(275);
	u.sjwL12E1 = rnd(275);
	u.sjwL12E2 = rnd(275);
	u.sjwL12E3 = rnd(275);
	u.sjwL13E1 = rnd(275);
	u.sjwL13E2 = rnd(275);
	u.sjwL13E3 = rnd(275);
	u.sjwL14E1 = rnd(275);
	u.sjwL14E2 = rnd(275);
	u.sjwL14E3 = rnd(275);
	u.sjwL15E1 = rnd(275);
	u.sjwL15E2 = rnd(275);
	u.sjwL15E3 = rnd(275);
	u.sjwL15E4 = rnd(275);
	u.sjwL16E1 = rnd(275);
	u.sjwL16E2 = rnd(275);
	u.sjwL16E3 = rnd(275);
	u.sjwL16E4 = rnd(275);
	u.sjwL17E1 = rnd(275);
	u.sjwL17E2 = rnd(275);
	u.sjwL17E3 = rnd(275);
	u.sjwL17E4 = rnd(275);
	u.sjwL18E1 = rnd(275);
	u.sjwL18E2 = rnd(275);
	u.sjwL18E3 = rnd(275);
	u.sjwL18E4 = rnd(275);
	u.sjwL19E1 = rnd(275);
	u.sjwL19E2 = rnd(275);
	u.sjwL19E3 = rnd(275);
	u.sjwL19E4 = rnd(275);
	u.sjwL20E1 = rnd(275);
	u.sjwL20E2 = rnd(275);
	u.sjwL20E3 = rnd(275);
	u.sjwL20E4 = rnd(275);
	u.sjwL20E5 = rnd(275);
	u.sjwL21E1 = rnd(275);
	u.sjwL21E2 = rnd(275);
	u.sjwL21E3 = rnd(275);
	u.sjwL21E4 = rnd(275);
	u.sjwL21E5 = rnd(275);
	u.sjwL22E1 = rnd(275);
	u.sjwL22E2 = rnd(275);
	u.sjwL22E3 = rnd(275);
	u.sjwL22E4 = rnd(275);
	u.sjwL22E5 = rnd(275);
	u.sjwL23E1 = rnd(275);
	u.sjwL23E2 = rnd(275);
	u.sjwL23E3 = rnd(275);
	u.sjwL23E4 = rnd(275);
	u.sjwL23E5 = rnd(275);
	u.sjwL24E1 = rnd(275);
	u.sjwL24E2 = rnd(275);
	u.sjwL24E3 = rnd(275);
	u.sjwL24E4 = rnd(275);
	u.sjwL24E5 = rnd(275);
	u.sjwL25E1 = rnd(275);
	u.sjwL25E2 = rnd(275);
	u.sjwL25E3 = rnd(275);
	u.sjwL25E4 = rnd(275);
	u.sjwL25E5 = rnd(275);
	u.sjwL25E6 = rnd(275);
	u.sjwL26E1 = rnd(275);
	u.sjwL26E2 = rnd(275);
	u.sjwL26E3 = rnd(275);
	u.sjwL26E4 = rnd(275);
	u.sjwL26E5 = rnd(275);
	u.sjwL26E6 = rnd(275);
	u.sjwL27E1 = rnd(275);
	u.sjwL27E2 = rnd(275);
	u.sjwL27E3 = rnd(275);
	u.sjwL27E4 = rnd(275);
	u.sjwL27E5 = rnd(275);
	u.sjwL27E6 = rnd(275);
	u.sjwL28E1 = rnd(275);
	u.sjwL28E2 = rnd(275);
	u.sjwL28E3 = rnd(275);
	u.sjwL28E4 = rnd(275);
	u.sjwL28E5 = rnd(275);
	u.sjwL28E6 = rnd(275);
	u.sjwL29E1 = rnd(275);
	u.sjwL29E2 = rnd(275);
	u.sjwL29E3 = rnd(275);
	u.sjwL29E4 = rnd(275);
	u.sjwL29E5 = rnd(275);
	u.sjwL29E6 = rnd(275);
	u.sjwL30E1 = rnd(275);
	u.sjwL30E2 = rnd(275);
	u.sjwL30E3 = rnd(275);
	u.sjwL30E4 = rnd(275);
	u.sjwL30E5 = rnd(275);
	u.sjwL30E6 = rnd(275);
	u.sjwL30E7 = rnd(275);
	u.sjwL31E1 = rnd(275);
	u.sjwL31E2 = rnd(275);
	u.sjwL31E3 = rnd(275);
	u.sjwL31E4 = rnd(275);
	u.sjwL31E5 = rnd(275);
	u.sjwL31E6 = rnd(275);
	u.sjwL31E7 = rnd(275);
	u.sjwL32E1 = rnd(275);
	u.sjwL32E2 = rnd(275);
	u.sjwL32E3 = rnd(275);
	u.sjwL32E4 = rnd(275);
	u.sjwL32E5 = rnd(275);
	u.sjwL32E6 = rnd(275);
	u.sjwL32E7 = rnd(275);
	u.sjwL33E1 = rnd(275);
	u.sjwL33E2 = rnd(275);
	u.sjwL33E3 = rnd(275);
	u.sjwL33E4 = rnd(275);
	u.sjwL33E5 = rnd(275);
	u.sjwL33E6 = rnd(275);
	u.sjwL33E7 = rnd(275);
	u.sjwL34E1 = rnd(275);
	u.sjwL34E2 = rnd(275);
	u.sjwL34E3 = rnd(275);
	u.sjwL34E4 = rnd(275);
	u.sjwL34E5 = rnd(275);
	u.sjwL34E6 = rnd(275);
	u.sjwL34E7 = rnd(275);
	u.sjwL35E1 = rnd(275);
	u.sjwL35E2 = rnd(275);
	u.sjwL35E3 = rnd(275);
	u.sjwL35E4 = rnd(275);
	u.sjwL35E5 = rnd(275);
	u.sjwL35E6 = rnd(275);
	u.sjwL35E7 = rnd(275);
	u.sjwL36E1 = rnd(275);
	u.sjwL36E2 = rnd(275);
	u.sjwL36E3 = rnd(275);
	u.sjwL36E4 = rnd(275);
	u.sjwL36E5 = rnd(275);
	u.sjwL36E6 = rnd(275);
	u.sjwL36E7 = rnd(275);
	u.sjwL37E1 = rnd(275);
	u.sjwL37E2 = rnd(275);
	u.sjwL37E3 = rnd(275);
	u.sjwL37E4 = rnd(275);
	u.sjwL37E5 = rnd(275);
	u.sjwL37E6 = rnd(275);
	u.sjwL37E7 = rnd(275);
	u.sjwL38E1 = rnd(275);
	u.sjwL38E2 = rnd(275);
	u.sjwL38E3 = rnd(275);
	u.sjwL38E4 = rnd(275);
	u.sjwL38E5 = rnd(275);
	u.sjwL38E6 = rnd(275);
	u.sjwL38E7 = rnd(275);
	u.sjwL39E1 = rnd(275);
	u.sjwL39E2 = rnd(275);
	u.sjwL39E3 = rnd(275);
	u.sjwL39E4 = rnd(275);
	u.sjwL39E5 = rnd(275);
	u.sjwL39E6 = rnd(275);
	u.sjwL39E7 = rnd(275);
	u.sjwL40E1 = rnd(275);
	u.sjwL40E2 = rnd(275);
	u.sjwL40E3 = rnd(275);
	u.sjwL40E4 = rnd(275);
	u.sjwL40E5 = rnd(275);
	u.sjwL40E6 = rnd(275);
	u.sjwL40E7 = rnd(275);
	u.sjwL41E1 = rnd(275);
	u.sjwL41E2 = rnd(275);
	u.sjwL41E3 = rnd(275);
	u.sjwL41E4 = rnd(275);
	u.sjwL41E5 = rnd(275);
	u.sjwL41E6 = rnd(275);
	u.sjwL41E7 = rnd(275);
	u.sjwL42E1 = rnd(275);
	u.sjwL42E2 = rnd(275);
	u.sjwL42E3 = rnd(275);
	u.sjwL42E4 = rnd(275);
	u.sjwL42E5 = rnd(275);
	u.sjwL42E6 = rnd(275);
	u.sjwL42E7 = rnd(275);
	u.sjwL43E1 = rnd(275);
	u.sjwL43E2 = rnd(275);
	u.sjwL43E3 = rnd(275);
	u.sjwL43E4 = rnd(275);
	u.sjwL43E5 = rnd(275);
	u.sjwL43E6 = rnd(275);
	u.sjwL43E7 = rnd(275);
	u.sjwL44E1 = rnd(275);
	u.sjwL44E2 = rnd(275);
	u.sjwL44E3 = rnd(275);
	u.sjwL44E4 = rnd(275);
	u.sjwL44E5 = rnd(275);
	u.sjwL44E6 = rnd(275);
	u.sjwL44E7 = rnd(275);
	u.sjwL45E1 = rnd(275);
	u.sjwL45E2 = rnd(275);
	u.sjwL45E3 = rnd(275);
	u.sjwL45E4 = rnd(275);
	u.sjwL45E5 = rnd(275);
	u.sjwL45E6 = rnd(275);
	u.sjwL45E7 = rnd(275);
	u.sjwL46E1 = rnd(275);
	u.sjwL46E2 = rnd(275);
	u.sjwL46E3 = rnd(275);
	u.sjwL46E4 = rnd(275);
	u.sjwL46E5 = rnd(275);
	u.sjwL46E6 = rnd(275);
	u.sjwL46E7 = rnd(275);
	u.sjwL47E1 = rnd(275);
	u.sjwL47E2 = rnd(275);
	u.sjwL47E3 = rnd(275);
	u.sjwL47E4 = rnd(275);
	u.sjwL47E5 = rnd(275);
	u.sjwL47E6 = rnd(275);
	u.sjwL47E7 = rnd(275);
	u.sjwL48E1 = rnd(275);
	u.sjwL48E2 = rnd(275);
	u.sjwL48E3 = rnd(275);
	u.sjwL48E4 = rnd(275);
	u.sjwL48E5 = rnd(275);
	u.sjwL48E6 = rnd(275);
	u.sjwL48E7 = rnd(275);
	u.sjwL49E1 = rnd(275);
	u.sjwL49E2 = rnd(275);
	u.sjwL49E3 = rnd(275);
	u.sjwL49E4 = rnd(275);
	u.sjwL49E5 = rnd(275);
	u.sjwL49E6 = rnd(275);
	u.sjwL49E7 = rnd(275);
	u.sjwL50E1 = rnd(275);
	u.sjwL50E2 = rnd(275);
	u.sjwL50E3 = rnd(275);
	u.sjwL50E4 = rnd(275);
	u.sjwL50E5 = rnd(275);
	u.sjwL50E6 = rnd(275);
	u.sjwL50E7 = rnd(275);
	u.sjwL51E1 = rnd(275);
	u.sjwL51E2 = rnd(275);
	u.sjwL51E3 = rnd(275);
	u.sjwL51E4 = rnd(275);
	u.sjwL51E5 = rnd(275);
	u.sjwL51E6 = rnd(275);
	u.sjwL51E7 = rnd(275);
	u.sjwL52E1 = rnd(275);
	u.sjwL52E2 = rnd(275);
	u.sjwL52E3 = rnd(275);
	u.sjwL52E4 = rnd(275);
	u.sjwL52E5 = rnd(275);
	u.sjwL52E6 = rnd(275);
	u.sjwL52E7 = rnd(275);
	u.sjwL53E1 = rnd(275);
	u.sjwL53E2 = rnd(275);
	u.sjwL53E3 = rnd(275);
	u.sjwL53E4 = rnd(275);
	u.sjwL53E5 = rnd(275);
	u.sjwL53E6 = rnd(275);
	u.sjwL53E7 = rnd(275);
	u.sjwL54E1 = rnd(275);
	u.sjwL54E2 = rnd(275);
	u.sjwL54E3 = rnd(275);
	u.sjwL54E4 = rnd(275);
	u.sjwL54E5 = rnd(275);
	u.sjwL54E6 = rnd(275);
	u.sjwL54E7 = rnd(275);
	u.sjwL55E1 = rnd(275);
	u.sjwL55E2 = rnd(275);
	u.sjwL55E3 = rnd(275);
	u.sjwL55E4 = rnd(275);
	u.sjwL55E5 = rnd(275);
	u.sjwL55E6 = rnd(275);
	u.sjwL55E7 = rnd(275);
	u.sjwL56E1 = rnd(275);
	u.sjwL56E2 = rnd(275);
	u.sjwL56E3 = rnd(275);
	u.sjwL56E4 = rnd(275);
	u.sjwL56E5 = rnd(275);
	u.sjwL56E6 = rnd(275);
	u.sjwL56E7 = rnd(275);
	u.sjwL57E1 = rnd(275);
	u.sjwL57E2 = rnd(275);
	u.sjwL57E3 = rnd(275);
	u.sjwL57E4 = rnd(275);
	u.sjwL57E5 = rnd(275);
	u.sjwL57E6 = rnd(275);
	u.sjwL57E7 = rnd(275);
	u.sjwL58E1 = rnd(275);
	u.sjwL58E2 = rnd(275);
	u.sjwL58E3 = rnd(275);
	u.sjwL58E4 = rnd(275);
	u.sjwL58E5 = rnd(275);
	u.sjwL58E6 = rnd(275);
	u.sjwL58E7 = rnd(275);
	u.sjwL59E1 = rnd(275);
	u.sjwL59E2 = rnd(275);
	u.sjwL59E3 = rnd(275);
	u.sjwL59E4 = rnd(275);
	u.sjwL59E5 = rnd(275);
	u.sjwL59E6 = rnd(275);
	u.sjwL59E7 = rnd(275);

	u.dorian4 = rnd(275);
	u.dorian8 = rnd(275);
	u.dorian12 = rnd(275);
	u.dorian16 = rnd(275);
	u.dorian20 = rnd(275);
	u.dorian24 = rnd(275);
	u.dorian28 = rnd(275);

	u.startscummereffect = rnd(275);

	u.adpartattack = rn2(AD_ENDS);
	while (u.adpartattack == AD_ENDS || u.adpartattack == AD_WERE) u.adpartattack = rn2(AD_ENDS);
	u.adrunsattack = rnd(275); /* timerun etc. */

	register int unobtitemamount = rnd(10); /* pick an # of items that are unobtainable --Amy */

	u.unobtainable = -1;
	while ( (u.unobtainable == -1) || (u.unobtainable == GOLD_PIECE) || (u.unobtainable == STRANGE_OBJECT) || (u.unobtainable == AMULET_OF_YENDOR) || (u.unobtainable == CANDELABRUM_OF_INVOCATION) || (u.unobtainable == BELL_OF_OPENING) || (u.unobtainable == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable].oc_prob < 1) ) u.unobtainable = rn2(NUM_OBJECTS);

	u.unobtainable2 = -1;
	if (unobtitemamount >= 2) {
	while ( (u.unobtainable2 == -1) || (u.unobtainable2 == GOLD_PIECE) || (u.unobtainable2 == STRANGE_OBJECT) || (u.unobtainable2 == AMULET_OF_YENDOR) || (u.unobtainable2 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable2 == BELL_OF_OPENING) || (u.unobtainable2 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable2].oc_prob < 1) ) u.unobtainable2 = rn2(NUM_OBJECTS);
	}

	u.unobtainable3 = -1;
	if (unobtitemamount >= 3) {
	while ( (u.unobtainable3 == -1) || (u.unobtainable3 == GOLD_PIECE) || (u.unobtainable3 == STRANGE_OBJECT) || (u.unobtainable3 == AMULET_OF_YENDOR) || (u.unobtainable3 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable3 == BELL_OF_OPENING) || (u.unobtainable3 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable3].oc_prob < 1) ) u.unobtainable3 = rn2(NUM_OBJECTS);
	}

	u.unobtainable4 = -1;
	if (unobtitemamount >= 4) {
	while ( (u.unobtainable4 == -1) || (u.unobtainable4 == GOLD_PIECE) || (u.unobtainable4 == STRANGE_OBJECT) || (u.unobtainable4 == AMULET_OF_YENDOR) || (u.unobtainable4 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable4 == BELL_OF_OPENING) || (u.unobtainable4 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable4].oc_prob < 1) ) u.unobtainable4 = rn2(NUM_OBJECTS);
	}

	u.unobtainable5 = -1;
	if (unobtitemamount >= 5) {
	while ( (u.unobtainable5 == -1) || (u.unobtainable5 == GOLD_PIECE) || (u.unobtainable5 == STRANGE_OBJECT) || (u.unobtainable5 == AMULET_OF_YENDOR) || (u.unobtainable5 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable5 == BELL_OF_OPENING) || (u.unobtainable5 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable5].oc_prob < 1) ) u.unobtainable5 = rn2(NUM_OBJECTS);
	}

	u.unobtainable6 = -1;
	if (unobtitemamount >= 6) {
	while ( (u.unobtainable6 == -1) || (u.unobtainable6 == GOLD_PIECE) || (u.unobtainable6 == STRANGE_OBJECT) || (u.unobtainable6 == AMULET_OF_YENDOR) || (u.unobtainable6 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable6 == BELL_OF_OPENING) || (u.unobtainable6 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable6].oc_prob < 1) ) u.unobtainable6 = rn2(NUM_OBJECTS);
	}

	u.unobtainable7 = -1;
	if (unobtitemamount >= 7) {
	while ( (u.unobtainable7 == -1) || (u.unobtainable7 == GOLD_PIECE) || (u.unobtainable7 == STRANGE_OBJECT) || (u.unobtainable7 == AMULET_OF_YENDOR) || (u.unobtainable7 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable7 == BELL_OF_OPENING) || (u.unobtainable7 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable7].oc_prob < 1) ) u.unobtainable7 = rn2(NUM_OBJECTS);
	}

	u.unobtainable8 = -1;
	if (unobtitemamount >= 8) {
	while ( (u.unobtainable8 == -1) || (u.unobtainable8 == GOLD_PIECE) || (u.unobtainable8 == STRANGE_OBJECT) || (u.unobtainable8 == AMULET_OF_YENDOR) || (u.unobtainable8 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable8 == BELL_OF_OPENING) || (u.unobtainable8 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable8].oc_prob < 1) ) u.unobtainable8 = rn2(NUM_OBJECTS);
	}

	u.unobtainable9 = -1;
	if (unobtitemamount >= 9) {
	while ( (u.unobtainable9 == -1) || (u.unobtainable9 == GOLD_PIECE) || (u.unobtainable9 == STRANGE_OBJECT) || (u.unobtainable9 == AMULET_OF_YENDOR) || (u.unobtainable9 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable9 == BELL_OF_OPENING) || (u.unobtainable9 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable9].oc_prob < 1) ) u.unobtainable9 = rn2(NUM_OBJECTS);
	}

	u.unobtainable10 = -1;
	if (unobtitemamount >= 10) {
	while ( (u.unobtainable10 == -1) || (u.unobtainable10 == GOLD_PIECE) || (u.unobtainable10 == STRANGE_OBJECT) || (u.unobtainable10 == AMULET_OF_YENDOR) || (u.unobtainable10 == CANDELABRUM_OF_INVOCATION) || (u.unobtainable10 == BELL_OF_OPENING) || (u.unobtainable10 == SPE_BOOK_OF_THE_DEAD) || (objects[u.unobtainable10].oc_prob < 1) ) u.unobtainable10 = rn2(NUM_OBJECTS);
	}

	register int curseitemamount = rnd(10); /* pick an # of items that are always cursed --Amy */

	u.alwayscurseditem = -1;
	while ( (u.alwayscurseditem == -1) || (u.alwayscurseditem == u.unobtainable) || (u.alwayscurseditem == u.unobtainable2) || (u.alwayscurseditem == u.unobtainable3) || (u.alwayscurseditem == u.unobtainable4) || (u.alwayscurseditem == u.unobtainable5) || (u.alwayscurseditem == u.unobtainable6) || (u.alwayscurseditem == u.unobtainable7) || (u.alwayscurseditem == u.unobtainable8) || (u.alwayscurseditem == u.unobtainable9) || (u.alwayscurseditem == u.unobtainable10) || (u.alwayscurseditem == GOLD_PIECE) || (u.alwayscurseditem == STRANGE_OBJECT) || (u.alwayscurseditem == AMULET_OF_YENDOR) || (u.alwayscurseditem == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem == BELL_OF_OPENING) || (u.alwayscurseditem == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem].oc_prob < 1) ) u.alwayscurseditem = rn2(NUM_OBJECTS);

	u.alwayscurseditem2 = -1;
	if (curseitemamount >= 2) {
	while ( (u.alwayscurseditem2 == -1) || (u.alwayscurseditem2 == u.unobtainable) || (u.alwayscurseditem2 == u.unobtainable2) || (u.alwayscurseditem2 == u.unobtainable3) || (u.alwayscurseditem2 == u.unobtainable4) || (u.alwayscurseditem2 == u.unobtainable5) || (u.alwayscurseditem2 == u.unobtainable6) || (u.alwayscurseditem2 == u.unobtainable7) || (u.alwayscurseditem2 == u.unobtainable8) || (u.alwayscurseditem2 == u.unobtainable9) || (u.alwayscurseditem2 == u.unobtainable10) || (u.alwayscurseditem2 == GOLD_PIECE) || (u.alwayscurseditem2 == STRANGE_OBJECT) || (u.alwayscurseditem2 == AMULET_OF_YENDOR) || (u.alwayscurseditem2 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem2 == BELL_OF_OPENING) || (u.alwayscurseditem2 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem2].oc_prob < 1) ) u.alwayscurseditem2 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem3 = -1;
	if (curseitemamount >= 3) {
	while ( (u.alwayscurseditem3 == -1) || (u.alwayscurseditem3 == u.unobtainable) || (u.alwayscurseditem3 == u.unobtainable2) || (u.alwayscurseditem3 == u.unobtainable3) || (u.alwayscurseditem3 == u.unobtainable4) || (u.alwayscurseditem3 == u.unobtainable5) || (u.alwayscurseditem3 == u.unobtainable6) || (u.alwayscurseditem3 == u.unobtainable7) || (u.alwayscurseditem3 == u.unobtainable8) || (u.alwayscurseditem3 == u.unobtainable9) || (u.alwayscurseditem3 == u.unobtainable10) || (u.alwayscurseditem3 == GOLD_PIECE) || (u.alwayscurseditem3 == STRANGE_OBJECT) || (u.alwayscurseditem3 == AMULET_OF_YENDOR) || (u.alwayscurseditem3 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem3 == BELL_OF_OPENING) || (u.alwayscurseditem3 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem3].oc_prob < 1) ) u.alwayscurseditem3 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem4 = -1;
	if (curseitemamount >= 4) {
	while ( (u.alwayscurseditem4 == -1) || (u.alwayscurseditem4 == u.unobtainable) || (u.alwayscurseditem4 == u.unobtainable2) || (u.alwayscurseditem4 == u.unobtainable3) || (u.alwayscurseditem4 == u.unobtainable4) || (u.alwayscurseditem4 == u.unobtainable5) || (u.alwayscurseditem4 == u.unobtainable6) || (u.alwayscurseditem4 == u.unobtainable7) || (u.alwayscurseditem4 == u.unobtainable8) || (u.alwayscurseditem4 == u.unobtainable9) || (u.alwayscurseditem4 == u.unobtainable10) || (u.alwayscurseditem4 == GOLD_PIECE) || (u.alwayscurseditem4 == STRANGE_OBJECT) || (u.alwayscurseditem4 == AMULET_OF_YENDOR) || (u.alwayscurseditem4 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem4 == BELL_OF_OPENING) || (u.alwayscurseditem4 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem4].oc_prob < 1) ) u.alwayscurseditem4 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem5 = -1;
	if (curseitemamount >= 5) {
	while ( (u.alwayscurseditem5 == -1) || (u.alwayscurseditem5 == u.unobtainable) || (u.alwayscurseditem5 == u.unobtainable2) || (u.alwayscurseditem5 == u.unobtainable3) || (u.alwayscurseditem5 == u.unobtainable4) || (u.alwayscurseditem5 == u.unobtainable5) || (u.alwayscurseditem5 == u.unobtainable6) || (u.alwayscurseditem5 == u.unobtainable7) || (u.alwayscurseditem5 == u.unobtainable8) || (u.alwayscurseditem5 == u.unobtainable9) || (u.alwayscurseditem5 == u.unobtainable10) || (u.alwayscurseditem5 == GOLD_PIECE) || (u.alwayscurseditem5 == STRANGE_OBJECT) || (u.alwayscurseditem5 == AMULET_OF_YENDOR) || (u.alwayscurseditem5 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem5 == BELL_OF_OPENING) || (u.alwayscurseditem5 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem5].oc_prob < 1) ) u.alwayscurseditem5 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem6 = -1;
	if (curseitemamount >= 6) {
	while ( (u.alwayscurseditem6 == -1) || (u.alwayscurseditem6 == u.unobtainable) || (u.alwayscurseditem6 == u.unobtainable2) || (u.alwayscurseditem6 == u.unobtainable3) || (u.alwayscurseditem6 == u.unobtainable4) || (u.alwayscurseditem6 == u.unobtainable5) || (u.alwayscurseditem6 == u.unobtainable6) || (u.alwayscurseditem6 == u.unobtainable7) || (u.alwayscurseditem6 == u.unobtainable8) || (u.alwayscurseditem6 == u.unobtainable9) || (u.alwayscurseditem6 == u.unobtainable10) || (u.alwayscurseditem6 == GOLD_PIECE) || (u.alwayscurseditem6 == STRANGE_OBJECT) || (u.alwayscurseditem6 == AMULET_OF_YENDOR) || (u.alwayscurseditem6 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem6 == BELL_OF_OPENING) || (u.alwayscurseditem6 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem6].oc_prob < 1) ) u.alwayscurseditem6 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem7 = -1;
	if (curseitemamount >= 7) {
	while ( (u.alwayscurseditem7 == -1) || (u.alwayscurseditem7 == u.unobtainable) || (u.alwayscurseditem7 == u.unobtainable2) || (u.alwayscurseditem7 == u.unobtainable3) || (u.alwayscurseditem7 == u.unobtainable4) || (u.alwayscurseditem7 == u.unobtainable5) || (u.alwayscurseditem7 == u.unobtainable6) || (u.alwayscurseditem7 == u.unobtainable7) || (u.alwayscurseditem7 == u.unobtainable8) || (u.alwayscurseditem7 == u.unobtainable9) || (u.alwayscurseditem7 == u.unobtainable10) || (u.alwayscurseditem7 == GOLD_PIECE) || (u.alwayscurseditem7 == STRANGE_OBJECT) || (u.alwayscurseditem7 == AMULET_OF_YENDOR) || (u.alwayscurseditem7 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem7 == BELL_OF_OPENING) || (u.alwayscurseditem7 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem7].oc_prob < 1) ) u.alwayscurseditem7 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem8 = -1;
	if (curseitemamount >= 8) {
	while ( (u.alwayscurseditem8 == -1) || (u.alwayscurseditem8 == u.unobtainable) || (u.alwayscurseditem8 == u.unobtainable2) || (u.alwayscurseditem8 == u.unobtainable3) || (u.alwayscurseditem8 == u.unobtainable4) || (u.alwayscurseditem8 == u.unobtainable5) || (u.alwayscurseditem8 == u.unobtainable6) || (u.alwayscurseditem8 == u.unobtainable7) || (u.alwayscurseditem8 == u.unobtainable8) || (u.alwayscurseditem8 == u.unobtainable9) || (u.alwayscurseditem8 == u.unobtainable10) || (u.alwayscurseditem8 == GOLD_PIECE) || (u.alwayscurseditem8 == STRANGE_OBJECT) || (u.alwayscurseditem8 == AMULET_OF_YENDOR) || (u.alwayscurseditem8 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem8 == BELL_OF_OPENING) || (u.alwayscurseditem8 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem8].oc_prob < 1) ) u.alwayscurseditem8 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem9 = -1;
	if (curseitemamount >= 9) {
	while ( (u.alwayscurseditem9 == -1) || (u.alwayscurseditem9 == u.unobtainable) || (u.alwayscurseditem9 == u.unobtainable2) || (u.alwayscurseditem9 == u.unobtainable3) || (u.alwayscurseditem9 == u.unobtainable4) || (u.alwayscurseditem9 == u.unobtainable5) || (u.alwayscurseditem9 == u.unobtainable6) || (u.alwayscurseditem9 == u.unobtainable7) || (u.alwayscurseditem9 == u.unobtainable8) || (u.alwayscurseditem9 == u.unobtainable9) || (u.alwayscurseditem9 == u.unobtainable10) || (u.alwayscurseditem9 == GOLD_PIECE) || (u.alwayscurseditem9 == STRANGE_OBJECT) || (u.alwayscurseditem9 == AMULET_OF_YENDOR) || (u.alwayscurseditem9 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem9 == BELL_OF_OPENING) || (u.alwayscurseditem9 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem9].oc_prob < 1) ) u.alwayscurseditem9 = rn2(NUM_OBJECTS);
	}

	u.alwayscurseditem10 = -1;
	if (curseitemamount >= 10) {
	while ( (u.alwayscurseditem10 == -1) || (u.alwayscurseditem10 == u.unobtainable) || (u.alwayscurseditem10 == u.unobtainable2) || (u.alwayscurseditem10 == u.unobtainable3) || (u.alwayscurseditem10 == u.unobtainable4) || (u.alwayscurseditem10 == u.unobtainable5) || (u.alwayscurseditem10 == u.unobtainable6) || (u.alwayscurseditem10 == u.unobtainable7) || (u.alwayscurseditem10 == u.unobtainable8) || (u.alwayscurseditem10 == u.unobtainable9) || (u.alwayscurseditem10 == u.unobtainable10) || (u.alwayscurseditem10 == GOLD_PIECE) || (u.alwayscurseditem10 == STRANGE_OBJECT) || (u.alwayscurseditem10 == AMULET_OF_YENDOR) || (u.alwayscurseditem10 == CANDELABRUM_OF_INVOCATION) || (u.alwayscurseditem10 == BELL_OF_OPENING) || (u.alwayscurseditem10 == SPE_BOOK_OF_THE_DEAD) || (objects[u.alwayscurseditem10].oc_prob < 1) ) u.alwayscurseditem10 = rn2(NUM_OBJECTS);
	}

	u.veryobtainable = -1;
	while ( (u.veryobtainable == -1) || (u.veryobtainable == GOLD_PIECE) || (u.veryobtainable == STRANGE_OBJECT) || (u.veryobtainable == AMULET_OF_YENDOR) || (u.veryobtainable == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable == BELL_OF_OPENING) || (u.veryobtainable == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable == SCR_WISHING) || (u.veryobtainable == SCR_RESURRECTION) || (u.veryobtainable == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable == SCR_WORLD_FALL) || (u.veryobtainable == SCR_ASTRALCENSION) || (u.veryobtainable == TREASURE_CHEST) || (u.veryobtainable == SCR_RAGNAROK) || (u.veryobtainable == SCR_ARTIFACT_CREATION) || (u.veryobtainable == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable == WAN_WISHING) || (u.veryobtainable == u.unobtainable) || (u.veryobtainable == u.unobtainable2) || (u.veryobtainable == u.unobtainable3) || (u.veryobtainable == u.unobtainable4) || (u.veryobtainable == u.unobtainable5) || (u.veryobtainable == u.unobtainable6) || (u.veryobtainable == u.unobtainable7) || (u.veryobtainable == u.unobtainable8) || (u.veryobtainable == u.unobtainable9) || (u.veryobtainable == u.unobtainable10) || (objects[u.veryobtainable].oc_prob < 1) ) u.veryobtainable = rn2(NUM_OBJECTS);
	u.veryobtainableboost = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost += rnz(10);
	if (!rn2(25)) u.veryobtainableboost += rnz(100);
	if (u.veryobtainableboost > 1000) u.veryobtainableboost = 1000; /* sanity check */

	u.veryobtainable2 = -1;
	while ( (u.veryobtainable2 == -1) || (u.veryobtainable2 == GOLD_PIECE) || (u.veryobtainable2 == STRANGE_OBJECT) || (u.veryobtainable2 == AMULET_OF_YENDOR) || (u.veryobtainable2 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable2 == BELL_OF_OPENING) || (u.veryobtainable2 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable2 == SCR_WISHING) || (u.veryobtainable2 == SCR_RESURRECTION) || (u.veryobtainable2 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable2 == SCR_WORLD_FALL) || (u.veryobtainable2 == SCR_ASTRALCENSION) || (u.veryobtainable2 == TREASURE_CHEST) || (u.veryobtainable2 == SCR_RAGNAROK) || (u.veryobtainable2 == SCR_ARTIFACT_CREATION) || (u.veryobtainable2 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable2 == WAN_WISHING) || (u.veryobtainable2 == u.unobtainable) || (u.veryobtainable2 == u.unobtainable2) || (u.veryobtainable2 == u.unobtainable3) || (u.veryobtainable2 == u.unobtainable4) || (u.veryobtainable2 == u.unobtainable5) || (u.veryobtainable2 == u.unobtainable6) || (u.veryobtainable2 == u.unobtainable7) || (u.veryobtainable2 == u.unobtainable8) || (u.veryobtainable2 == u.unobtainable9) || (u.veryobtainable2 == u.unobtainable10) || (objects[u.veryobtainable2].oc_prob < 1) ) u.veryobtainable2 = rn2(NUM_OBJECTS);
	u.veryobtainableboost2 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost2 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost2 += rnz(100);
	if (u.veryobtainableboost2 > 1000) u.veryobtainableboost2 = 1000; /* sanity check */

	u.veryobtainable3 = -1;
	while ( (u.veryobtainable3 == -1) || (u.veryobtainable3 == GOLD_PIECE) || (u.veryobtainable3 == STRANGE_OBJECT) || (u.veryobtainable3 == AMULET_OF_YENDOR) || (u.veryobtainable3 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable3 == BELL_OF_OPENING) || (u.veryobtainable3 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable3 == SCR_WISHING) || (u.veryobtainable3 == SCR_RESURRECTION) || (u.veryobtainable3 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable3 == SCR_WORLD_FALL) || (u.veryobtainable3 == SCR_ASTRALCENSION) || (u.veryobtainable3 == TREASURE_CHEST) || (u.veryobtainable3 == SCR_RAGNAROK) || (u.veryobtainable3 == SCR_ARTIFACT_CREATION) || (u.veryobtainable3 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable3 == WAN_WISHING) || (u.veryobtainable3 == u.unobtainable) || (u.veryobtainable3 == u.unobtainable2) || (u.veryobtainable3 == u.unobtainable3) || (u.veryobtainable3 == u.unobtainable4) || (u.veryobtainable3 == u.unobtainable5) || (u.veryobtainable3 == u.unobtainable6) || (u.veryobtainable3 == u.unobtainable7) || (u.veryobtainable3 == u.unobtainable8) || (u.veryobtainable3 == u.unobtainable9) || (u.veryobtainable3 == u.unobtainable10) || (objects[u.veryobtainable3].oc_prob < 1) ) u.veryobtainable3 = rn2(NUM_OBJECTS);
	u.veryobtainableboost3 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost3 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost3 += rnz(100);
	if (u.veryobtainableboost3 > 1000) u.veryobtainableboost3 = 1000; /* sanity check */

	u.veryobtainable4 = -1;
	while ( (u.veryobtainable4 == -1) || (u.veryobtainable4 == GOLD_PIECE) || (u.veryobtainable4 == STRANGE_OBJECT) || (u.veryobtainable4 == AMULET_OF_YENDOR) || (u.veryobtainable4 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable4 == BELL_OF_OPENING) || (u.veryobtainable4 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable4 == SCR_WISHING) || (u.veryobtainable4 == SCR_RESURRECTION) || (u.veryobtainable4 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable4 == SCR_WORLD_FALL) || (u.veryobtainable4 == SCR_ASTRALCENSION) || (u.veryobtainable4 == TREASURE_CHEST) || (u.veryobtainable4 == SCR_RAGNAROK) || (u.veryobtainable4 == SCR_ARTIFACT_CREATION) || (u.veryobtainable4 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable4 == WAN_WISHING) || (u.veryobtainable4 == u.unobtainable) || (u.veryobtainable4 == u.unobtainable2) || (u.veryobtainable4 == u.unobtainable3) || (u.veryobtainable4 == u.unobtainable4) || (u.veryobtainable4 == u.unobtainable5) || (u.veryobtainable4 == u.unobtainable6) || (u.veryobtainable4 == u.unobtainable7) || (u.veryobtainable4 == u.unobtainable8) || (u.veryobtainable4 == u.unobtainable9) || (u.veryobtainable4 == u.unobtainable10) || (objects[u.veryobtainable4].oc_prob < 1) ) u.veryobtainable4 = rn2(NUM_OBJECTS);
	u.veryobtainableboost4 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost4 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost4 += rnz(100);
	if (u.veryobtainableboost4 > 1000) u.veryobtainableboost4 = 1000; /* sanity check */

	u.veryobtainable5 = -1;
	while ( (u.veryobtainable5 == -1) || (u.veryobtainable5 == GOLD_PIECE) || (u.veryobtainable5 == STRANGE_OBJECT) || (u.veryobtainable5 == AMULET_OF_YENDOR) || (u.veryobtainable5 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable5 == BELL_OF_OPENING) || (u.veryobtainable5 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable5 == SCR_WISHING) || (u.veryobtainable5 == SCR_RESURRECTION) || (u.veryobtainable5 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable5 == SCR_WORLD_FALL) || (u.veryobtainable5 == SCR_ASTRALCENSION) || (u.veryobtainable5 == TREASURE_CHEST) || (u.veryobtainable5 == SCR_RAGNAROK) || (u.veryobtainable5 == SCR_ARTIFACT_CREATION) || (u.veryobtainable5 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable5 == WAN_WISHING) || (u.veryobtainable5 == u.unobtainable) || (u.veryobtainable5 == u.unobtainable2) || (u.veryobtainable5 == u.unobtainable3) || (u.veryobtainable5 == u.unobtainable4) || (u.veryobtainable5 == u.unobtainable5) || (u.veryobtainable5 == u.unobtainable6) || (u.veryobtainable5 == u.unobtainable7) || (u.veryobtainable5 == u.unobtainable8) || (u.veryobtainable5 == u.unobtainable9) || (u.veryobtainable5 == u.unobtainable10) || (objects[u.veryobtainable5].oc_prob < 1) ) u.veryobtainable5 = rn2(NUM_OBJECTS);
	u.veryobtainableboost5 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost5 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost5 += rnz(100);
	if (u.veryobtainableboost5 > 1000) u.veryobtainableboost5 = 1000; /* sanity check */

	u.veryobtainable6 = -1;
	while ( (u.veryobtainable6 == -1) || (u.veryobtainable6 == GOLD_PIECE) || (u.veryobtainable6 == STRANGE_OBJECT) || (u.veryobtainable6 == AMULET_OF_YENDOR) || (u.veryobtainable6 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable6 == BELL_OF_OPENING) || (u.veryobtainable6 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable6 == SCR_WISHING) || (u.veryobtainable6 == SCR_RESURRECTION) || (u.veryobtainable6 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable6 == SCR_WORLD_FALL) || (u.veryobtainable6 == SCR_ASTRALCENSION) || (u.veryobtainable6 == TREASURE_CHEST) || (u.veryobtainable6 == SCR_RAGNAROK) || (u.veryobtainable6 == SCR_ARTIFACT_CREATION) || (u.veryobtainable6 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable6 == WAN_WISHING) || (u.veryobtainable6 == u.unobtainable) || (u.veryobtainable6 == u.unobtainable2) || (u.veryobtainable6 == u.unobtainable3) || (u.veryobtainable6 == u.unobtainable4) || (u.veryobtainable6 == u.unobtainable5) || (u.veryobtainable6 == u.unobtainable6) || (u.veryobtainable6 == u.unobtainable7) || (u.veryobtainable6 == u.unobtainable8) || (u.veryobtainable6 == u.unobtainable9) || (u.veryobtainable6 == u.unobtainable10) || (objects[u.veryobtainable6].oc_prob < 1) ) u.veryobtainable6 = rn2(NUM_OBJECTS);
	u.veryobtainableboost6 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost6 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost6 += rnz(100);
	if (u.veryobtainableboost6 > 1000) u.veryobtainableboost6 = 1000; /* sanity check */

	u.veryobtainable7 = -1;
	while ( (u.veryobtainable7 == -1) || (u.veryobtainable7 == GOLD_PIECE) || (u.veryobtainable7 == STRANGE_OBJECT) || (u.veryobtainable7 == AMULET_OF_YENDOR) || (u.veryobtainable7 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable7 == BELL_OF_OPENING) || (u.veryobtainable7 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable7 == SCR_WISHING) || (u.veryobtainable7 == SCR_RESURRECTION) || (u.veryobtainable7 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable7 == SCR_WORLD_FALL) || (u.veryobtainable7 == SCR_ASTRALCENSION) || (u.veryobtainable7 == TREASURE_CHEST) || (u.veryobtainable7 == SCR_RAGNAROK) || (u.veryobtainable7 == SCR_ARTIFACT_CREATION) || (u.veryobtainable7 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable7 == WAN_WISHING) || (u.veryobtainable7 == u.unobtainable) || (u.veryobtainable7 == u.unobtainable2) || (u.veryobtainable7 == u.unobtainable3) || (u.veryobtainable7 == u.unobtainable4) || (u.veryobtainable7 == u.unobtainable5) || (u.veryobtainable7 == u.unobtainable6) || (u.veryobtainable7 == u.unobtainable7) || (u.veryobtainable7 == u.unobtainable8) || (u.veryobtainable7 == u.unobtainable9) || (u.veryobtainable7 == u.unobtainable10) || (objects[u.veryobtainable7].oc_prob < 1) ) u.veryobtainable7 = rn2(NUM_OBJECTS);
	u.veryobtainableboost7 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost7 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost7 += rnz(100);
	if (u.veryobtainableboost7 > 1000) u.veryobtainableboost7 = 1000; /* sanity check */

	u.veryobtainable8 = -1;
	while ( (u.veryobtainable8 == -1) || (u.veryobtainable8 == GOLD_PIECE) || (u.veryobtainable8 == STRANGE_OBJECT) || (u.veryobtainable8 == AMULET_OF_YENDOR) || (u.veryobtainable8 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable8 == BELL_OF_OPENING) || (u.veryobtainable8 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable8 == SCR_WISHING) || (u.veryobtainable8 == SCR_RESURRECTION) || (u.veryobtainable8 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable8 == SCR_WORLD_FALL) || (u.veryobtainable8 == SCR_ASTRALCENSION) || (u.veryobtainable8 == TREASURE_CHEST) || (u.veryobtainable8 == SCR_RAGNAROK) || (u.veryobtainable8 == SCR_ARTIFACT_CREATION) || (u.veryobtainable8 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable8 == WAN_WISHING) || (u.veryobtainable8 == u.unobtainable) || (u.veryobtainable8 == u.unobtainable2) || (u.veryobtainable8 == u.unobtainable3) || (u.veryobtainable8 == u.unobtainable4) || (u.veryobtainable8 == u.unobtainable5) || (u.veryobtainable8 == u.unobtainable6) || (u.veryobtainable8 == u.unobtainable7) || (u.veryobtainable8 == u.unobtainable8) || (u.veryobtainable8 == u.unobtainable9) || (u.veryobtainable8 == u.unobtainable10) || (objects[u.veryobtainable8].oc_prob < 1) ) u.veryobtainable8 = rn2(NUM_OBJECTS);
	u.veryobtainableboost8 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost8 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost8 += rnz(100);
	if (u.veryobtainableboost8 > 1000) u.veryobtainableboost8 = 1000; /* sanity check */

	u.veryobtainable9 = -1;
	while ( (u.veryobtainable9 == -1) || (u.veryobtainable9 == GOLD_PIECE) || (u.veryobtainable9 == STRANGE_OBJECT) || (u.veryobtainable9 == AMULET_OF_YENDOR) || (u.veryobtainable9 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable9 == BELL_OF_OPENING) || (u.veryobtainable9 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable9 == SCR_WISHING) || (u.veryobtainable9 == SCR_RESURRECTION) || (u.veryobtainable9 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable9 == SCR_WORLD_FALL) || (u.veryobtainable9 == SCR_ASTRALCENSION) || (u.veryobtainable9 == TREASURE_CHEST) || (u.veryobtainable9 == SCR_RAGNAROK) || (u.veryobtainable9 == SCR_ARTIFACT_CREATION) || (u.veryobtainable9 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable9 == WAN_WISHING) || (u.veryobtainable9 == u.unobtainable) || (u.veryobtainable9 == u.unobtainable2) || (u.veryobtainable9 == u.unobtainable3) || (u.veryobtainable9 == u.unobtainable4) || (u.veryobtainable9 == u.unobtainable5) || (u.veryobtainable9 == u.unobtainable6) || (u.veryobtainable9 == u.unobtainable7) || (u.veryobtainable9 == u.unobtainable8) || (u.veryobtainable9 == u.unobtainable9) || (u.veryobtainable9 == u.unobtainable10) || (objects[u.veryobtainable9].oc_prob < 1) ) u.veryobtainable9 = rn2(NUM_OBJECTS);
	u.veryobtainableboost9 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost9 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost9 += rnz(100);
	if (u.veryobtainableboost9 > 1000) u.veryobtainableboost9 = 1000; /* sanity check */

	u.veryobtainable10 = -1;
	while ( (u.veryobtainable10 == -1) || (u.veryobtainable10 == GOLD_PIECE) || (u.veryobtainable10 == STRANGE_OBJECT) || (u.veryobtainable10 == AMULET_OF_YENDOR) || (u.veryobtainable10 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable10 == BELL_OF_OPENING) || (u.veryobtainable10 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable10 == SCR_WISHING) || (u.veryobtainable10 == SCR_RESURRECTION) || (u.veryobtainable10 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable10 == SCR_WORLD_FALL) || (u.veryobtainable10 == SCR_ASTRALCENSION) || (u.veryobtainable10 == TREASURE_CHEST) || (u.veryobtainable10 == SCR_RAGNAROK) || (u.veryobtainable10 == SCR_ARTIFACT_CREATION) || (u.veryobtainable10 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable10 == WAN_WISHING) || (u.veryobtainable10 == u.unobtainable) || (u.veryobtainable10 == u.unobtainable2) || (u.veryobtainable10 == u.unobtainable3) || (u.veryobtainable10 == u.unobtainable4) || (u.veryobtainable10 == u.unobtainable5) || (u.veryobtainable10 == u.unobtainable6) || (u.veryobtainable10 == u.unobtainable7) || (u.veryobtainable10 == u.unobtainable8) || (u.veryobtainable10 == u.unobtainable9) || (u.veryobtainable10 == u.unobtainable10) || (objects[u.veryobtainable10].oc_prob < 1) ) u.veryobtainable10 = rn2(NUM_OBJECTS);
	u.veryobtainableboost10 = (1 + rnz(10));
	if (!rn2(5)) u.veryobtainableboost10 += rnz(10);
	if (!rn2(25)) u.veryobtainableboost10 += rnz(100);
	if (u.veryobtainableboost10 > 1000) u.veryobtainableboost10 = 1000; /* sanity check */

	u.veryobtainable11 = -1;
	while ( (u.veryobtainable11 == -1) || (u.veryobtainable11 == GOLD_PIECE) || (u.veryobtainable11 == STRANGE_OBJECT) || (u.veryobtainable11 == AMULET_OF_YENDOR) || (u.veryobtainable11 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable11 == BELL_OF_OPENING) || (u.veryobtainable11 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable11 == SCR_WISHING) || (u.veryobtainable11 == SCR_RESURRECTION) || (u.veryobtainable11 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable11 == SCR_WORLD_FALL) || (u.veryobtainable11 == SCR_ASTRALCENSION) || (u.veryobtainable11 == TREASURE_CHEST) || (u.veryobtainable11 == SCR_RAGNAROK) || (u.veryobtainable11 == SCR_ARTIFACT_CREATION) || (u.veryobtainable11 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable11 == WAN_WISHING) || (u.veryobtainable11 == u.unobtainable) || (u.veryobtainable11 == u.unobtainable2) || (u.veryobtainable11 == u.unobtainable3) || (u.veryobtainable11 == u.unobtainable4) || (u.veryobtainable11 == u.unobtainable5) || (u.veryobtainable11 == u.unobtainable6) || (u.veryobtainable11 == u.unobtainable7) || (u.veryobtainable11 == u.unobtainable8) || (u.veryobtainable11 == u.unobtainable9) || (u.veryobtainable11 == u.unobtainable10) || (objects[u.veryobtainable11].oc_prob < 1) ) u.veryobtainable11 = rn2(NUM_OBJECTS);
	u.veryobtainableboost11 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost11 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost11 += rnd(100);
	if (u.veryobtainableboost11 > 1000) u.veryobtainableboost11 = 1000; /* sanity check */

	u.veryobtainable12 = -1;
	while ( (u.veryobtainable12 == -1) || (u.veryobtainable12 == GOLD_PIECE) || (u.veryobtainable12 == STRANGE_OBJECT) || (u.veryobtainable12 == AMULET_OF_YENDOR) || (u.veryobtainable12 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable12 == BELL_OF_OPENING) || (u.veryobtainable12 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable12 == SCR_WISHING) || (u.veryobtainable12 == SCR_RESURRECTION) || (u.veryobtainable12 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable12 == SCR_WORLD_FALL) || (u.veryobtainable12 == SCR_ASTRALCENSION) || (u.veryobtainable12 == TREASURE_CHEST) || (u.veryobtainable12 == SCR_RAGNAROK) || (u.veryobtainable12 == SCR_ARTIFACT_CREATION) || (u.veryobtainable12 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable12 == WAN_WISHING) || (u.veryobtainable12 == u.unobtainable) || (u.veryobtainable12 == u.unobtainable2) || (u.veryobtainable12 == u.unobtainable3) || (u.veryobtainable12 == u.unobtainable4) || (u.veryobtainable12 == u.unobtainable5) || (u.veryobtainable12 == u.unobtainable6) || (u.veryobtainable12 == u.unobtainable7) || (u.veryobtainable12 == u.unobtainable8) || (u.veryobtainable12 == u.unobtainable9) || (u.veryobtainable12 == u.unobtainable10) || (objects[u.veryobtainable12].oc_prob < 1) ) u.veryobtainable12 = rn2(NUM_OBJECTS);
	u.veryobtainableboost12 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost12 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost12 += rnd(100);
	if (u.veryobtainableboost12 > 1000) u.veryobtainableboost12 = 1000; /* sanity check */

	u.veryobtainable13 = -1;
	while ( (u.veryobtainable13 == -1) || (u.veryobtainable13 == GOLD_PIECE) || (u.veryobtainable13 == STRANGE_OBJECT) || (u.veryobtainable13 == AMULET_OF_YENDOR) || (u.veryobtainable13 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable13 == BELL_OF_OPENING) || (u.veryobtainable13 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable13 == SCR_WISHING) || (u.veryobtainable13 == SCR_RESURRECTION) || (u.veryobtainable13 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable13 == SCR_WORLD_FALL) || (u.veryobtainable13 == SCR_ASTRALCENSION) || (u.veryobtainable13 == TREASURE_CHEST) || (u.veryobtainable13 == SCR_RAGNAROK) || (u.veryobtainable13 == SCR_ARTIFACT_CREATION) || (u.veryobtainable13 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable13 == WAN_WISHING) || (u.veryobtainable13 == u.unobtainable) || (u.veryobtainable13 == u.unobtainable2) || (u.veryobtainable13 == u.unobtainable3) || (u.veryobtainable13 == u.unobtainable4) || (u.veryobtainable13 == u.unobtainable5) || (u.veryobtainable13 == u.unobtainable6) || (u.veryobtainable13 == u.unobtainable7) || (u.veryobtainable13 == u.unobtainable8) || (u.veryobtainable13 == u.unobtainable9) || (u.veryobtainable13 == u.unobtainable10) || (objects[u.veryobtainable13].oc_prob < 1) ) u.veryobtainable13 = rn2(NUM_OBJECTS);
	u.veryobtainableboost13 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost13 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost13 += rnd(100);
	if (u.veryobtainableboost13 > 1000) u.veryobtainableboost13 = 1000; /* sanity check */

	u.veryobtainable14 = -1;
	while ( (u.veryobtainable14 == -1) || (u.veryobtainable14 == GOLD_PIECE) || (u.veryobtainable14 == STRANGE_OBJECT) || (u.veryobtainable14 == AMULET_OF_YENDOR) || (u.veryobtainable14 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable14 == BELL_OF_OPENING) || (u.veryobtainable14 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable14 == SCR_WISHING) || (u.veryobtainable14 == SCR_RESURRECTION) || (u.veryobtainable14 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable14 == SCR_WORLD_FALL) || (u.veryobtainable14 == SCR_ASTRALCENSION) || (u.veryobtainable14 == TREASURE_CHEST) || (u.veryobtainable14 == SCR_RAGNAROK) || (u.veryobtainable14 == SCR_ARTIFACT_CREATION) || (u.veryobtainable14 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable14 == WAN_WISHING) || (u.veryobtainable14 == u.unobtainable) || (u.veryobtainable14 == u.unobtainable2) || (u.veryobtainable14 == u.unobtainable3) || (u.veryobtainable14 == u.unobtainable4) || (u.veryobtainable14 == u.unobtainable5) || (u.veryobtainable14 == u.unobtainable6) || (u.veryobtainable14 == u.unobtainable7) || (u.veryobtainable14 == u.unobtainable8) || (u.veryobtainable14 == u.unobtainable9) || (u.veryobtainable14 == u.unobtainable10) || (objects[u.veryobtainable14].oc_prob < 1) ) u.veryobtainable14 = rn2(NUM_OBJECTS);
	u.veryobtainableboost14 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost14 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost14 += rnd(100);
	if (u.veryobtainableboost14 > 1000) u.veryobtainableboost14 = 1000; /* sanity check */

	u.veryobtainable15 = -1;
	while ( (u.veryobtainable15 == -1) || (u.veryobtainable15 == GOLD_PIECE) || (u.veryobtainable15 == STRANGE_OBJECT) || (u.veryobtainable15 == AMULET_OF_YENDOR) || (u.veryobtainable15 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable15 == BELL_OF_OPENING) || (u.veryobtainable15 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable15 == SCR_WISHING) || (u.veryobtainable15 == SCR_RESURRECTION) || (u.veryobtainable15 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable15 == SCR_WORLD_FALL) || (u.veryobtainable15 == SCR_ASTRALCENSION) || (u.veryobtainable15 == TREASURE_CHEST) || (u.veryobtainable15 == SCR_RAGNAROK) || (u.veryobtainable15 == SCR_ARTIFACT_CREATION) || (u.veryobtainable15 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable15 == WAN_WISHING) || (u.veryobtainable15 == u.unobtainable) || (u.veryobtainable15 == u.unobtainable2) || (u.veryobtainable15 == u.unobtainable3) || (u.veryobtainable15 == u.unobtainable4) || (u.veryobtainable15 == u.unobtainable5) || (u.veryobtainable15 == u.unobtainable6) || (u.veryobtainable15 == u.unobtainable7) || (u.veryobtainable15 == u.unobtainable8) || (u.veryobtainable15 == u.unobtainable9) || (u.veryobtainable15 == u.unobtainable10) || (objects[u.veryobtainable15].oc_prob < 1) ) u.veryobtainable15 = rn2(NUM_OBJECTS);
	u.veryobtainableboost15 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost15 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost15 += rnd(100);
	if (u.veryobtainableboost15 > 1000) u.veryobtainableboost15 = 1000; /* sanity check */

	u.veryobtainable16 = -1;
	while ( (u.veryobtainable16 == -1) || (u.veryobtainable16 == GOLD_PIECE) || (u.veryobtainable16 == STRANGE_OBJECT) || (u.veryobtainable16 == AMULET_OF_YENDOR) || (u.veryobtainable16 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable16 == BELL_OF_OPENING) || (u.veryobtainable16 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable16 == SCR_WISHING) || (u.veryobtainable16 == SCR_RESURRECTION) || (u.veryobtainable16 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable16 == SCR_WORLD_FALL) || (u.veryobtainable16 == SCR_ASTRALCENSION) || (u.veryobtainable16 == TREASURE_CHEST) || (u.veryobtainable16 == SCR_RAGNAROK) || (u.veryobtainable16 == SCR_ARTIFACT_CREATION) || (u.veryobtainable16 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable16 == WAN_WISHING) || (u.veryobtainable16 == u.unobtainable) || (u.veryobtainable16 == u.unobtainable2) || (u.veryobtainable16 == u.unobtainable3) || (u.veryobtainable16 == u.unobtainable4) || (u.veryobtainable16 == u.unobtainable5) || (u.veryobtainable16 == u.unobtainable6) || (u.veryobtainable16 == u.unobtainable7) || (u.veryobtainable16 == u.unobtainable8) || (u.veryobtainable16 == u.unobtainable9) || (u.veryobtainable16 == u.unobtainable10) || (objects[u.veryobtainable16].oc_prob < 1) ) u.veryobtainable16 = rn2(NUM_OBJECTS);
	u.veryobtainableboost16 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost16 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost16 += rnd(100);
	if (u.veryobtainableboost16 > 1000) u.veryobtainableboost16 = 1000; /* sanity check */

	u.veryobtainable17 = -1;
	while ( (u.veryobtainable17 == -1) || (u.veryobtainable17 == GOLD_PIECE) || (u.veryobtainable17 == STRANGE_OBJECT) || (u.veryobtainable17 == AMULET_OF_YENDOR) || (u.veryobtainable17 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable17 == BELL_OF_OPENING) || (u.veryobtainable17 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable17 == SCR_WISHING) || (u.veryobtainable17 == SCR_RESURRECTION) || (u.veryobtainable17 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable17 == SCR_WORLD_FALL) || (u.veryobtainable17 == SCR_ASTRALCENSION) || (u.veryobtainable17 == TREASURE_CHEST) || (u.veryobtainable17 == SCR_RAGNAROK) || (u.veryobtainable17 == SCR_ARTIFACT_CREATION) || (u.veryobtainable17 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable17 == WAN_WISHING) || (u.veryobtainable17 == u.unobtainable) || (u.veryobtainable17 == u.unobtainable2) || (u.veryobtainable17 == u.unobtainable3) || (u.veryobtainable17 == u.unobtainable4) || (u.veryobtainable17 == u.unobtainable5) || (u.veryobtainable17 == u.unobtainable6) || (u.veryobtainable17 == u.unobtainable7) || (u.veryobtainable17 == u.unobtainable8) || (u.veryobtainable17 == u.unobtainable9) || (u.veryobtainable17 == u.unobtainable10) || (objects[u.veryobtainable17].oc_prob < 1) ) u.veryobtainable17 = rn2(NUM_OBJECTS);
	u.veryobtainableboost17 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost17 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost17 += rnd(100);
	if (u.veryobtainableboost17 > 1000) u.veryobtainableboost17 = 1000; /* sanity check */

	u.veryobtainable18 = -1;
	while ( (u.veryobtainable18 == -1) || (u.veryobtainable18 == GOLD_PIECE) || (u.veryobtainable18 == STRANGE_OBJECT) || (u.veryobtainable18 == AMULET_OF_YENDOR) || (u.veryobtainable18 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable18 == BELL_OF_OPENING) || (u.veryobtainable18 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable18 == SCR_WISHING) || (u.veryobtainable18 == SCR_RESURRECTION) || (u.veryobtainable18 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable18 == SCR_WORLD_FALL) || (u.veryobtainable18 == SCR_ASTRALCENSION) || (u.veryobtainable18 == TREASURE_CHEST) || (u.veryobtainable18 == SCR_RAGNAROK) || (u.veryobtainable18 == SCR_ARTIFACT_CREATION) || (u.veryobtainable18 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable18 == WAN_WISHING) || (u.veryobtainable18 == u.unobtainable) || (u.veryobtainable18 == u.unobtainable2) || (u.veryobtainable18 == u.unobtainable3) || (u.veryobtainable18 == u.unobtainable4) || (u.veryobtainable18 == u.unobtainable5) || (u.veryobtainable18 == u.unobtainable6) || (u.veryobtainable18 == u.unobtainable7) || (u.veryobtainable18 == u.unobtainable8) || (u.veryobtainable18 == u.unobtainable9) || (u.veryobtainable18 == u.unobtainable10) || (objects[u.veryobtainable18].oc_prob < 1) ) u.veryobtainable18 = rn2(NUM_OBJECTS);
	u.veryobtainableboost18 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost18 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost18 += rnd(100);
	if (u.veryobtainableboost18 > 1000) u.veryobtainableboost18 = 1000; /* sanity check */

	u.veryobtainable19 = -1;
	while ( (u.veryobtainable19 == -1) || (u.veryobtainable19 == GOLD_PIECE) || (u.veryobtainable19 == STRANGE_OBJECT) || (u.veryobtainable19 == AMULET_OF_YENDOR) || (u.veryobtainable19 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable19 == BELL_OF_OPENING) || (u.veryobtainable19 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable19 == SCR_WISHING) || (u.veryobtainable19 == SCR_RESURRECTION) || (u.veryobtainable19 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable19 == SCR_WORLD_FALL) || (u.veryobtainable19 == SCR_ASTRALCENSION) || (u.veryobtainable19 == TREASURE_CHEST) || (u.veryobtainable19 == SCR_RAGNAROK) || (u.veryobtainable19 == SCR_ARTIFACT_CREATION) || (u.veryobtainable19 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable19 == WAN_WISHING) || (u.veryobtainable19 == u.unobtainable) || (u.veryobtainable19 == u.unobtainable2) || (u.veryobtainable19 == u.unobtainable3) || (u.veryobtainable19 == u.unobtainable4) || (u.veryobtainable19 == u.unobtainable5) || (u.veryobtainable19 == u.unobtainable6) || (u.veryobtainable19 == u.unobtainable7) || (u.veryobtainable19 == u.unobtainable8) || (u.veryobtainable19 == u.unobtainable9) || (u.veryobtainable19 == u.unobtainable10) || (objects[u.veryobtainable19].oc_prob < 1) ) u.veryobtainable19 = rn2(NUM_OBJECTS);
	u.veryobtainableboost19 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost19 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost19 += rnd(100);
	if (u.veryobtainableboost19 > 1000) u.veryobtainableboost19 = 1000; /* sanity check */

	u.veryobtainable20 = -1;
	while ( (u.veryobtainable20 == -1) || (u.veryobtainable20 == GOLD_PIECE) || (u.veryobtainable20 == STRANGE_OBJECT) || (u.veryobtainable20 == AMULET_OF_YENDOR) || (u.veryobtainable20 == CANDELABRUM_OF_INVOCATION) || (u.veryobtainable20 == BELL_OF_OPENING) || (u.veryobtainable20 == SPE_BOOK_OF_THE_DEAD) || (u.veryobtainable20 == SCR_WISHING) || (u.veryobtainable20 == SCR_RESURRECTION) || (u.veryobtainable20 == SCR_EXTRA_SKILL_POINT) || (u.veryobtainable20 == SCR_WORLD_FALL) || (u.veryobtainable20 == SCR_ASTRALCENSION) || (u.veryobtainable20 == TREASURE_CHEST) || (u.veryobtainable20 == SCR_RAGNAROK) || (u.veryobtainable20 == SCR_ARTIFACT_CREATION) || (u.veryobtainable20 == SCR_ARTIFACT_JACKPOT) || (u.veryobtainable20 == WAN_WISHING) || (u.veryobtainable20 == u.unobtainable) || (u.veryobtainable20 == u.unobtainable2) || (u.veryobtainable20 == u.unobtainable3) || (u.veryobtainable20 == u.unobtainable4) || (u.veryobtainable20 == u.unobtainable5) || (u.veryobtainable20 == u.unobtainable6) || (u.veryobtainable20 == u.unobtainable7) || (u.veryobtainable20 == u.unobtainable8) || (u.veryobtainable20 == u.unobtainable9) || (u.veryobtainable20 == u.unobtainable10) || (objects[u.veryobtainable20].oc_prob < 1) ) u.veryobtainable20 = rn2(NUM_OBJECTS);
	u.veryobtainableboost20 = (1 + rnd(10));
	if (!rn2(5)) u.veryobtainableboost20 += rnd(10);
	if (!rn2(25)) u.veryobtainableboost20 += rnd(100);
	if (u.veryobtainableboost20 > 1000) u.veryobtainableboost20 = 1000; /* sanity check */

	u.veryobtainclass1 = -1;
	if (!rn2(2)) {
		if (!rn2(1000)) u.veryobtainclass1 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass1 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass1 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass1 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass1 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass1 = RING_CLASS; break;
			case 4: u.veryobtainclass1 = AMULET_CLASS; break;
			case 5: u.veryobtainclass1 = WAND_CLASS; break;
			case 6: u.veryobtainclass1 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass1 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass1 = POTION_CLASS; break;
			case 9: u.veryobtainclass1 = TOOL_CLASS; break;
			case 10: u.veryobtainclass1 = FOOD_CLASS; break;
			case 11: u.veryobtainclass1 = GEM_CLASS; break;
		}
		u.veryobtainclass1boost = rnd(100);
	}

	u.veryobtainclass2 = -1;
	if (!rn2(5)) {
		if (!rn2(1000)) u.veryobtainclass2 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass2 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass2 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass2 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass2 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass2 = RING_CLASS; break;
			case 4: u.veryobtainclass2 = AMULET_CLASS; break;
			case 5: u.veryobtainclass2 = WAND_CLASS; break;
			case 6: u.veryobtainclass2 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass2 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass2 = POTION_CLASS; break;
			case 9: u.veryobtainclass2 = TOOL_CLASS; break;
			case 10: u.veryobtainclass2 = FOOD_CLASS; break;
			case 11: u.veryobtainclass2 = GEM_CLASS; break;
		}
		u.veryobtainclass2boost = rnd(100);
	}

	u.veryobtainclass3 = -1;
	if (!rn2(10)) {
		if (!rn2(1000)) u.veryobtainclass3 = BALL_CLASS;
		else if (!rn2(2000)) u.veryobtainclass3 = CHAIN_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = VENOM_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = ROCK_CLASS;
		else if (!rn2(1000)) u.veryobtainclass3 = IMPLANT_CLASS;
		else switch (rnd(11)) {
			case 1: u.veryobtainclass3 = WEAPON_CLASS; break;
			case 2: u.veryobtainclass3 = ARMOR_CLASS; break;
			case 3: u.veryobtainclass3 = RING_CLASS; break;
			case 4: u.veryobtainclass3 = AMULET_CLASS; break;
			case 5: u.veryobtainclass3 = WAND_CLASS; break;
			case 6: u.veryobtainclass3 = SPBOOK_CLASS; break;
			case 7: u.veryobtainclass3 = SCROLL_CLASS; break;
			case 8: u.veryobtainclass3 = POTION_CLASS; break;
			case 9: u.veryobtainclass3 = TOOL_CLASS; break;
			case 10: u.veryobtainclass3 = FOOD_CLASS; break;
			case 11: u.veryobtainclass3 = GEM_CLASS; break;
		}
		u.veryobtainclass3boost = rnd(100);
	}

	u.spellbookbias1 = -1;
	u.spellbookbias2 = -1;
	u.spellbookbias3 = -1;

	if (!rn2(5)) {
		u.spellbookbias1 = P_FIRST_SPELL + rn2(10);
		u.spellbookchance1 = rnd(20);
		if (!rn2(4)) {
			u.spellbookbias2 = P_FIRST_SPELL + rn2(10);
			u.spellbookchance2 = rnd(20);
			if (!rn2(5)) {
				u.spellbookbias3 = P_FIRST_SPELL + rn2(10);
				u.spellbookchance3 = rnd(20);
			}
		}
	}

	u.invisotrap = rnd(TRAPNUM-1);

	u.frequenttrap = rnd(TRAPNUM-1);
	while (u.frequenttrap == MAGIC_PORTAL || u.frequenttrap == ACTIVE_SUPERSCROLLER_TRAP || u.frequenttrap == WISHING_TRAP || u.frequenttrap == PENTAGRAM_TRAP || u.frequenttrap == THRONE_TRAP || u.frequenttrap == S_PRESSING_TRAP || u.frequenttrap == DATA_DELETE_TRAP || u.frequenttrap == ELDER_TENTACLING_TRAP || u.frequenttrap == ARTIFACT_JACKPOT_TRAP || u.frequenttrap == GOOD_ARTIFACT_TRAP || u.frequenttrap == BOON_TRAP) u.frequenttrap = rnd(TRAPNUM-1);
	u.freqtrapbonus = rnz(2) * rne(2);
	if (!rn2(5)) u.freqtrapbonus = rnz(3) * rne(3);

	u.traprandomizing = rnd(1000);

	u.trapxtradiff = 0;
	if (!rn2(10)) {
		if (rn2(5)) u.trapxtradiff = rno(20);
		else if (rn2(3)) u.trapxtradiff = rno(50);
		else u.trapxtradiff = rno(100);
	}

	u.invistrapchance = 80 + rn2(21);
	if (!rn2(5)) u.invistrapchance = 20 + rn2(81);
	u.xdifftrapchance = rno(15);
	if (!rn2(5)) u.xdifftrapchance = rno(50);
	if (!rn2(25)) u.xdifftrapchance = rno(100);
	if (u.xdifftrapchance < 1) u.xdifftrapchance = 1;
	if (u.xdifftrapchance > 100) u.xdifftrapchance = 100;

	u.impossibleproperty = -1;
	u.nonextrinsicproperty = -1;
	u.nonintrinsicproperty = -1;
	u.nondoubleproperty = -1;

	if (!rn2(2)) u.impossibleproperty = randomdisableproperty();
	if (!rn2(2)) u.nonextrinsicproperty = randomdisableproperty();
	if (!rn2(2)) u.nonintrinsicproperty = randomdisableproperty();
	if (!rn2(2)) u.nondoubleproperty = randomdisableproperty();

	u.idscrollpenalty = rnd(200); /* if rnd(this) is greater than 100, the scroll isn't ided */
	if (!rn2(7)) u.idscrollpenalty += rnz(100);
	if (!rn2(50)) u.idscrollpenalty += rnz(200);
	u.idpotionpenalty = rnd(10); /* if rnd(this) is greater than 3, the potion isn't ided */
	if (!rn2(7)) u.idpotionpenalty += rnz(5);
	if (!rn2(50)) u.idpotionpenalty += rnz(10);
	u.idringpenalty = rnd(20); /* if rnd(this) is greater than 4, the ring isn't ided */
	if (!rn2(7)) u.idringpenalty += rnz(10);
	if (!rn2(50)) u.idringpenalty += rnz(20);
	u.idamuletpenalty = rnd(20); /* if rnd(this) is greater than 15, the amulet isn't ided */
	if (!rn2(7)) u.idamuletpenalty += rnz(10);
	if (!rn2(50)) u.idamuletpenalty += rnz(20);
	u.idimplantpenalty = rnd(50); /* if rnd(this) is greater than 1, the implant isn't ided */
	if (!rn2(7)) u.idimplantpenalty += rnz(25);
	if (!rn2(50)) u.idimplantpenalty += rnz(50);
	u.idwandpenalty = rnd(12); /* if rnd(this) is greater than 3, the wand isn't ided */
	if (!rn2(7)) u.idwandpenalty += rnz(6);
	if (!rn2(50)) u.idwandpenalty += rnz(12);
	u.idarmorpenalty = rnd(30); /* if rnd(this) is greater than 15, the armor isn't ided */
	if (!rn2(7)) u.idarmorpenalty += rnz(15);
	if (!rn2(50)) u.idarmorpenalty += rnz(30);
	u.idspellbookpenalty = rnd(16); /* if rnd(this) is greater than 2, the spellbook isn't ided */
	if (!rn2(7)) u.idspellbookpenalty += rnz(8);
	if (!rn2(50)) u.idspellbookpenalty += rnz(16);
	u.idgempenalty = rnd(200); /* if rnd(this) is greater than 100, the gem isn't ided */
	if (!rn2(7)) u.idgempenalty += rnz(100);
	if (!rn2(50)) u.idgempenalty += rnz(200);
	u.idtoolpenalty = rnd(12); /* if rnd(this) is greater than 5, the tool isn't ided */
	if (!rn2(7)) u.idtoolpenalty += rnz(6);
	if (!rn2(50)) u.idtoolpenalty += rnz(12);

	u.musableremovechance = 0;
	if (!rn2(3)) u.musableremovechance += rnd(20);
	if (!rn2(5)) u.musableremovechance += rnd(20);
	if (!rn2(25)) u.musableremovechance += rnd(25);
	if (!rn2(125)) u.musableremovechance += rnd(25);
	if (!rn2(125)) u.musableremovechance += rnd(100);
	if (u.musableremovechance > 90) u.musableremovechance = 90;
	if (u.musableremovechance < 0) u.musableremovechance = 0;

	u.equipmentremovechance = 0;
	if (!rn2(3)) u.equipmentremovechance += rnd(10);
	if (!rn2(6)) u.equipmentremovechance += rnd(20);
	if (!rn2(15)) u.equipmentremovechance += rnd(20);
	if (!rn2(120)) u.equipmentremovechance += rnd(20);
	if (!rn2(120)) u.equipmentremovechance += rnd(100);
	if (u.equipmentremovechance > 90) u.equipmentremovechance = 90;
	if (u.equipmentremovechance < 0) u.equipmentremovechance = 0;

	u.bookspawnchance = 0;
	if (!rn2(20)) u.bookspawnchance += rnd(10);
	if (!rn2(200)) u.bookspawnchance += rnd(20);
	if (!rn2(2000)) u.bookspawnchance += rnd(50);
	if (!rn2(20000)) u.bookspawnchance += rnd(70);
	if (!rn2(20000)) u.bookspawnchance += rnd(100);
	if (u.bookspawnchance > 90) u.bookspawnchance = 90;
	if (u.bookspawnchance < 0) u.bookspawnchance = 0;

	u.ringspawnchance = 0;
	if (!rn2(3)) u.ringspawnchance += rnd(15);
	if (!rn2(6)) u.ringspawnchance += rnd(30);
	if (!rn2(30)) u.ringspawnchance += rnd(50);
	if (!rn2(30)) u.ringspawnchance += rnd(100);
	if (u.ringspawnchance > 90) u.ringspawnchance = 90;
	if (u.ringspawnchance < 0) u.ringspawnchance = 0;

	u.amuletspawnchance = 0;
	if (!rn2(3)) u.amuletspawnchance += rnd(20);
	if (!rn2(6)) u.amuletspawnchance += rnd(20);
	if (!rn2(15)) u.amuletspawnchance += rnd(25);
	if (!rn2(60)) u.amuletspawnchance += rnd(25);
	if (!rn2(60)) u.amuletspawnchance += rnd(100);
	if (u.amuletspawnchance > 90) u.amuletspawnchance = 90;
	if (u.amuletspawnchance < 0) u.amuletspawnchance = 0;

	u.implantspawnchance = 0;
	if (!rn2(10)) u.implantspawnchance += rnd(10);
	if (!rn2(25)) u.implantspawnchance += rnd(15);
	if (!rn2(200)) u.implantspawnchance += rnd(25);
	if (!rn2(2000)) u.implantspawnchance += rnd(40);
	if (!rn2(2000)) u.implantspawnchance += rnd(100);
	if (u.implantspawnchance > 90) u.implantspawnchance = 90;
	if (u.implantspawnchance < 0) u.implantspawnchance = 0;

	u.weaponspawnchance = 0;
	if (!rn2(3)) u.weaponspawnchance += rnd(10);
	if (!rn2(6)) u.weaponspawnchance += rnd(15);
	if (!rn2(15)) u.weaponspawnchance += rnd(15);
	if (!rn2(60)) u.weaponspawnchance += rnd(20);
	if (!rn2(250)) u.weaponspawnchance += rnd(30);
	if (!rn2(250)) u.weaponspawnchance += rnd(100);
	if (u.weaponspawnchance > 90) u.weaponspawnchance = 90;
	if (u.weaponspawnchance < 0) u.weaponspawnchance = 0;

	u.armorspawnchance = 0;
	if (!rn2(3)) u.armorspawnchance += rnd(15);
	if (!rn2(6)) u.armorspawnchance += rnd(15);
	if (!rn2(12)) u.armorspawnchance += rnd(15);
	if (!rn2(40)) u.armorspawnchance += rnd(15);
	if (!rn2(120)) u.armorspawnchance += rnd(30);
	if (!rn2(120)) u.armorspawnchance += rnd(100);
	if (u.armorspawnchance > 90) u.armorspawnchance = 90;
	if (u.armorspawnchance < 0) u.armorspawnchance = 0;

	u.toolspawnchance = 0;
	if (!rn2(3)) u.toolspawnchance += rnd(10);
	if (!rn2(6)) u.toolspawnchance += rnd(10);
	if (!rn2(15)) u.toolspawnchance += rnd(20);
	if (!rn2(60)) u.toolspawnchance += rnd(20);
	if (!rn2(250)) u.toolspawnchance += rnd(30);
	if (!rn2(250)) u.toolspawnchance += rnd(100);
	if (u.toolspawnchance > 90) u.toolspawnchance = 90;
	if (u.toolspawnchance < 0) u.toolspawnchance = 0;

	u.foodspawnchance = 0;
	if (!rn2(2)) u.foodspawnchance += rnd(5);
	if (!rn2(4)) u.foodspawnchance += rnd(5);
	if (!rn2(8)) u.foodspawnchance += rnd(10);
	if (!rn2(25)) u.foodspawnchance += rnd(20);
	if (!rn2(100)) u.foodspawnchance += rnd(20);
	if (!rn2(500)) u.foodspawnchance += rnd(30);
	if (!rn2(500)) u.foodspawnchance += rnd(100);
	if (u.foodspawnchance > 90) u.foodspawnchance = 90;
	if (u.foodspawnchance < 0) u.foodspawnchance = 0;

	u.shopitemreduction = 0;
	if (rn2(5)) u.shopitemreduction += rnd(15);
	if (!rn2(3)) u.shopitemreduction += rnd(15);
	if (!rn2(6)) u.shopitemreduction += rnd(20);
	if (!rn2(25)) u.shopitemreduction += rnd(20);
	if (!rn2(125)) u.shopitemreduction += rnd(20);
	if (!rn2(125)) u.shopitemreduction += rnd(100);
	if (u.shopitemreduction > 90) u.shopitemreduction = 90;
	if (u.shopitemreduction < 0) u.shopitemreduction = 0;

	u.potionspawnchance = 0;
	if (!rn2(2)) u.potionspawnchance += rnd(10);
	if (!rn2(4)) u.potionspawnchance += rnd(10);
	if (!rn2(8)) u.potionspawnchance += rnd(15);
	if (!rn2(25)) u.potionspawnchance += rnd(15);
	if (!rn2(100)) u.potionspawnchance += rnd(20);
	if (!rn2(500)) u.potionspawnchance += rnd(20);
	if (!rn2(500)) u.potionspawnchance += rnd(100);
	if (u.potionspawnchance > 90) u.potionspawnchance = 90;
	if (u.potionspawnchance < 0) u.potionspawnchance = 0;

	u.scrollspawnchance = 0;
	if (!rn2(2)) u.scrollspawnchance += rnd(10);
	if (!rn2(4)) u.scrollspawnchance += rnd(10);
	if (!rn2(8)) u.scrollspawnchance += rnd(10);
	if (!rn2(16)) u.scrollspawnchance += rnd(10);
	if (!rn2(35)) u.scrollspawnchance += rnd(10);
	if (!rn2(90)) u.scrollspawnchance += rnd(10);
	if (!rn2(200)) u.scrollspawnchance += rnd(15);
	if (!rn2(900)) u.scrollspawnchance += rnd(15);
	if (!rn2(900)) u.scrollspawnchance += rnd(100);
	if (u.scrollspawnchance > 90) u.scrollspawnchance = 90;
	if (u.scrollspawnchance < 0) u.scrollspawnchance = 0;

	u.wandspawnchance = 0;
	if (!rn2(3)) u.wandspawnchance += rnd(10);
	if (!rn2(6)) u.wandspawnchance += rnd(15);
	if (!rn2(15)) u.wandspawnchance += rnd(15);
	if (!rn2(60)) u.wandspawnchance += rnd(15);
	if (!rn2(240)) u.wandspawnchance += rnd(15);
	if (!rn2(600)) u.wandspawnchance += rnd(20);
	if (!rn2(600)) u.wandspawnchance += rnd(100);
	if (u.wandspawnchance > 90) u.wandspawnchance = 90;
	if (u.wandspawnchance < 0) u.wandspawnchance = 0;

	u.antimusablebias = 0;
	if (!rn2(3)) u.antimusablebias = rno(100);

	u.concealitemchance = 0;
	if (!rn2(3)) u.concealitemchance += rnd(20);
	if (!rn2(5)) u.concealitemchance += rnd(20);
	if (!rn2(7)) u.concealitemchance += rnd(25);
	if (!rn2(9)) u.concealitemchance += rnd(25);
	if (!rn2(9)) u.concealitemchance += rnd(100);
	if (u.concealitemchance > 90) u.concealitemchance = 90;
	if (u.concealitemchance < 0) u.concealitemchance = 0;

	u.usefulitemchance = 0;
	if (!rn2(2)) u.usefulitemchance += rnd(10);
	if (!rn2(5)) u.usefulitemchance += rnd(10);
	if (!rn2(25)) u.usefulitemchance += rnd(10);
	if (!rn2(100)) u.usefulitemchance += rnd(15);
	if (!rn2(250)) u.usefulitemchance += rnd(15);
	if (!rn2(750)) u.usefulitemchance += rnd(15);
	if (!rn2(3250)) u.usefulitemchance += rnd(15);
	if (!rn2(3250)) u.usefulitemchance += rnd(100);
	if (u.usefulitemchance > 90) u.usefulitemchance = 90;
	if (u.usefulitemchance < 0) u.usefulitemchance = 0;

	u.eeveelution = PM_VAPOREON; /* failsafe */
	if (u.monstertimefinish % 42 == 0) u.eeveelution = PM_VOLAREON;
	else if (u.monstertimefinish % 23 == 0) u.eeveelution = PM_INSECTEON;
	else if (u.monstertimefinish % 15 == 0) u.eeveelution = PM_SYLVEON;
	else if (u.monstertimefinish % 13 == 0) u.eeveelution = PM_GLACEON;
	else if (u.monstertimefinish % 11 == 0) u.eeveelution = PM_LEAFEON;
	else if (u.monstertimefinish % 10 == 0) u.eeveelution = PM_UMBREON;
	else if (u.monstertimefinish % 9 == 0) u.eeveelution = PM_ESPEON;
	else if (u.monstertimefinish % 7 == 0) u.eeveelution = PM_JOLTEON;
	else if (u.monstertimefinish % 3 == 0) u.eeveelution = PM_FLAREON;
	else u.eeveelution = PM_VAPOREON;

	u.greencrosschance = rnd(20);

	u.untrainableskill = 0;
	u.halfspeedskill = 0;
	u.fifthspeedskill = 0;
	u.basiclimitskill = 0;
	u.skilledlimitskill = 0;
	u.expertlimitskill = 0;
	u.earlytrainingskill = 0;
	u.earlytrainingtimer = 9999999;
	u.frtrainingskill = 0;
	u.frtrainingtimer = 9999999;
	u.latetrainingskill = 0;
	u.latetrainingtimer = 9999999;
	u.lavtrainingskill = 0;
	u.lavtrainingtimer = 0;
	u.slowtrainingskill = 0;

	u.hiddenpowerskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();

	if (!rn2(2)) u.untrainableskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.halfspeedskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.fifthspeedskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.basiclimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.skilledlimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
	if (!rn2(2)) u.expertlimitskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();

	if (!rn2(2)) {
		u.earlytrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.earlytrainingtimer = rnz(50);
		u.earlytrainingtimer = rnd(u.earlytrainingtimer);
		u.earlytrainingtimer = rnz(u.earlytrainingtimer); /* calculations by jonadab */
	}
	/* don't reset the "blown" variable - if you screw up, it's your fault! --Amy */

	if (!rn2(3)) {
		u.frtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.frtrainingtimer = rnz(50);
		u.frtrainingtimer = rnd(u.frtrainingtimer);
		u.frtrainingtimer = rnz(u.frtrainingtimer);
		u.frtrainingtimer *= rnz(20);
	}

	if (!rn2(2)) {
		u.latetrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.latetrainingtimer = rnz(10000) + rnd(50000);
	}

	if (!rn2(2)) {
		u.lavtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();
		u.lavtrainingtimer = rnz(10000) + rnd(50000);
	}
	if (!rn2(2)) u.slowtrainingskill = !rn2(3) ? rnd(P_LIGHTSABER) : rn2(2) ? (P_ATTACK_SPELL + rn2(10)) : randomgoodcombatskill();

	u.stickycursechance = 0;
	if (!rn2(10)) {
		u.stickycursechance = rnd(10);
		if (!rn2(5)) u.stickycursechance += rnd(15);
		if (!rn2(25)) u.stickycursechance += rnd(15);
		if (!rn2(125)) u.stickycursechance += rnd(20);
		if (!rn2(625)) u.stickycursechance += rnd(20);
		if (!rn2(3225)) u.stickycursechance += rnd(20);
		if (u.stickycursechance > 100) u.stickycursechance = 100;
	}

	u.heavycursechance = 0;
	u.primecursechance = 0;
	if (!rn2(25)) {
		u.heavycursechance = rnd(25);
		if (!rn2(5)) u.heavycursechance += rnd(25);
		if (!rn2(15)) u.heavycursechance += rnd(25);
		if (!rn2(75)) u.heavycursechance += rnd(25);
		if (u.heavycursechance > 100) u.heavycursechance = 100;

		if (!rn2(100)) {
			u.primecursechance = rnd(10);
			if (!rn2(5)) u.primecursechance += rnd(15);
			if (!rn2(25)) u.primecursechance += rnd(15);
			if (!rn2(125)) u.primecursechance += rnd(20);
			if (!rn2(750)) u.primecursechance += rnd(20);
			if (!rn2(2500)) u.primecursechance += rnd(20);
			if (u.primecursechance > 100) u.primecursechance = 100;
		}
	}

	u.genericcursechance = 0;
	if (!rn2(10)) {
		u.genericcursechance = rnd(5);
		if (!rn2(5)) u.genericcursechance = rnd(15);
		if (!rn2(25)) u.genericcursechance = rnd(33);
	}

	u.pract_procrastinatetimer = rn1(500000, 500000);

	u.monstermultiplier = 100;
	if (rn2(3)) {
		if (rn2(2)) {
			while (rn2(6)) u.monstermultiplier--;
		} else {
			while (rn2(6)) u.monstermultiplier++;
		}
	}
	if (u.monstermultiplier < 10) u.monstermultiplier = 10; /* sanity check */
	if (u.monstermultiplier > 190) u.monstermultiplier = 190;

	reset_nastinator();

	if (isnastinator) { /* harder than hard race - starts with uncurable nasty trap effects --Amy */

		gain_nastinator();

		while ((rnd(7)) < 3) {

			gain_nastinator();

		}
	}

	if (iswindinhabitant) { /* similar to nastinator, but they will be re-initialized sometimes --Amy */

		gain_nastinator();

		while (!rn2(3)) {

			gain_nastinator();

		}
	}

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shambler->mmove = rn2(10)+9;				/* slow to very fast */
	shambler->ac = rn2(21)-10;				/* any AC */
	shambler->mr = rn2(5)*25;				/* varying amounts of MR */
	shambler->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shambler->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shambler->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shambler->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shambler->cnutrit = rnd(2000);					/* see above */
	shambler->msound = randmonsound();			/* any but the specials */
	shambler->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shambler->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shambler->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shambler->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shambler->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shambler->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shambler->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shambler->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shambler->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shambler->mflags2 |= (1 << rn2(31));
	}
	shambler->mflags2 &= ~M2_MERC;				/* no guards */
	shambler->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shambler->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shambler->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerp->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerp->ac = rn2(21)-10;				/* any AC */
	shamblerp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerp->cnutrit = rnd(2000);					/* see above */
	shamblerp->msound = randmonsound();			/* any but the specials */
	shamblerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerp->mflags2 |= (1 << rn2(31));
	}
	shamblerp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	pokshambler->mmove = rn2(10)+9;				/* slow to very fast */
	pokshambler->ac = rn2(21)-10;				/* any AC */
	pokshambler->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshambler->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshambler->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	pokshambler->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshambler->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshambler->cnutrit = rnd(2000);					/* see above */
	pokshambler->msound = randmonsound();			/* any but the specials */
	pokshambler->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshambler->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshambler->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshambler->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshambler->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshambler->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshambler->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshambler->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshambler->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshambler->mflags2 |= (1 << rn2(31));
	}
	pokshambler->mflags2 &= ~M2_MERC;				/* no guards */
	pokshambler->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshambler->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshambler->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	pokshamblerp->mmove = rn2(10)+9;				/* slow to very fast */
	pokshamblerp->ac = rn2(21)-10;				/* any AC */
	pokshamblerp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	pokshamblerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerp->cnutrit = rnd(2000);					/* see above */
	pokshamblerp->msound = randmonsound();			/* any but the specials */
	pokshamblerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerp->mflags2 |= (1 << rn2(31));
	}
	pokshamblerp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerp->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblera->mmove = rn2(10)+9;				/* slow to very fast */
	shamblera->ac = rn2(21)-10;				/* any AC */
	shamblera->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblera->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblera->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblera->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblera->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblera->cnutrit = rnd(2000);					/* see above */
	shamblera->msound = randmonsound();			/* any but the specials */
	shamblera->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblera->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblera->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblera->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblera->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblera->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblera->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblera->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblera->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblera->mflags2 |= (1 << rn2(31));
	}
	shamblera->mflags2 &= ~M2_MERC;				/* no guards */
	shamblera->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblera->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblera->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerap->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerap->ac = rn2(21)-10;				/* any AC */
	shamblerap->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerap->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerap->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerap->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerap->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerap->cnutrit = rnd(2000);					/* see above */
	shamblerap->msound = randmonsound();			/* any but the specials */
	shamblerap->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerap->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerap->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerap->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerap->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerap->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerap->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerap->mflags2 |= (1 << rn2(31));
	}
	shamblerap->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerap->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerap->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerap->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerb->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerb->ac = rn2(21)-10;				/* any AC */
	shamblerb->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerb->cnutrit = rnd(2000);					/* see above */
	shamblerb->msound = randmonsound();			/* any but the specials */
	shamblerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerb->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblerb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerb->mflags2 |= (1 << rn2(31));
	}
	shamblerb->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerbp->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerbp->ac = rn2(21)-10;				/* any AC */
	shamblerbp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerbp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerbp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	shamblerbp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerbp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerbp->cnutrit = rnd(2000);					/* see above */
	shamblerbp->msound = randmonsound();			/* any but the specials */
	shamblerbp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerbp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerbp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerbp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerbp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerb->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblerbp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerbp->mflags2 |= (1 << rn2(31));
	}
	shamblerbp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerbp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerbp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerbp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/*extra hard versions*/

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblers->mmove = rn2(18)+9;				/* slow to very fast */
	shamblers->ac = rn2(35)-24;				/* any AC */
	shamblers->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblers->cnutrit = rnd(2000);					/* see above */
	shamblers->msound = randmonsound();			/* any but the specials */
	shamblers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblers->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblers->mflags2 |= (1 << rn2(31));
	}
	shamblers->mflags2 &= ~M2_MERC;				/* no guards */
	shamblers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblers->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblersp->mmove = rn2(18)+9;				/* slow to very fast */
	shamblersp->ac = rn2(35)-24;				/* any AC */
	shamblersp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblersp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblersp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblersp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblersp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblersp->cnutrit = rnd(2000);					/* see above */
	shamblersp->msound = randmonsound();			/* any but the specials */
	shamblersp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblersp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblersp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblersp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblersp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblersp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblersp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblersp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblersp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblersp->mflags2 |= (1 << rn2(31));
	}
	shamblersp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblersp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblersp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblersp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblers->mmove = rn2(18)+9;				/* slow to very fast */
	pokshamblers->ac = rn2(35)-24;				/* any AC */
	pokshamblers->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &pokshamblers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	pokshamblers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblers->cnutrit = rnd(2000);					/* see above */
	pokshamblers->msound = randmonsound();			/* any but the specials */
	pokshamblers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblers->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblers->mflags2 |= (1 << rn2(31));
	}
	pokshamblers->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblers->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblersp->mmove = rn2(18)+9;				/* slow to very fast */
	pokshamblersp->ac = rn2(35)-24;				/* any AC */
	pokshamblersp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblersp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &pokshamblersp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	pokshamblersp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblersp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblersp->cnutrit = rnd(2000);					/* see above */
	pokshamblersp->msound = randmonsound();			/* any but the specials */
	pokshamblersp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblersp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblersp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblersp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblersp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblersp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblersp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblersp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblersp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblersp->mflags2 |= (1 << rn2(31));
	}
	pokshamblersp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblersp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblersp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblersp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblerxts->mmove = rn2(20)+9;				/* slow to very fast */
	pokshamblerxts->ac = rn2(40)-29;				/* any AC */
	pokshamblerxts->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxts->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &pokshamblerxts->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	pokshamblerxts->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxts->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxts->cnutrit = rnd(2000);					/* see above */
	pokshamblerxts->msound = randmonsound();			/* any but the specials */
	pokshamblerxts->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxts->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxts->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxts->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxts->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxts->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxts->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxts->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxts->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxts->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxts->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxts->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxts->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxts->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	pokshamblerxtsp->mmove = rn2(20)+9;				/* slow to very fast */
	pokshamblerxtsp->ac = rn2(40)-29;				/* any AC */
	pokshamblerxtsp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxtsp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &pokshamblerxtsp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	pokshamblerxtsp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxtsp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxtsp->cnutrit = rnd(2000);					/* see above */
	pokshamblerxtsp->msound = randmonsound();			/* any but the specials */
	pokshamblerxtsp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxtsp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxtsp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxtsp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxtsp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxtsp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxtsp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxtsp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxtsp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxtsp->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxtsp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxtsp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxtsp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxtsp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	shamblerz->ac = rn2(40)-29;				/* any AC */
	shamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	shamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerz->cnutrit = rnd(2000);					/* see above */
	shamblerz->msound = randmonsound();			/* any but the specials */
	shamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerz->mflags2 |= (1 << rn2(31));
	}
	shamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerza->mmove = rn2(20)+9;				/* slow to very fast */
	shamblerza->ac = rn2(40)-29;				/* any AC */
	shamblerza->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerza->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblerza->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	shamblerza->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerza->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerza->cnutrit = rnd(2000);					/* see above */
	shamblerza->msound = randmonsound();			/* any but the specials */
	shamblerza->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerza->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerza->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerza->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerza->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerza->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerza->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerza->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerza->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerza->mflags2 |= (1 << rn2(31));
	}
	shamblerza->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerza->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerza->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerza->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblernl->mmove = rn2(22)+9;				/* slow to very fast */
	shamblernl->ac = rn2(45)-29;				/* any AC */
	shamblernl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblernl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblernl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(26)+2;				/* either too high or too low */
	}
	shamblernl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblernl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblernl->cnutrit = rnd(2000);					/* see above */
	shamblernl->msound = randmonsound();			/* any but the specials */
	shamblernl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblernl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblernl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblernl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblernl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblernl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblernl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblernl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblernl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblernl->mflags2 |= (1 << rn2(31));
	}
	shamblernl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblernl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblernl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblernl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblernla->mmove = rn2(22)+9;				/* slow to very fast */
	shamblernla->ac = rn2(45)-29;				/* any AC */
	shamblernla->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblernla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &shamblernla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(26)+2;				/* either too high or too low */
	}
	shamblernla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblernla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblernla->cnutrit = rnd(2000);					/* see above */
	shamblernla->msound = randmonsound();			/* any but the specials */
	shamblernla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblernla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblernla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblernla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblernla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblernla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblernla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblernla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblernla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblernla->mflags2 |= (1 << rn2(31));
	}
	shamblernla->mflags2 &= ~M2_MERC;				/* no guards */
	shamblernla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblernla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblernla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	rshamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	rshamblerz->ac = rn2(40)-29;				/* any AC */
	rshamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &rshamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	rshamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerz->cnutrit = rnd(2000);					/* see above */
	rshamblerz->msound = randmonsound();			/* any but the specials */
	rshamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerz->mflags2 |= (1 << rn2(31));
	}
	rshamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerz, buf, sizeof(buf) );
	rshamblerz->mname = u.strshamblerz;

	/* second one */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	rshamblerza->mmove = rn2(20)+9;				/* slow to very fast */
	rshamblerza->ac = rn2(40)-29;				/* any AC */
	rshamblerza->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerza->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &rshamblerza->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	rshamblerza->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerza->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerza->cnutrit = rnd(2000);					/* see above */
	rshamblerza->msound = randmonsound();			/* any but the specials */
	rshamblerza->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerza->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerza->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerza->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerza->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerza->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerza->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerza->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerza->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerza->mflags2 |= (1 << rn2(31));
	}
	rshamblerza->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerza->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerza->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerza->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerza, buf, sizeof(buf) );
	rshamblerza->mname = u.strshamblerza;


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerr->mmove = rn2(18)+9;				/* slow to very fast */
	shamblerr->ac = rn2(35)-24;				/* any AC */
	shamblerr->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerr->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblerr->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblerr->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerr->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerr->cnutrit = rnd(2000);					/* see above */
	shamblerr->msound = randmonsound();			/* any but the specials */
	shamblerr->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerr->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerr->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerr->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerr->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerr->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerr->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerr->mflags2 |= (1 << rn2(31));
	}
	shamblerr->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerr->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerr->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerr->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* second one */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerrp->mmove = rn2(18)+9;				/* slow to very fast */
	shamblerrp->ac = rn2(35)-24;				/* any AC */
	shamblerrp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerrp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(6); i++) {
		attkptr = &shamblerrp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	shamblerrp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerrp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerrp->cnutrit = rnd(2000);					/* see above */
	shamblerrp->msound = randmonsound();			/* any but the specials */
	shamblerrp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerrp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerrp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerrp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerrp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerrp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerrp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerrp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerrp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerrp->mflags2 |= (1 << rn2(31));
	}
	shamblerrp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerrp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerrp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerrp->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblert->mmove = rn2(14)+9;				/* slow to very fast */
	shamblert->ac = rn2(31)-20;				/* any AC */
	shamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblert->cnutrit = rnd(2000);					/* see above */
	shamblert->msound = randmonsound();			/* any but the specials */
	shamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblert->mflags2 |= (1 << rn2(31));
	}
	shamblert->mflags2 &= ~M2_MERC;				/* no guards */
	shamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	randspoilerb->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerb->ac = rn2(18)-7;				/* any AC */
	randspoilerb->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	randspoilerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerb->cnutrit = rnd(2000);					/* see above */
	randspoilerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randspoilerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randspoilerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randspoilerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randspoilerb->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		randspoilerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*randspoilerb->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*randspoilerb->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	randspoilerb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randspoilerb->mflags2 |= (1 << rn2(31));
	}
	randspoilerb->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randspoilerb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	randspoilerc->mmove = rn2(14)+9;				/* slow to very fast */
	randspoilerc->ac = rn2(31)-20;				/* any AC */
	randspoilerc->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerc->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randspoilerc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	randspoilerc->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerc->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerc->cnutrit = rnd(2000);					/* see above */
	randspoilerc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randspoilerc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randspoilerc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randspoilerc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randspoilerc->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		randspoilerc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	randspoilerc->mflags1 &= ~M1_HIDE;				/* no hiding */

	randspoilerc->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randspoilerc->mflags2 |= (1 << rn2(31));
	}
	randspoilerc->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randspoilerc->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblery->mmove = rn2(14)+9;				/* slow to very fast */
	shamblery->ac = rn2(31)-20;				/* any AC */
	shamblery->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblery->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblery->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblery->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblery->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblery->cnutrit = rnd(2000);					/* see above */
	shamblery->msound = randmonsound();			/* any but the specials */
	shamblery->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblery->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblery->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblery->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblery->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblery->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblery->mflags1 &= ~M1_HIDE;				/* no hiding */

	shamblery->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblery->mflags2 |= (1 << rn2(31));
	}
	shamblery->mflags2 &= ~M2_MERC;				/* no guards */
	shamblery->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblery->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblery->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	shamblertp->ac = rn2(31)-20;				/* any AC */
	shamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblertp->cnutrit = rnd(2000);					/* see above */
	shamblertp->msound = randmonsound();			/* any but the specials */
	shamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblertp->mflags2 |= (1 << rn2(31));
	}
	shamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	pokshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	pokshamblert->ac = rn2(31)-20;				/* any AC */
	pokshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &pokshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	pokshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblert->cnutrit = rnd(2000);					/* see above */
	pokshamblert->msound = randmonsound();			/* any but the specials */
	pokshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		pokshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	pokshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblert->mflags2 |= (1 << rn2(31));
	}
	pokshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	pokshamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	pokshamblertp->ac = rn2(31)-20;				/* any AC */
	pokshamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &pokshamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	pokshamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblertp->cnutrit = rnd(2000);					/* see above */
	pokshamblertp->msound = randmonsound();			/* any but the specials */
	pokshamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		pokshamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	pokshamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	pokshamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblertp->mflags2 |= (1 << rn2(31));
	}
	pokshamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	rpokshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	rpokshamblert->ac = rn2(31)-20;				/* any AC */
	rpokshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	rpokshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rpokshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rpokshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rpokshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rpokshamblert->cnutrit = rnd(2000);					/* see above */
	rpokshamblert->msound = randmonsound();			/* any but the specials */
	rpokshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rpokshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rpokshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rpokshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rpokshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		rpokshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	rpokshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rpokshamblert->mflags2 |= (1 << rn2(31));
	}
	rpokshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	rpokshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rpokshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rpokshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strpokshamblert, buf, sizeof(buf) );
	rpokshamblert->mname = u.strpokshamblert;

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	rpokshamblertp->mmove = rn2(14)+9;				/* slow to very fast */
	rpokshamblertp->ac = rn2(31)-20;				/* any AC */
	rpokshamblertp->mr = rn2(5)*25;				/* varying amounts of MR */
	rpokshamblertp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rpokshamblertp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rpokshamblertp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rpokshamblertp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rpokshamblertp->cnutrit = rnd(2000);					/* see above */
	rpokshamblertp->msound = randmonsound();			/* any but the specials */
	rpokshamblertp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rpokshamblertp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rpokshamblertp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rpokshamblertp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rpokshamblertp->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		rpokshamblertp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	rpokshamblertp->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	rpokshamblertp->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rpokshamblertp->mflags2 |= (1 << rn2(31));
	}
	rpokshamblertp->mflags2 &= ~M2_MERC;				/* no guards */
	rpokshamblertp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rpokshamblertp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rpokshamblertp->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strpokshamblertp, buf, sizeof(buf) );
	rpokshamblertp->mname = u.strpokshamblertp;

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerta->mmove = rn2(14)+9;				/* slow to very fast */
	shamblerta->ac = rn2(31)-20;				/* any AC */
	shamblerta->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerta->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerta->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblerta->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerta->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerta->cnutrit = rnd(2000);					/* see above */
	shamblerta->msound = randmonsound();			/* any but the specials */
	shamblerta->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerta->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerta->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerta->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerta->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerta->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerta->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerta->mflags2 |= (1 << rn2(31));
	}
	shamblerta->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerta->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerta->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerta->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerya->mmove = rn2(14)+9;				/* slow to very fast */
	shamblerya->ac = rn2(31)-20;				/* any AC */
	shamblerya->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerya->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerya->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblerya->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerya->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerya->cnutrit = rnd(2000);					/* see above */
	shamblerya->msound = randmonsound();			/* any but the specials */
	shamblerya->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerya->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerya->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerya->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerya->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerya->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblerya->mflags1 &= ~M1_HIDE;				/* no hiding */

	shamblerya->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerya->mflags2 |= (1 << rn2(31));
	}
	shamblerya->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerya->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerya->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerya->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblertpa->mmove = rn2(14)+9;				/* slow to very fast */
	shamblertpa->ac = rn2(31)-20;				/* any AC */
	shamblertpa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblertpa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblertpa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	shamblertpa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblertpa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblertpa->cnutrit = rnd(2000);					/* see above */
	shamblertpa->msound = randmonsound();			/* any but the specials */
	shamblertpa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblertpa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblertpa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblertpa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblertpa->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblertpa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	shamblertpa->mflags1 &= ~M1_CARNIVORE;				/* must be herbivore */

	shamblertpa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblertpa->mflags2 |= (1 << rn2(31));
	}
	shamblertpa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblertpa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblertpa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblertpa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	shamblerl->mmove = rn2(8)+9;				/* slow to very fast */
	shamblerl->ac = rn2(16)-5;				/* any AC */
	shamblerl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	shamblerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerl->cnutrit = rnd(2000);					/* see above */
	shamblerl->msound = randmonsound();			/* any but the specials */
	shamblerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerl->mflags2 |= (1 << rn2(31));
	}
	shamblerl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	shamblerln->mmove = rn2(3)+6;				/* slow to very fast */
	shamblerln->ac = 10 - rn2(6);				/* any AC */
	shamblerln->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerln->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(2); i++) {
		attkptr = &shamblerln->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2);				/* either too high or too low */
	}
	shamblerln->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerln->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerln->cnutrit = rnd(2000);					/* see above */
	shamblerln->msound = randmonsound();			/* any but the specials */
	shamblerln->mresists = 0;
	for (i = 0; i < rnd(3); i++) {
		shamblerln->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(2); i++) {
		shamblerln->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerln->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerln->mflags1 = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerln->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerln->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerln->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerln->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(7); i++) {
		shamblerln->mflags2 |= (1 << rn2(31));
	}
	shamblerln->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerln->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerln->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerln->mflags2 &= ~M2_PNAME;				/* not a proper name */

	shamblerlo->mmove = rn2(3)+6;				/* slow to very fast */
	shamblerlo->ac = 10 - rn2(6);				/* any AC */
	shamblerlo->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerlo->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(2); i++) {
		attkptr = &shamblerlo->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2);				/* either too high or too low */
	}
	shamblerlo->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerlo->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerlo->cnutrit = rnd(2000);					/* see above */
	shamblerlo->msound = randmonsound();			/* any but the specials */
	shamblerlo->mresists = 0;
	for (i = 0; i < rnd(3); i++) {
		shamblerlo->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(2); i++) {
		shamblerlo->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerlo->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerlo->mflags1 = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerlo->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerlo->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerlo->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerlo->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(7); i++) {
		shamblerlo->mflags2 |= (1 << rn2(31));
	}
	shamblerlo->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerlo->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerlo->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerlo->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	shamblerla->mmove = rn2(8)+9;				/* slow to very fast */
	shamblerla->ac = rn2(16)-5;				/* any AC */
	shamblerla->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	shamblerla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerla->cnutrit = rnd(2000);					/* see above */
	shamblerla->msound = randmonsound();			/* any but the specials */
	shamblerla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerla->mflags2 |= (1 << rn2(31));
	}
	shamblerla->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	pokshamblerl->mmove = rn2(8)+9;				/* slow to very fast */
	pokshamblerl->ac = rn2(16)-5;				/* any AC */
	pokshamblerl->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	pokshamblerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerl->cnutrit = rnd(2000);					/* see above */
	pokshamblerl->msound = randmonsound();			/* any but the specials */
	pokshamblerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerl->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerl->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerl->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerl->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerl->mflags2 |= (1 << rn2(31));
	}
	pokshamblerl->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerl->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(12)-9;*/				/* shuffle level */
	pokshamblerla->mmove = rn2(8)+9;				/* slow to very fast */
	pokshamblerla->ac = rn2(16)-5;				/* any AC */
	pokshamblerla->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerla->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerla->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+2;				/* either too high or too low */
	}
	pokshamblerla->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerla->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerla->cnutrit = rnd(2000);					/* see above */
	pokshamblerla->msound = randmonsound();			/* any but the specials */
	pokshamblerla->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerla->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerla->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerla->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerla->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerla->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerla->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerla->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerla->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerla->mflags2 |= (1 << rn2(31));
	}
	pokshamblerla->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerla->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerla->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerla->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	gloshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	gloshamblerx->ac = rn2(18)-7;				/* any AC */
	gloshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &gloshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	gloshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblerx->cnutrit = rnd(2000);					/* see above */
	gloshamblerx->msound = randmonsound();			/* any but the specials */
	gloshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		gloshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*gloshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*gloshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	gloshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblerx->mflags2 |= (1 << rn2(31));
	}
	gloshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	gloshamblert->mmove = rn2(14)+9;				/* slow to very fast */
	gloshamblert->ac = rn2(31)-20;				/* any AC */
	gloshamblert->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &gloshamblert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	gloshamblert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblert->cnutrit = rnd(2000);					/* see above */
	gloshamblert->msound = randmonsound();			/* any but the specials */
	gloshamblert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblert->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		gloshamblert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	gloshamblert->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblert->mflags2 |= (1 << rn2(31));
	}
	gloshamblert->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblert->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	gloshamblerz->mmove = rn2(20)+9;				/* slow to very fast */
	gloshamblerz->ac = rn2(40)-29;				/* any AC */
	gloshamblerz->mr = rn2(5)*25;				/* varying amounts of MR */
	gloshamblerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &gloshamblerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	gloshamblerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	gloshamblerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	gloshamblerz->cnutrit = rnd(2000);					/* see above */
	gloshamblerz->msound = randmonsound();			/* any but the specials */
	gloshamblerz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		gloshamblerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		gloshamblerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	gloshamblerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	gloshamblerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		gloshamblerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*gloshamblerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*gloshamblerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	gloshamblerz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		gloshamblerz->mflags2 |= (1 << rn2(31));
	}
	gloshamblerz->mflags2 &= ~M2_MERC;				/* no guards */
	gloshamblerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	gloshamblerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	gloshamblerz->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerx->ac = rn2(18)-7;				/* any AC */
	shamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerx->cnutrit = rnd(2000);					/* see above */
	shamblerx->msound = randmonsound();			/* any but the specials */
	shamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerx->mflags2 |= (1 << rn2(31));
	}
	shamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerxz->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerxz->ac = rn2(18)-7;				/* any AC */
	shamblerxz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerxz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerxz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerxz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerxz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerxz->cnutrit = rnd(2000);					/* see above */
	shamblerxz->msound = randmonsound();			/* any but the specials */
	shamblerxz->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerxz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerxz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerxz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerxz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerxz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerxz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerxz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerxz->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerxz->mflags2 |= (1 << rn2(31));
	}
	shamblerxz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerxz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerxz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerxz->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	shamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerxa->ac = rn2(18)-7;				/* any AC */
	shamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &shamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	shamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerxa->cnutrit = rnd(2000);					/* see above */
	shamblerxa->msound = randmonsound();			/* any but the specials */
	shamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerxa->mflags2 |= (1 << rn2(31));
	}
	shamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	rshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	rshamblerx->ac = rn2(18)-7;				/* any AC */
	rshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &rshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	rshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerx->cnutrit = rnd(2000);					/* see above */
	rshamblerx->msound = randmonsound();			/* any but the specials */
	rshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerx->mflags2 |= (1 << rn2(31));
	}
	rshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerx, buf, sizeof(buf) );
	rshamblerx->mname = u.strshamblerx;

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	rshamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	rshamblerxa->ac = rn2(18)-7;				/* any AC */
	rshamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	rshamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &rshamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	rshamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	rshamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	rshamblerxa->cnutrit = rnd(2000);					/* see above */
	rshamblerxa->msound = randmonsound();			/* any but the specials */
	rshamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rshamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rshamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rshamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rshamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		rshamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*rshamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*rshamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	rshamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rshamblerxa->mflags2 |= (1 << rn2(31));
	}
	rshamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	rshamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rshamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rshamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strshamblerxa, buf, sizeof(buf) );
	rshamblerxa->mname = u.strshamblerxa;

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	pokshamblerx->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerx->ac = rn2(18)-7;				/* any AC */
	pokshamblerx->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	pokshamblerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerx->cnutrit = rnd(2000);					/* see above */
	pokshamblerx->msound = randmonsound();			/* any but the specials */
	pokshamblerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerx->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerx->mflags2 |= (1 << rn2(31));
	}
	pokshamblerx->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerx->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	pokshamblerxa->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerxa->ac = rn2(18)-7;				/* any AC */
	pokshamblerxa->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerxa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &pokshamblerxa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	pokshamblerxa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerxa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerxa->cnutrit = rnd(2000);					/* see above */
	pokshamblerxa->msound = randmonsound();			/* any but the specials */
	pokshamblerxa->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerxa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerxa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerxa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerxa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerxa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerxa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerxa->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerxa->mflags2 |= (1 << rn2(31));
	}
	pokshamblerxa->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerxa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerxa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerxa->mflags2 &= ~M2_PNAME;				/* not a proper name */


	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerm->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerm->ac = rn2(21)-10;				/* any AC */
	shamblerm->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerm->cnutrit = rnd(2000);					/* see above */
	shamblerm->msound = randmonsound();			/* any but the specials */
	shamblerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerm->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerm->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerm->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerm->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerm->mflags2 |= (1 << rn2(31));
	}
	shamblerm->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerm->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerma->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerma->ac = rn2(21)-10;				/* any AC */
	shamblerma->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerma->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerma->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerma->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerma->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerma->cnutrit = rnd(2000);					/* see above */
	shamblerma->msound = randmonsound();			/* any but the specials */
	shamblerma->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerma->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerma->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerma->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerma->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerma->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerma->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerma->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerma->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerma->mflags2 |= (1 << rn2(31));
	}
	shamblerma->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerma->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerma->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerma->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblern->mmove = rn2(9)+9;				/* slow to very fast */
	shamblern->ac = rn2(21)-10;				/* any AC */
	shamblern->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblern->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblern->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblern->cnutrit = rnd(2000);					/* see above */
	shamblern->msound = randmonsound();			/* any but the specials */
	shamblern->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblern->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblern->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblern->mflags1 = M1_HIDE;
	for (i = 0; i < rnd(17); i++) {
		shamblern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblern->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblern->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblern->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblern->mflags2 |= (1 << rn2(31));
	}
	shamblern->mflags2 &= ~M2_MERC;				/* no guards */
	shamblern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblern->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerna->mmove = rn2(9)+9;				/* slow to very fast */
	shamblerna->ac = rn2(21)-10;				/* any AC */
	shamblerna->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerna->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &shamblerna->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	shamblerna->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerna->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerna->cnutrit = rnd(2000);					/* see above */
	shamblerna->msound = randmonsound();			/* any but the specials */
	shamblerna->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerna->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerna->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerna->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerna->mflags1 = M1_HIDE;
	for (i = 0; i < rnd(17); i++) {
		shamblerna->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerna->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerna->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerna->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		shamblerna->mflags2 |= (1 << rn2(31));
	}
	shamblerna->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerna->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerna->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerna->mflags2 &= ~M2_PNAME;				/* not a proper name */



	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	pokshamblerm->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerm->ac = rn2(21)-10;				/* any AC */
	pokshamblerm->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	pokshamblerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerm->cnutrit = rnd(2000);					/* see above */
	pokshamblerm->msound = randmonsound();			/* any but the specials */
	pokshamblerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerm->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerm->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerm->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerm->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerm->mflags2 |= (1 << rn2(31));
	}
	pokshamblerm->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerm->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*pokshambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	pokshamblerma->mmove = rn2(9)+9;				/* slow to very fast */
	pokshamblerma->ac = rn2(21)-10;				/* any AC */
	pokshamblerma->mr = rn2(5)*25;				/* varying amounts of MR */
	pokshamblerma->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &pokshamblerma->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+2;				/* either too high or too low */
	}
	pokshamblerma->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	pokshamblerma->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	pokshamblerma->cnutrit = rnd(2000);					/* see above */
	pokshamblerma->msound = randmonsound();			/* any but the specials */
	pokshamblerma->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		pokshamblerma->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		pokshamblerma->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	pokshamblerma->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	pokshamblerma->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		pokshamblerma->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*pokshamblerma->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*pokshamblerma->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	pokshamblerma->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		pokshamblerma->mflags2 |= (1 << rn2(31));
	}
	pokshamblerma->mflags2 &= ~M2_MERC;				/* no guards */
	pokshamblerma->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	pokshamblerma->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	pokshamblerma->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shamblerplayer->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayer->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayer->ac = rn2(21)-10;				/* any AC */
	shamblerplayer->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayer->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayer->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayer->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayer->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayer->cnutrit = rnd(2000);					/* see above */
	shamblerplayer->msound = randmonsound();			/* any but the specials */
	shamblerplayer->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayer->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayer->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayer->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayer->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayer->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayer->mflags2 = M2_HOSTILE | M2_WERE;		/* mondata.c prevents players from polying into them */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayer->mflags2 |= (1 << rn2(31));
	}
	shamblerplayer->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayer->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayer->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayer->mflags2 &= ~M2_NOPOLY;				/* see above */

	/* what a horrible night to have a curse */
	/*shamblerplayergl->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayergl->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayergl->ac = rn2(21)-10;				/* any AC */
	shamblerplayergl->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayergl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayergl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayergl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayergl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayergl->cnutrit = rnd(2000);					/* see above */
	shamblerplayergl->msound = randmonsound();			/* any but the specials */
	shamblerplayergl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayergl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayergl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayergl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayergl->mflags1 = M1_CARNIVORE|M1_OVIPAROUS;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayergl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayergl->mflags2 = M2_NOPOLY;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayergl->mflags2 |= (1 << rn2(31));
	}
	shamblerplayergl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayergl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayergl->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayergl->mflags2 &= ~M2_WERE;				/* no werefoo */

	/* what a horrible night to have a curse */
	/*shamblerplayerb->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerb->mmove = rn2(10)+9;				/* slow to very fast */
	shamblerplayerb->ac = rn2(21)-10;				/* any AC */
	shamblerplayerb->mr = rn2(11)*10;				/* varying amounts of MR */
	shamblerplayerb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &shamblerplayerb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}
	shamblerplayerb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerb->cnutrit = rnd(2000);					/* see above */
	shamblerplayerb->msound = randmonsound();			/* any but the specials */
	shamblerplayerb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerb->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerb->mflags2 = M2_HOSTILE | M2_WERE;		/* mondata.c prevents players from polying into them */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerb->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerb->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerb->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerb->mflags2 &= ~M2_NOPOLY;				/* see above */

	/* what a horrible night to have a curse */
	/*shamblerplayerc->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerc->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerc->ac = rn2(21)-10;				/* any AC */
	shamblerplayerc->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerc->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerc->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerc->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerc->cnutrit = rnd(2000);					/* see above */
	shamblerplayerc->msound = randmonsound();			/* any but the specials */
	shamblerplayerc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerc->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerc->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerc->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerc->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerc->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerc->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerc->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerc->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayerd->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerd->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerd->ac = rn2(21)-10;				/* any AC */
	shamblerplayerd->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerd->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerd->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerd->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerd->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerd->cnutrit = rnd(2000);					/* see above */
	shamblerplayerd->msound = randmonsound();			/* any but the specials */
	shamblerplayerd->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerd->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerd->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerd->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerd->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerd->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerd->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerd->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerd->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerd->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerd->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerd->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerd->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerd->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerd->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayere->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayere->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayere->ac = rn2(21)-10;				/* any AC */
	shamblerplayere->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayere->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayere->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayere->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayere->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayere->cnutrit = rnd(2000);					/* see above */
	shamblerplayere->msound = randmonsound();			/* any but the specials */
	shamblerplayere->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayere->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayere->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayere->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayere->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayere->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayere->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayere->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayere->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayere->mflags2 |= (1 << rn2(31));
	}
	shamblerplayere->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayere->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayere->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayere->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayere->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shamblerplayerf->mlevel += rnd(12)-3;*/				/* shuffle level */
	shamblerplayerf->mmove = rn3(10)+9;				/* slow to very fast */
	shamblerplayerf->ac = rn2(21)-10;				/* any AC */
	shamblerplayerf->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerf->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(10)+2;				/* either too high or too low */
	}
	shamblerplayerf->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerf->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerf->cnutrit = rnd(2000);					/* see above */
	shamblerplayerf->msound = randmonsound();			/* any but the specials */
	shamblerplayerf->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerf->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerf->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerf->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerf->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerf->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerf->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerf->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerf->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerf->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerf->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerf->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerf->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerg->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerg->ac = rn2(21)-10;				/* any AC */
	shamblerplayerg->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerg->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerg->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerg->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerg->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerg->cnutrit = rnd(2000);					/* see above */
	shamblerplayerg->msound = randmonsound();			/* any but the specials */
	shamblerplayerg->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerg->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerg->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerg->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerg->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerg->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerg->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerg->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerg->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerg->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerg->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerg->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerh->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerh->ac = rn2(21)-10;				/* any AC */
	shamblerplayerh->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerh->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerh->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerh->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerh->cnutrit = rnd(2000);					/* see above */
	shamblerplayerh->msound = randmonsound();			/* any but the specials */
	shamblerplayerh->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerh->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerh->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerh->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerh->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerh->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerh->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerh->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerh->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerh->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerh->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerh->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerh->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermso->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermso->ac = rn2(21)-10;				/* any AC */
	shamblerplayermso->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermso->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermso->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermso->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermso->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermso->cnutrit = rnd(2000);					/* see above */
	shamblerplayermso->msound = randmonsound();			/* any but the specials */
	shamblerplayermso->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermso->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermso->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermso->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermso->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermso->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermso->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermso->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermso->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermso->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermso->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermso->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermso->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermsp->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermsp->ac = rn2(21)-10;				/* any AC */
	shamblerplayermsp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermsp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermsp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermsp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermsp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermsp->cnutrit = rnd(2000);					/* see above */
	shamblerplayermsp->msound = randmonsound();			/* any but the specials */
	shamblerplayermsp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermsp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermsp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermsp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermsp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermsp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermsp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermsp->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermsp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermsp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermsp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermsp->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermsp->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayeri->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayeri->ac = rn2(21)-10;				/* any AC */
	shamblerplayeri->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeri->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayeri->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayeri->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeri->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeri->cnutrit = rnd(2000);					/* see above */
	shamblerplayeri->msound = randmonsound();			/* any but the specials */
	shamblerplayeri->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeri->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayeri->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeri->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeri->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeri->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeri->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeri->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeri->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeri->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeri->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeri->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeri->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeri->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeri->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayerj->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayerj->ac = rn2(21)-10;				/* any AC */
	shamblerplayerj->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerj->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayerj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayerj->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerj->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerj->cnutrit = rnd(2000);					/* see above */
	shamblerplayerj->msound = randmonsound();			/* any but the specials */
	shamblerplayerj->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerj->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerj->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerj->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerj->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerj->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerj->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerj->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerj->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerj->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerj->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerj->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerj->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerk->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerk->ac = rn2(31)-20;				/* any AC */
	shamblerplayerk->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerk->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerk->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerk->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerk->cnutrit = rnd(2000);					/* see above */
	shamblerplayerk->msound = randmonsound();			/* any but the specials */
	shamblerplayerk->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerk->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerk->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerk->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerk->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerk->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerk->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerk->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerk->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerk->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerk->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerk->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerk->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerl->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerl->ac = rn2(31)-20;				/* any AC */
	shamblerplayerl->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerl->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerl->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerl->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerl->cnutrit = rnd(2000);					/* see above */
	shamblerplayerl->msound = randmonsound();			/* any but the specials */
	shamblerplayerl->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerl->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerl->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerl->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerl->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerl->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerl->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerl->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerl->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerl->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerl->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayerm->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayerm->ac = rn2(31)-20;				/* any AC */
	shamblerplayerm->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerm->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayerm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayerm->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerm->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerm->cnutrit = rnd(2000);					/* see above */
	shamblerplayerm->msound = randmonsound();			/* any but the specials */
	shamblerplayerm->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerm->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerm->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerm->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerm->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayerm->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerm->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerm->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerm->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerm->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerm->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerm->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	shamblerplayern->mmove = rn3(14)+9;				/* slow to very fast */
	shamblerplayern->ac = rn2(31)-20;				/* any AC */
	shamblerplayern->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayern->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(5); i++) {
		attkptr = &shamblerplayern->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(15)+2;				/* either too high or too low */
	}
	shamblerplayern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayern->cnutrit = rnd(2000);					/* see above */
	shamblerplayern->msound = randmonsound();			/* any but the specials */
	shamblerplayern->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayern->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayern->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayern->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	shamblerplayern->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayern->mflags2 |= (1 << rn2(31));
	}
	shamblerplayern->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayern->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayern->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayero->mmove = rn3(18)+9;				/* slow to very fast */
	shamblerplayero->ac = rn2(35)-24;				/* any AC */
	shamblerplayero->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayero->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayero->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(20)+2;				/* either too high or too low */
	}
	shamblerplayero->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayero->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayero->cnutrit = rnd(2000);					/* see above */
	shamblerplayero->msound = randmonsound();			/* any but the specials */
	shamblerplayero->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayero->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayero->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayero->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayero->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayero->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayero->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayero->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayero->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayero->mflags2 |= (1 << rn2(31));
	}
	shamblerplayero->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayero->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayero->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayero->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayero->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerp->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerp->ac = rn2(40)-29;				/* any AC */
	shamblerplayerp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerp->cnutrit = rnd(2000);					/* see above */
	shamblerplayerp->msound = randmonsound();			/* any but the specials */
	shamblerplayerp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerp->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerp->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerp->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerp->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerq->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerq->ac = rn2(40)-29;				/* any AC */
	shamblerplayerq->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerq->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerq->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerq->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerq->cnutrit = rnd(2000);					/* see above */
	shamblerplayerq->msound = randmonsound();			/* any but the specials */
	shamblerplayerq->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerq->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerq->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerq->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerq->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerq->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerq->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerq->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerq->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerq->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerq->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerq->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */



	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerr->mmove = rn3(20)+9;				/* slow to very fast */
	shamblerplayerr->ac = rn2(40)-29;				/* any AC */
	shamblerplayerr->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerr->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerr->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerr->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerr->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerr->cnutrit = rnd(2000);					/* see above */
	shamblerplayerr->msound = randmonsound();			/* any but the specials */
	shamblerplayerr->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerr->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerr->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerr->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerr->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerr->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerr->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerr->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerr->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerr->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerr->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerr->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerr->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */



	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayers->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayers->ac = rn2(40)-29;				/* any AC */
	shamblerplayers->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayers->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayers->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayers->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayers->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayers->cnutrit = rnd(2000);					/* see above */
	shamblerplayers->msound = randmonsound();			/* any but the specials */
	shamblerplayers->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayers->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayers->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayers->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayers->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayers->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayers->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayers->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayers->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayers->mflags2 |= (1 << rn2(31));
	}
	shamblerplayers->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayers->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayers->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayers->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayers->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */


	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayert->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayert->ac = rn2(41)-30;				/* any AC */
	shamblerplayert->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayert->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayert->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayert->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayert->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayert->cnutrit = rnd(2000);					/* see above */
	shamblerplayert->msound = randmonsound();			/* any but the specials */
	shamblerplayert->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayert->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayert->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayert->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayert->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayert->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayert->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayert->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayert->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayert->mflags2 |= (1 << rn2(31));
	}
	shamblerplayert->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayert->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayert->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayert->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayert->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayeru->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayeru->ac = rn2(42)-31;				/* any AC */
	shamblerplayeru->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeru->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayeru->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayeru->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeru->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeru->cnutrit = rnd(2000);					/* see above */
	shamblerplayeru->msound = randmonsound();			/* any but the specials */
	shamblerplayeru->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeru->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayeru->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeru->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeru->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeru->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeru->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeru->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeru->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeru->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeru->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeru->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeru->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeru->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeru->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerv->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerv->ac = rn2(42)-31;				/* any AC */
	shamblerplayerv->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerv->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerv->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerv->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerv->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerv->cnutrit = rnd(2000);					/* see above */
	shamblerplayerv->msound = randmonsound();			/* any but the specials */
	shamblerplayerv->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerv->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerv->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerv->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerv->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerv->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerv->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerv->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerv->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerv->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerv->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerv->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerv->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerv->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerv->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerflum->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerflum->ac = rn2(42)-31;				/* any AC */
	shamblerplayerflum->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerflum->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerflum->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerflum->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerflum->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerflum->cnutrit = rnd(2000);					/* see above */
	shamblerplayerflum->msound = randmonsound();			/* any but the specials */
	shamblerplayerflum->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerflum->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerflum->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerflum->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerflum->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerflum->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerflum->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerflum->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerflum->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerflum->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerflum->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerflum->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerflum->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerflum->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerflum->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerw->mmove = rn3(21)+9;				/* slow to very fast */
	shamblerplayerw->ac = rn2(42)-31;				/* any AC */
	shamblerplayerw->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerw->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerw->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerw->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerw->cnutrit = rnd(2000);					/* see above */
	shamblerplayerw->msound = randmonsound();			/* any but the specials */
	shamblerplayerw->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerw->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerw->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerw->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerw->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerw->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerw->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerw->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerw->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerw->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerw->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerw->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerw->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerx->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerx->ac = rn2(42)-31;				/* any AC */
	shamblerplayerx->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerx->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(24)+2;				/* either too high or too low */
	}
	shamblerplayerx->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerx->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerx->cnutrit = rnd(2000);					/* see above */
	shamblerplayerx->msound = randmonsound();			/* any but the specials */
	shamblerplayerx->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayerx->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerx->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerx->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerx->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerx->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerx->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerx->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerx->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerx->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerx->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerx->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayery->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayery->ac = rn2(42)-31;				/* any AC */
	shamblerplayery->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayery->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayery->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayery->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayery->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayery->cnutrit = rnd(2000);					/* see above */
	shamblerplayery->msound = randmonsound();			/* any but the specials */
	shamblerplayery->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayery->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayery->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayery->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayery->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayery->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayery->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayery->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayery->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayery->mflags2 |= (1 << rn2(31));
	}
	shamblerplayery->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayery->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayery->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayery->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayery->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerz->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerz->ac = rn2(42)-31;				/* any AC */
	shamblerplayerz->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerz->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayerz->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerz->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerz->cnutrit = rnd(2000);					/* see above */
	shamblerplayerz->msound = randmonsound();			/* any but the specials */
	shamblerplayerz->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerz->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerz->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerz->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerz->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerz->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerz->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerz->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerz->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerz->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerz->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerz->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayeraa->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayeraa->ac = rn2(43)-32;				/* any AC */
	shamblerplayeraa->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayeraa->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayeraa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayeraa->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayeraa->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayeraa->cnutrit = rnd(2000);					/* see above */
	shamblerplayeraa->msound = randmonsound();			/* any but the specials */
	shamblerplayeraa->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayeraa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayeraa->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayeraa->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayeraa->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeraa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayeraa->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayeraa->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayeraa->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayeraa->mflags2 |= (1 << rn2(31));
	}
	shamblerplayeraa->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayeraa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayeraa->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayeraa->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayeraa->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerab->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerab->ac = rn2(44)-33;				/* any AC */
	shamblerplayerab->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerab->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerab->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(25)+2;				/* either too high or too low */
	}
	shamblerplayerab->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerab->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerab->cnutrit = rnd(2000);					/* see above */
	shamblerplayerab->msound = randmonsound();			/* any but the specials */
	shamblerplayerab->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerab->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerab->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerab->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerab->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerab->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerab->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerab->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerab->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerab->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerab->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerab->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerab->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerab->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerac->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerac->ac = rn2(44)-33;				/* any AC */
	shamblerplayerac->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerac->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerac->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(26)+2;				/* either too high or too low */
	}
	shamblerplayerac->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerac->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerac->cnutrit = rnd(2000);					/* see above */
	shamblerplayerac->msound = randmonsound();			/* any but the specials */
	shamblerplayerac->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerac->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerac->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerac->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerac->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerac->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerac->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerac->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerac->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerac->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerac->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerac->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerac->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerac->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerad->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerad->ac = rn2(46)-36;				/* any AC */
	shamblerplayerad->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerad->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerad->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(26)+2;				/* either too high or too low */
	}
	shamblerplayerad->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerad->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerad->cnutrit = rnd(2000);					/* see above */
	shamblerplayerad->msound = randmonsound();			/* any but the specials */
	shamblerplayerad->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerad->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerad->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerad->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerad->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerad->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerad->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerad->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerad->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerad->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerad->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerad->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerad->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerad->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerad->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*pokshamblerxt->mlevel += rnd(24)-6;*/				/* shuffle level */
	shamblerplayerae->mmove = rn3(22)+9;				/* slow to very fast */
	shamblerplayerae->ac = rn2(46)-36;				/* any AC */
	shamblerplayerae->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayerae->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(6); i++) {
		attkptr = &shamblerplayerae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(27)+2;				/* either too high or too low */
	}
	shamblerplayerae->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayerae->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayerae->cnutrit = rnd(2000);					/* see above */
	shamblerplayerae->msound = randmonsound();			/* any but the specials */
	shamblerplayerae->mresists = 0;
	for (i = 0; i < rnd(7); i++) {
		shamblerplayerae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(6); i++) {
		shamblerplayerae->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayerae->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayerae->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayerae->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayerae->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayerae->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayerae->mflags2 |= (1 << rn2(31));
	}
	shamblerplayerae->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayerae->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayerae->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayerae->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayerae->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(16)-7;*/				/* shuffle level */
	splicemona->mmove = rn2(9)+9;				/* slow to very fast */
	splicemona->ac = rn2(18)-7;				/* any AC */
	splicemona->mr = rn2(5)*25;				/* varying amounts of MR */
	splicemona->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(3); i++) {
		attkptr = &splicemona->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}
	splicemona->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	splicemona->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	splicemona->cnutrit = rnd(2000);					/* see above */
	splicemona->msound = randmonsound();			/* any but the specials */
	splicemona->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		splicemona->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		splicemona->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	splicemona->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	splicemona->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		splicemona->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*splicemona->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*splicemona->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	splicemona->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		splicemona->mflags2 |= (1 << rn2(31));
	}
	splicemona->mflags2 &= ~M2_MERC;				/* no guards */
	splicemona->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	splicemona->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	splicemona->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(18)-4;*/				/* shuffle level */
	splicemonb->mmove = rn2(14)+9;				/* slow to very fast */
	splicemonb->ac = rn2(31)-20;				/* any AC */
	splicemonb->mr = rn2(5)*25;				/* varying amounts of MR */
	splicemonb->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &splicemonb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	splicemonb->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	splicemonb->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	splicemonb->cnutrit = rnd(2000);					/* see above */
	splicemonb->msound = randmonsound();			/* any but the specials */
	splicemonb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		splicemonb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		splicemonb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	splicemonb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	splicemonb->mflags1 = M1_HERBIVORE;
	for (i = 0; i < rnd(17); i++) {
		splicemonb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	splicemonb->mflags1 &= ~M1_HIDE;				/* no hiding */

	splicemonb->mflags2 = M2_HOSTILE;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		splicemonb->mflags2 |= (1 << rn2(31));
	}
	splicemonb->mflags2 &= ~M2_MERC;				/* no guards */
	splicemonb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	splicemonb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	splicemonb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	if (!rn2(10)) {
	attkptr = &deathraylord->mattk[4]; /* Yeenoghu gets finger of death */
	attkptr->aatyp = AT_MAGC; /* well, at least one out of ten games he does */
	attkptr->adtyp = AD_DISN; /* as a tribute to that fallthrough "bug" where he got a touch of death --Amy */
	attkptr->damn = 2;
	attkptr->damd = 6;
	}

	lolirace->msound = !rn2(3) ? MS_FART_NORMAL : !rn2(2) ? MS_FART_QUIET : MS_FART_LOUD;

	if (!rn2(10)) {
	attkptr = &coldlord->mattk[1]; /* evil patch idea by irinya: because nobody actually knows how much damage Asmodeus's cold attack does, it's been bumped up to 60d6 */
	attkptr->damn = 60;
	}

	/* evil patch idea by hackedhead: rider-gating */
	/* evil patch idea by Wooble: make the riders covetous */

	if (!rn2(10)) riderone->mflags2 |= M2_DEMON;
	if (!rn2(10)) riderone->mflags3 |= M3_WANTSBOOK;
	if (!rn2(10)) ridertwo->mflags2 |= M2_DEMON;
	if (!rn2(10)) ridertwo->mflags3 |= M3_WANTSBOOK;
	if (!rn2(10)) riderthree->mflags2 |= M2_DEMON;
	if (!rn2(10)) riderthree->mflags3 |= M3_WANTSBOOK;

	/* the multicolor grue has a AD_RBRE breath attack, but there is no AD_RBRE for melee attacks (yet).
	 * So we're just giving it some random damage types for its melee and passive attack. --Amy */
	for (i = 0; i < 2; i++) {
		attkptr = &multigrue->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	/* similar stuff for some other monsters */

	for (i = 0; i < 2; i++) {
		attkptr = &randomeye->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandommimic, buf, sizeof(buf) );
	rrandommimic->mname = u.strandommimic;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandommimicb, buf, sizeof(buf) );
	rrandommimicb->mname = u.strandommimicb;

	randommimic->mmove = rnd(10)+2;
	randommimic->ac = 5-rnd(20);
	randommimic->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randommimic->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randommimicb->mmove = rnd(10)+2;
	randommimicb->ac = 5-rnd(20);
	randommimicb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randommimicb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randompiercer->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercerd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}
	for (i = 0; i < 2; i++) {
		attkptr = &randompiercere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomvortex->mmove = rnd(10)+6;
	randomvortex->ac = 0-rnd(16);
	randomvortex->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomvortex->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungus->ac = 10-rnd(25);
	randomfungus->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungus->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusb->mmove = rnd(12);
	randomfungusb->ac = 10-rnd(25);
	randomfungusb->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusba->mmove = rnd(12);
	randomfungusba->ac = 10-rnd(25);
	randomfungusba->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusba->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbb->mmove = rnd(12);
	randomfungusbb->ac = 10-rnd(25);
	randomfungusbb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbbx->mmove = rnd(12);
	randomfungusbbx->ac = 10-rnd(25);
	randomfungusbbx->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbbx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbc->mmove = rnd(12);
	randomfungusbc->ac = 10-rnd(25);
	randomfungusbc->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbd->mmove = rnd(12);
	randomfungusbd->ac = 10-rnd(25);
	randomfungusbd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusbe->mmove = rnd(12);
	randomfungusbe->ac = 10-rnd(25);
	randomfungusbe->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusbe->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusc->ac = 10-rnd(35);
	randomfungusc->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungusc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusd->mmove = rnd(15);
	randomfungusd->ac = 10-rnd(35);
	randomfungusd->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusda->mmove = rnd(15);
	randomfungusda->ac = 10-rnd(35);
	randomfungusda->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusda->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdb->mmove = rnd(15);
	randomfungusdb->ac = 10-rnd(35);
	randomfungusdb->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdbx->mmove = rnd(15);
	randomfungusdbx->ac = 10-rnd(35);
	randomfungusdbx->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdbx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdc->mmove = rnd(15);
	randomfungusdc->ac = 10-rnd(35);
	randomfungusdc->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusdd->mmove = rnd(15);
	randomfungusdd->ac = 10-rnd(35);
	randomfungusdd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusdd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusde->mmove = rnd(15);
	randomfungusde->ac = 10-rnd(35);
	randomfungusde->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomfungusde->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfunguse->ac = 10-rnd(25);
	randomfunguse->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfunguse->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusf->mmove = rnd(12);
	randomfungusf->ac = 10-rnd(25);
	randomfungusf->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusg->mmove = rnd(12);
	randomfungusg->ac = 10-rnd(25);
	randomfungusg->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungush->mmove = rnd(12);
	randomfungush->ac = 10-rnd(25);
	randomfungush->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungush->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusi->mmove = rnd(12);
	randomfungusi->ac = 10-rnd(25);
	randomfungusi->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusj->ac = 10-rnd(35);
	randomfungusj->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &randomfungusj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusk->mmove = rnd(15);
	randomfungusk->ac = 10-rnd(35);
	randomfungusk->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusl->mmove = rnd(15);
	randomfungusl->ac = 10-rnd(35);
	randomfungusl->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusm->mmove = rnd(15);
	randomfungusm->ac = 10-rnd(35);
	randomfungusm->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusm->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomfungusn->mmove = rnd(15);
	randomfungusn->ac = 10-rnd(35);
	randomfungusn->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &randomfungusn->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	rrandomfungusa->ac = 10-rnd(30);
	rrandomfungusa->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &rrandomfungusa->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungus, buf, sizeof(buf) );
	rrandomfungusa->mname = u.strandomfungus;

	rrandomfungusb->mmove = rnd(12);
	rrandomfungusb->ac = 10-rnd(30);
	rrandomfungusb->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusb, buf, sizeof(buf) );
	rrandomfungusb->mname = u.strandomfungusb;

	rrandomfungusc->mmove = rnd(12);
	rrandomfungusc->ac = 10-rnd(30);
	rrandomfungusc->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusc, buf, sizeof(buf) );
	rrandomfungusc->mname = u.strandomfungusc;

	rrandomfungusd->mmove = rnd(12);
	rrandomfungusd->ac = 10-rnd(30);
	rrandomfungusd->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusd, buf, sizeof(buf) );
	rrandomfungusd->mname = u.strandomfungusd;

	rrandomfungusdx->mmove = rnd(12);
	rrandomfungusdx->ac = 10-rnd(30);
	rrandomfungusdx->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusdx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusdx, buf, sizeof(buf) );
	rrandomfungusdx->mname = u.strandomfungusd;

	rrandomfunguse->mmove = rnd(12);
	rrandomfunguse->ac = 10-rnd(30);
	rrandomfunguse->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfunguse->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfunguse, buf, sizeof(buf) );
	rrandomfunguse->mname = u.strandomfunguse;

	rrandomfungusf->mmove = rnd(12);
	rrandomfungusf->ac = 10-rnd(30);
	rrandomfungusf->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusf, buf, sizeof(buf) );
	rrandomfungusf->mname = u.strandomfungusf;

	rrandomfungusg->mmove = rnd(12);
	rrandomfungusg->ac = 10-rnd(30);
	rrandomfungusg->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &rrandomfungusg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusg, buf, sizeof(buf) );
	rrandomfungusg->mname = u.strandomfungusg;

	rrandomfungush->ac = 10-rnd(30);
	rrandomfungush->mr = rn2(101);
	for (i = 0; i < 1; i++) {
		attkptr = &rrandomfungush->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungush, buf, sizeof(buf) );
	rrandomfungush->mname = u.strandomfungush;

	rrandomfungusi->mmove = rnd(12);
	rrandomfungusi->ac = 10-rnd(30);
	rrandomfungusi->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusi, buf, sizeof(buf) );
	rrandomfungusi->mname = u.strandomfungusi;

	rrandomfungusj->mmove = rnd(12);
	rrandomfungusj->ac = 10-rnd(30);
	rrandomfungusj->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusj, buf, sizeof(buf) );
	rrandomfungusj->mname = u.strandomfungusj;

	rrandomfungusk->mmove = rnd(12);
	rrandomfungusk->ac = 10-rnd(30);
	rrandomfungusk->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusk, buf, sizeof(buf) );
	rrandomfungusk->mname = u.strandomfungusk;

	rrandomfungusl->mmove = rnd(12);
	rrandomfungusl->ac = 10-rnd(30);
	rrandomfungusl->mr = rn2(101);
	for (i = 0; i < 2; i++) {
		attkptr = &rrandomfungusl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomfungusl, buf, sizeof(buf) );
	rrandomfungusl->mname = u.strandomfungusl;

	randomtroll->mmove = rnd(6)+10;
	randomtroll->ac = 0-rnd(20);
	randomtroll->mr = rn2(101);
	for (i = 0; i < 3; i++) {
		attkptr = &randomtroll->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randomeel->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragon->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilera->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoileri->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}

	for (i = 0; i < rnd(3); i++) {
		attkptr = &randspoilerk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+2;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerl->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerl->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerl->ac = rn2(26)-15;				/* any AC */
	randspoilerl->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerl->maligntyp = rn2(21)-10;			/* any alignment */
	randspoilerl->msound = randmonsound();			/* any but the specials */

	for (i = 0; i < 1; i++) {
		attkptr = &randspoilerm->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerm->mmove = rn2(9)+9;				/* slow to very fast */
	randspoilerm->ac = rn2(26)-15;				/* any AC */
	randspoilerm->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerm->maligntyp = rn2(21)-10;			/* any alignment */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilern->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilern->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilern->ac = rn2(36)-15;				/* any AC */
	randspoilern->mr = rn2(5)*25;				/* varying amounts of MR */

	randspoilern->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilern->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilern->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilern->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilern->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilern->mflags2 |= (1 << rn2(31));
	}
	randspoilern->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilern->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilern->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilern->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilern->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilero->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilero->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilero->ac = rn2(36)-15;				/* any AC */
	randspoilero->mr = rn2(5)*25;				/* varying amounts of MR */

	randspoilero->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilero->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilero->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilero->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilero->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilero->mflags2 |= (1 << rn2(31));
	}
	randspoilero->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilero->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilero->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilero->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilero->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilerp->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerp->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilerp->ac = rn2(36)-15;				/* any AC */
	randspoilerp->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerp->msound = randmonsound();	

	randspoilerp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerp->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilerp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilerp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilerp->mflags2 |= (1 << rn2(31));
	}
	randspoilerp->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilerp->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilerp->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 6; i++) {
		attkptr = &randspoilerq->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = rnd(2);				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+2;				/* either too high or too low */
	}
	randspoilerq->mmove = rn2(25)+12;				/* slow to very fast */
	randspoilerq->ac = rn2(36)-15;				/* any AC */
	randspoilerq->mr = rn2(5)*25;				/* varying amounts of MR */
	randspoilerq->msound = randmonsound();	

	randspoilerq->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	randspoilerq->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	randspoilerq->cnutrit = rnd(2000);					/* see above */

	for (i = 0; i < rnd(8); i++) {
		randspoilerq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(17); i++) {
		randspoilerq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	for (i = 0; i < 6; i++) {
		randspoilerq->mflags2 |= (1 << rn2(31));
	}
	randspoilerq->mflags2 &= ~M2_MERC;				/* no guards */
	randspoilerq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randspoilerq->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	for (i = 0; i < 5; i++) {
		randspoilerq->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randspoilerq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	for (i = 0; i < 2; i++) {
		attkptr = &randfluidator->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
	}
	randfluidator->mmove = rn2(9)+9;				/* slow to very fast */
	randfluidator->ac = rn2(18)-7;				/* any AC */
	randfluidator->mr = rn2(5)*25;				/* varying amounts of MR */
	randfluidator->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randfluidator->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		attkptr = &randfluidatorb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
	}
	randfluidatorb->mmove = rn2(14)+9;				/* slow to very fast */
	randfluidatorb->ac = rn2(31)-20;				/* any AC */
	randfluidatorb->mr = rn2(5)*25;				/* varying amounts of MR */
	randfluidatorb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randfluidatorb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxya->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 4; i++) {
		attkptr = &randxyd->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 3; i++) {
		attkptr = &randxye->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

		attkptr = &randxyf->mattk[1];
		attkptr->adtyp = randxyf->mattk[0].adtyp;


	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyg->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randxyi->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 4; i++) {
		attkptr = &randxyj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyl->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxym->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyn->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyo->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyp->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyq->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyr->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxys->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyt->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxytX->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxytY->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyu->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyv->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randxyw->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 3; i < 4; i++) {
		attkptr = &randxyx->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyy->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 2; i < 3; i++) {
		attkptr = &randxyz->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &randhybrid->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyaa->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randxyab->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randxyac->mattk[i];

		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomsphere->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomlight->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomlightB->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightC->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightD->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightE->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 2; i++) {
		attkptr = &randomlightF->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randomlightG->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &shadowwarrior->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 1; i < 2; i++) {
		attkptr = &shadowwarriorX->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonb->mcolor = rnd(15);
		if (randomdragonb->mcolor == 4) randomdragonb->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonc->mcolor = rnd(15);
		if (randomdragonc->mcolor == 4) randomdragonc->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragond->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragond->mcolor = rnd(15);
		if (randomdragond->mcolor == 4) randomdragond->mcolor = 12;

	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragone->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragone->mcolor = rnd(15);
		if (randomdragone->mcolor == 4) randomdragone->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonf->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonf->mcolor = rnd(15);
		if (randomdragonf->mcolor == 4) randomdragonf->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragong->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragong->mcolor = rnd(15);
		if (randomdragong->mcolor == 4) randomdragong->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonh->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonh->mcolor = rnd(15);
		if (randomdragonh->mcolor == 4) randomdragonh->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragoni->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragoni->mcolor = rnd(15);
		if (randomdragoni->mcolor == 4) randomdragoni->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonj->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonj->mcolor = rnd(15);
		if (randomdragonj->mcolor == 4) randomdragonj->mcolor = 12;
	}

	for (i = 0; i < 1; i++) {
		attkptr = &randomdragonk->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		randomdragonk->mcolor = rnd(15);
		if (randomdragonk->mcolor == 4) randomdragonk->mcolor = 12;
	}

	randombdragonb->mcolor = randomdragonb->mcolor;
	randombdragonc->mcolor = randomdragonc->mcolor;
	randombdragond->mcolor = randomdragond->mcolor;
	randombdragone->mcolor = randomdragone->mcolor;
	randombdragonf->mcolor = randomdragonf->mcolor;
	randombdragong->mcolor = randomdragong->mcolor;
	randombdragonh->mcolor = randomdragonh->mcolor;
	randombdragoni->mcolor = randomdragoni->mcolor;
	randombdragonj->mcolor = randomdragonj->mcolor;
	randombdragonk->mcolor = randomdragonk->mcolor;

	for (i = 0; i < 1; i++) {
		attkptr = &rrandomdragonb->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		rrandomdragonb->mcolor = rnd(15);
		if (rrandomdragonb->mcolor == 4) rrandomdragonb->mcolor = 12;

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomdragonb, buf, sizeof(buf) );
	rrandomdragonb->mname = u.strandomdragonb;

	for (i = 0; i < 1; i++) {
		attkptr = &rrandomdragonc->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = rnd(10);
		}

		rrandomdragonc->mcolor = rnd(15);
		if (rrandomdragonc->mcolor == 4) rrandomdragonc->mcolor = 12;

	}

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomdragonc, buf, sizeof(buf) );
	rrandomdragonc->mname = u.strandomdragonc;

	rrandombdragonb->mcolor = rrandomdragonb->mcolor;
	rrandombdragonc->mcolor = rrandomdragonc->mcolor;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandombdragonb, buf, sizeof(buf) );
	rrandombdragonb->mname = u.strandombdragonb;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandombdragonc, buf, sizeof(buf) );
	rrandombdragonc->mname = u.strandombdragonc;

	for (i = 1; i < 2; i++) {
		attkptr = &randomflyfish->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	for (i = 0; i < 3; i++) {
		attkptr = &randomturret->mattk[i];

		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}

	}

	randomkop->mmove = rn2(10)+9;				/* slow to very fast */
	randomkop->ac = rn2(21)-10;				/* any AC */
	randomkop->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &randomkop->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+2;				/* either too high or too low */
	}
	randomkop->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkop->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkop->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkop->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkop->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkop->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkop->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkop->mflags2 |= (1 << rn2(31));
	}
	randomkop->mflags2 &= ~M2_MERC;				/* no guards */
	randomkop->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkop->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkop->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randomkopb->mmove = rn2(14)+9;				/* slow to very fast */
	randomkopb->ac = rn2(31)-20;				/* any AC */
	randomkopb->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randomkopb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	randomkopb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkopb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkopb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkopb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkopb->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkopb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkopb->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkopb->mflags2 |= (1 << rn2(31));
	}
	randomkopb->mflags2 &= ~M2_MERC;				/* no guards */
	randomkopb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkopb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkopb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	rrandomkopb->mmove = rn2(14)+9;				/* slow to very fast */
	rrandomkopb->ac = rn2(31)-20;				/* any AC */
	rrandomkopb->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &rrandomkopb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+2;				/* either too high or too low */
	}
	rrandomkopb->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		rrandomkopb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		rrandomkopb->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	rrandomkopb->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	rrandomkopb->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		rrandomkopb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	rrandomkopb->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		rrandomkopb->mflags2 |= (1 << rn2(31));
	}
	rrandomkopb->mflags2 &= ~M2_MERC;				/* no guards */
	rrandomkopb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	rrandomkopb->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	rrandomkopb->mflags2 &= ~M2_PNAME;				/* not a proper name */

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.strandomkopb, buf, sizeof(buf) );
	rrandomkopb->mname = u.strandomkopb;

	randomkopc->mmove = rn2(20)+9;				/* slow to very fast */
	randomkopc->ac = rn2(40)-29;				/* any AC */
	randomkopc->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &randomkopc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(24)+2;				/* either too high or too low */
	}
	randomkopc->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		randomkopc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randomkopc->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randomkopc->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randomkopc->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randomkopc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randomkopc->mflags2 = M2_HUMAN|M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randomkopc->mflags2 |= (1 << rn2(31));
	}
	randomkopc->mflags2 &= ~M2_MERC;				/* no guards */
	randomkopc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randomkopc->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randomkopc->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompeji->mmove = rn2(15)+9;				/* slow to very fast */
	randompompeji->ac = rn2(26)-15;				/* any AC */
	randompompeji->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(4); i++) {
		attkptr = &randompompeji->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+2;				/* either too high or too low */
	}
	randompompeji->mresists = 0;
	for (i = 0; i < rnd(8); i++) {
		randompompeji->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompeji->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompeji->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompeji->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompeji->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompeji->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompeji->mflags2 |= (1 << rn2(31));
	}
	randompompeji->mflags2 &= ~M2_MERC;				/* no guards */
	randompompeji->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompeji->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompeji->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompejib->mmove = rn2(20)+9;				/* slow to very fast */
	randompompejib->ac = rn2(41)-30;				/* any AC */
	randompompejib->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < rnd(5); i++) {
		attkptr = &randompompejib->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+2;				/* either too high or too low */
	}
	randompompejib->mresists = 0;
	for (i = 0; i < rnd(10); i++) {
		randompompejib->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompejib->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompejib->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompejib->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompejib->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompejib->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompejib->mflags2 |= (1 << rn2(31));
	}
	randompompejib->mflags2 &= ~M2_MERC;				/* no guards */
	randompompejib->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompejib->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompejib->mflags2 &= ~M2_PNAME;				/* not a proper name */

	randompompejic->mmove = rn2(27)+9;				/* slow to very fast */
	randompompejic->ac = rn2(55)-44;				/* any AC */
	randompompejic->mr = rn2(5)*25;				/* varying amounts of MR */
	/* attacks...?  */
	for (i = 0; i < (rnd(5) + 1); i++) {
		attkptr = &randompompejic->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(32)+2;				/* either too high or too low */
	}
	randompompejic->mresists = 0;
	for (i = 0; i < rnd(12); i++) {
		randompompejic->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		randompompejic->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	randompompejic->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	randompompejic->mflags1 = M1_BREATHLESS|M1_MINDLESS|M1_HUMANOID;
	for (i = 0; i < rnd(17); i++) {
		randompompejic->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randompompejic->mflags2 = M2_STALK|M2_HOSTILE|M2_STRONG|M2_NEUTER|M2_NASTY;		/* Don't let the player be one of these yet. */
	for (i = 0; i < rnd(17); i++) {
		randompompejic->mflags2 |= (1 << rn2(31));
	}
	randompompejic->mflags2 &= ~M2_MERC;				/* no guards */
	randompompejic->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randompompejic->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	randompompejic->mflags2 &= ~M2_PNAME;				/* not a proper name */

	/* Starlit sky monsters are an invention of my roommate. It's a name that she gave to a glitch monster
	 * in Castle of the Winds. --Amy */

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel > 5)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlita->mmove = mons[starlitmonster].mmove;
	starlita->ac = mons[starlitmonster].ac;
	starlita->mr = mons[starlitmonster].mr;
	starlita->maligntyp = mons[starlitmonster].maligntyp;
	starlita->mattk[0] = mons[starlitmonster].mattk[0];
	starlita->mattk[1] = mons[starlitmonster].mattk[1];
	starlita->mattk[2] = mons[starlitmonster].mattk[2];
	starlita->mattk[3] = mons[starlitmonster].mattk[3];
	starlita->mattk[4] = mons[starlitmonster].mattk[4];
	starlita->mattk[5] = mons[starlitmonster].mattk[5];
	starlita->cwt = mons[starlitmonster].cwt;
	starlita->cnutrit = mons[starlitmonster].cnutrit;
	starlita->msound = mons[starlitmonster].msound;
	starlita->msize = mons[starlitmonster].msize;
	starlita->mresists = mons[starlitmonster].mresists;
	starlita->mflags1 = mons[starlitmonster].mflags1;
	starlita->mflags2 = mons[starlitmonster].mflags2;
	starlita->mflags3 = mons[starlitmonster].mflags3;

	starlita->mflags2 &= ~M2_NOPOLY;
	starlita->mflags2 &= ~M2_MERC;
	starlita->mflags2 &= ~M2_WERE;
	starlita->mflags2 &= ~M2_PNAME;
	starlita->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 5) || (mons[starlitmonster].mlevel > 10)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitb->mmove = mons[starlitmonster].mmove;
	starlitb->ac = mons[starlitmonster].ac;
	starlitb->mr = mons[starlitmonster].mr;
	starlitb->maligntyp = mons[starlitmonster].maligntyp;
	starlitb->mattk[0] = mons[starlitmonster].mattk[0];
	starlitb->mattk[1] = mons[starlitmonster].mattk[1];
	starlitb->mattk[2] = mons[starlitmonster].mattk[2];
	starlitb->mattk[3] = mons[starlitmonster].mattk[3];
	starlitb->mattk[4] = mons[starlitmonster].mattk[4];
	starlitb->mattk[5] = mons[starlitmonster].mattk[5];
	starlitb->cwt = mons[starlitmonster].cwt;
	starlitb->cnutrit = mons[starlitmonster].cnutrit;
	starlitb->msound = mons[starlitmonster].msound;
	starlitb->msize = mons[starlitmonster].msize;
	starlitb->mresists = mons[starlitmonster].mresists;
	starlitb->mflags1 = mons[starlitmonster].mflags1;
	starlitb->mflags2 = mons[starlitmonster].mflags2;
	starlitb->mflags3 = mons[starlitmonster].mflags3;

	starlitb->mflags2 &= ~M2_NOPOLY;
	starlitb->mflags2 &= ~M2_MERC;
	starlitb->mflags2 &= ~M2_WERE;
	starlitb->mflags2 &= ~M2_PNAME;
	starlitb->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 10) || (mons[starlitmonster].mlevel > 15)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitc->mmove = mons[starlitmonster].mmove;
	starlitc->ac = mons[starlitmonster].ac;
	starlitc->mr = mons[starlitmonster].mr;
	starlitc->maligntyp = mons[starlitmonster].maligntyp;
	starlitc->mattk[0] = mons[starlitmonster].mattk[0];
	starlitc->mattk[1] = mons[starlitmonster].mattk[1];
	starlitc->mattk[2] = mons[starlitmonster].mattk[2];
	starlitc->mattk[3] = mons[starlitmonster].mattk[3];
	starlitc->mattk[4] = mons[starlitmonster].mattk[4];
	starlitc->mattk[5] = mons[starlitmonster].mattk[5];
	starlitc->cwt = mons[starlitmonster].cwt;
	starlitc->cnutrit = mons[starlitmonster].cnutrit;
	starlitc->msound = mons[starlitmonster].msound;
	starlitc->msize = mons[starlitmonster].msize;
	starlitc->mresists = mons[starlitmonster].mresists;
	starlitc->mflags1 = mons[starlitmonster].mflags1;
	starlitc->mflags2 = mons[starlitmonster].mflags2;
	starlitc->mflags3 = mons[starlitmonster].mflags3;

	starlitc->mflags2 &= ~M2_NOPOLY;
	starlitc->mflags2 &= ~M2_MERC;
	starlitc->mflags2 &= ~M2_WERE;
	starlitc->mflags2 &= ~M2_PNAME;
	starlitc->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 15) || (mons[starlitmonster].mlevel > 20)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitd->mmove = mons[starlitmonster].mmove;
	starlitd->ac = mons[starlitmonster].ac;
	starlitd->mr = mons[starlitmonster].mr;
	starlitd->maligntyp = mons[starlitmonster].maligntyp;
	starlitd->mattk[0] = mons[starlitmonster].mattk[0];
	starlitd->mattk[1] = mons[starlitmonster].mattk[1];
	starlitd->mattk[2] = mons[starlitmonster].mattk[2];
	starlitd->mattk[3] = mons[starlitmonster].mattk[3];
	starlitd->mattk[4] = mons[starlitmonster].mattk[4];
	starlitd->mattk[5] = mons[starlitmonster].mattk[5];
	starlitd->cwt = mons[starlitmonster].cwt;
	starlitd->cnutrit = mons[starlitmonster].cnutrit;
	starlitd->msound = mons[starlitmonster].msound;
	starlitd->msize = mons[starlitmonster].msize;
	starlitd->mresists = mons[starlitmonster].mresists;
	starlitd->mflags1 = mons[starlitmonster].mflags1;
	starlitd->mflags2 = mons[starlitmonster].mflags2;
	starlitd->mflags3 = mons[starlitmonster].mflags3;

	starlitd->mflags2 &= ~M2_NOPOLY;
	starlitd->mflags2 &= ~M2_MERC;
	starlitd->mflags2 &= ~M2_WERE;
	starlitd->mflags2 &= ~M2_PNAME;
	starlitd->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 20) || (mons[starlitmonster].mlevel > 25)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlite->mmove = mons[starlitmonster].mmove;
	starlite->ac = mons[starlitmonster].ac;
	starlite->mr = mons[starlitmonster].mr;
	starlite->maligntyp = mons[starlitmonster].maligntyp;
	starlite->mattk[0] = mons[starlitmonster].mattk[0];
	starlite->mattk[1] = mons[starlitmonster].mattk[1];
	starlite->mattk[2] = mons[starlitmonster].mattk[2];
	starlite->mattk[3] = mons[starlitmonster].mattk[3];
	starlite->mattk[4] = mons[starlitmonster].mattk[4];
	starlite->mattk[5] = mons[starlitmonster].mattk[5];
	starlite->cwt = mons[starlitmonster].cwt;
	starlite->cnutrit = mons[starlitmonster].cnutrit;
	starlite->msound = mons[starlitmonster].msound;
	starlite->msize = mons[starlitmonster].msize;
	starlite->mresists = mons[starlitmonster].mresists;
	starlite->mflags1 = mons[starlitmonster].mflags1;
	starlite->mflags2 = mons[starlitmonster].mflags2;
	starlite->mflags3 = mons[starlitmonster].mflags3;

	starlite->mflags2 &= ~M2_NOPOLY;
	starlite->mflags2 &= ~M2_MERC;
	starlite->mflags2 &= ~M2_WERE;
	starlite->mflags2 &= ~M2_PNAME;
	starlite->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 25) || (mons[starlitmonster].mlevel > 30)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitf->mmove = mons[starlitmonster].mmove;
	starlitf->ac = mons[starlitmonster].ac;
	starlitf->mr = mons[starlitmonster].mr;
	starlitf->maligntyp = mons[starlitmonster].maligntyp;
	starlitf->mattk[0] = mons[starlitmonster].mattk[0];
	starlitf->mattk[1] = mons[starlitmonster].mattk[1];
	starlitf->mattk[2] = mons[starlitmonster].mattk[2];
	starlitf->mattk[3] = mons[starlitmonster].mattk[3];
	starlitf->mattk[4] = mons[starlitmonster].mattk[4];
	starlitf->mattk[5] = mons[starlitmonster].mattk[5];
	starlitf->cwt = mons[starlitmonster].cwt;
	starlitf->cnutrit = mons[starlitmonster].cnutrit;
	starlitf->msound = mons[starlitmonster].msound;
	starlitf->msize = mons[starlitmonster].msize;
	starlitf->mresists = mons[starlitmonster].mresists;
	starlitf->mflags1 = mons[starlitmonster].mflags1;
	starlitf->mflags2 = mons[starlitmonster].mflags2;
	starlitf->mflags3 = mons[starlitmonster].mflags3;

	starlitf->mflags2 &= ~M2_NOPOLY;
	starlitf->mflags2 &= ~M2_MERC;
	starlitf->mflags2 &= ~M2_WERE;
	starlitf->mflags2 &= ~M2_PNAME;
	starlitf->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 30) || (mons[starlitmonster].mlevel > 35)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitg->mmove = mons[starlitmonster].mmove;
	starlitg->ac = mons[starlitmonster].ac;
	starlitg->mr = mons[starlitmonster].mr;
	starlitg->maligntyp = mons[starlitmonster].maligntyp;
	starlitg->mattk[0] = mons[starlitmonster].mattk[0];
	starlitg->mattk[1] = mons[starlitmonster].mattk[1];
	starlitg->mattk[2] = mons[starlitmonster].mattk[2];
	starlitg->mattk[3] = mons[starlitmonster].mattk[3];
	starlitg->mattk[4] = mons[starlitmonster].mattk[4];
	starlitg->mattk[5] = mons[starlitmonster].mattk[5];
	starlitg->cwt = mons[starlitmonster].cwt;
	starlitg->cnutrit = mons[starlitmonster].cnutrit;
	starlitg->msound = mons[starlitmonster].msound;
	starlitg->msize = mons[starlitmonster].msize;
	starlitg->mresists = mons[starlitmonster].mresists;
	starlitg->mflags1 = mons[starlitmonster].mflags1;
	starlitg->mflags2 = mons[starlitmonster].mflags2;
	starlitg->mflags3 = mons[starlitmonster].mflags3;

	starlitg->mflags2 &= ~M2_NOPOLY;
	starlitg->mflags2 &= ~M2_MERC;
	starlitg->mflags2 &= ~M2_WERE;
	starlitg->mflags2 &= ~M2_PNAME;
	starlitg->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 35) || (mons[starlitmonster].mlevel > 40)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlith->mmove = mons[starlitmonster].mmove;
	starlith->ac = mons[starlitmonster].ac;
	starlith->mr = mons[starlitmonster].mr;
	starlith->maligntyp = mons[starlitmonster].maligntyp;
	starlith->mattk[0] = mons[starlitmonster].mattk[0];
	starlith->mattk[1] = mons[starlitmonster].mattk[1];
	starlith->mattk[2] = mons[starlitmonster].mattk[2];
	starlith->mattk[3] = mons[starlitmonster].mattk[3];
	starlith->mattk[4] = mons[starlitmonster].mattk[4];
	starlith->mattk[5] = mons[starlitmonster].mattk[5];
	starlith->cwt = mons[starlitmonster].cwt;
	starlith->cnutrit = mons[starlitmonster].cnutrit;
	starlith->msound = mons[starlitmonster].msound;
	starlith->msize = mons[starlitmonster].msize;
	starlith->mresists = mons[starlitmonster].mresists;
	starlith->mflags1 = mons[starlitmonster].mflags1;
	starlith->mflags2 = mons[starlitmonster].mflags2;
	starlith->mflags3 = mons[starlitmonster].mflags3;

	starlith->mflags2 &= ~M2_NOPOLY;
	starlith->mflags2 &= ~M2_MERC;
	starlith->mflags2 &= ~M2_WERE;
	starlith->mflags2 &= ~M2_PNAME;
	starlith->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 40) || (mons[starlitmonster].mlevel > 50)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starliti->mmove = mons[starlitmonster].mmove;
	starliti->ac = mons[starlitmonster].ac;
	starliti->mr = mons[starlitmonster].mr;
	starliti->maligntyp = mons[starlitmonster].maligntyp;
	starliti->mattk[0] = mons[starlitmonster].mattk[0];
	starliti->mattk[1] = mons[starlitmonster].mattk[1];
	starliti->mattk[2] = mons[starlitmonster].mattk[2];
	starliti->mattk[3] = mons[starlitmonster].mattk[3];
	starliti->mattk[4] = mons[starlitmonster].mattk[4];
	starliti->mattk[5] = mons[starlitmonster].mattk[5];
	starliti->cwt = mons[starlitmonster].cwt;
	starliti->cnutrit = mons[starlitmonster].cnutrit;
	starliti->msound = mons[starlitmonster].msound;
	starliti->msize = mons[starlitmonster].msize;
	starliti->mresists = mons[starlitmonster].mresists;
	starliti->mflags1 = mons[starlitmonster].mflags1;
	starliti->mflags2 = mons[starlitmonster].mflags2;
	starliti->mflags3 = mons[starlitmonster].mflags3;

	starliti->mflags2 &= ~M2_NOPOLY;
	starliti->mflags2 &= ~M2_MERC;
	starliti->mflags2 &= ~M2_WERE;
	starliti->mflags2 &= ~M2_PNAME;
	starliti->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 50) || (mons[starlitmonster].mlevel > 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitj->mmove = mons[starlitmonster].mmove;
	starlitj->ac = mons[starlitmonster].ac;
	starlitj->mr = mons[starlitmonster].mr;
	starlitj->maligntyp = mons[starlitmonster].maligntyp;
	starlitj->mattk[0] = mons[starlitmonster].mattk[0];
	starlitj->mattk[1] = mons[starlitmonster].mattk[1];
	starlitj->mattk[2] = mons[starlitmonster].mattk[2];
	starlitj->mattk[3] = mons[starlitmonster].mattk[3];
	starlitj->mattk[4] = mons[starlitmonster].mattk[4];
	starlitj->mattk[5] = mons[starlitmonster].mattk[5];
	starlitj->cwt = mons[starlitmonster].cwt;
	starlitj->cnutrit = mons[starlitmonster].cnutrit;
	starlitj->msound = mons[starlitmonster].msound;
	starlitj->msize = mons[starlitmonster].msize;
	starlitj->mresists = mons[starlitmonster].mresists;
	starlitj->mflags1 = mons[starlitmonster].mflags1;
	starlitj->mflags2 = mons[starlitmonster].mflags2;
	starlitj->mflags3 = mons[starlitmonster].mflags3;

	starlitj->mflags2 &= ~M2_NOPOLY;
	starlitj->mflags2 &= ~M2_MERC;
	starlitj->mflags2 &= ~M2_WERE;
	starlitj->mflags2 &= ~M2_PNAME;
	starlitj->mflags2 &= ~M2_PEACEFUL;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 50) || (mons[starlitmonster].mlevel > 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitffx->mmove = mons[starlitmonster].mmove;
	starlitffx->ac = mons[starlitmonster].ac;
	starlitffx->mr = mons[starlitmonster].mr;
	starlitffx->maligntyp = mons[starlitmonster].maligntyp;
	starlitffx->mattk[0] = mons[starlitmonster].mattk[0];
	starlitffx->mattk[1] = mons[starlitmonster].mattk[1];
	starlitffx->mattk[2] = mons[starlitmonster].mattk[2];
	starlitffx->mattk[3] = mons[starlitmonster].mattk[3];
	starlitffx->mattk[4] = mons[starlitmonster].mattk[4];
	starlitffx->mattk[5] = mons[starlitmonster].mattk[5];
	starlitffx->cwt = mons[starlitmonster].cwt;
	starlitffx->cnutrit = mons[starlitmonster].cnutrit;
	starlitffx->msound = mons[starlitmonster].msound;
	starlitffx->msize = mons[starlitmonster].msize;
	starlitffx->mresists = mons[starlitmonster].mresists;
	starlitffx->mflags1 = mons[starlitmonster].mflags1;
	starlitffx->mflags2 = mons[starlitmonster].mflags2;
	starlitffx->mflags3 = mons[starlitmonster].mflags3;

	starlitffx->mflags2 &= ~M2_NOPOLY;
	starlitffx->mflags2 &= ~M2_MERC;
	starlitffx->mflags2 &= ~M2_WERE;
	starlitffx->mflags2 &= ~M2_PNAME;
	starlitffx->mflags2 &= ~M2_PEACEFUL;

	starlitffx->mflags3 |= M3_NOPLRPOLY;
	starlitffx->mflags3 |= M3_NOTAME;
	starlitffx->mflags3 |= M3_MIMIC;

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel <= 60)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitk->mmove = mons[starlitmonster].mmove;
	starlitk->ac = mons[starlitmonster].ac;
	starlitk->mr = mons[starlitmonster].mr;
	starlitk->maligntyp = mons[starlitmonster].maligntyp;
	starlitk->mattk[0] = mons[starlitmonster].mattk[0];
	starlitk->mattk[1] = mons[starlitmonster].mattk[1];
	starlitk->mattk[2] = mons[starlitmonster].mattk[2];
	starlitk->mattk[3] = mons[starlitmonster].mattk[3];
	starlitk->mattk[4] = mons[starlitmonster].mattk[4];
	starlitk->mattk[5] = mons[starlitmonster].mattk[5];
	starlitk->cwt = mons[starlitmonster].cwt;
	starlitk->cnutrit = mons[starlitmonster].cnutrit;
	starlitk->msound = mons[starlitmonster].msound;
	starlitk->msize = mons[starlitmonster].msize;
	starlitk->mresists = mons[starlitmonster].mresists;
	starlitk->mflags1 = mons[starlitmonster].mflags1;
	starlitk->mflags2 = mons[starlitmonster].mflags2;
	starlitk->mflags3 = mons[starlitmonster].mflags3;

	starlitk->mflags2 &= ~M2_NOPOLY;
	starlitk->mflags2 &= ~M2_MERC;
	starlitk->mflags2 &= ~M2_WERE;
	starlitk->mflags2 &= ~M2_PNAME;
	starlitk->mflags2 &= ~M2_PEACEFUL;

	/* and a total train wreck... */
	starlitmonster = -1;
	starlitattempts = 0;
	while ((starlitmonster == -1) && starlitattempts < 50000 ) {
		starlitmonster = /*(NUMMONS + rnd(MISSINGNORANGE));*/PM_HUMAN;
		starlitattempts++;
	}

	starlitmonster = -1;
	starlitattempts = 0;
	while (((starlitmonster == -1) || (mons[starlitmonster].mlevel > 5)) && starlitattempts < 50000 ) {
		starlitmonster = rn2(NUMMONS);
		starlitattempts++;
	}

	starlitl->mmove = mons[starlitmonster].mmove;
	starlitl->ac = mons[starlitmonster].ac;
	starlitl->mr = mons[starlitmonster].mr;
	starlitl->maligntyp = mons[starlitmonster].maligntyp;
	starlitl->mattk[0] = mons[starlitmonster].mattk[0];
	starlitl->mattk[1] = mons[starlitmonster].mattk[1];
	starlitl->mattk[2] = mons[starlitmonster].mattk[2];
	starlitl->mattk[3] = mons[starlitmonster].mattk[3];
	starlitl->mattk[4] = mons[starlitmonster].mattk[4];
	starlitl->mattk[5] = mons[starlitmonster].mattk[5];
	starlitl->cwt = mons[starlitmonster].cwt;
	starlitl->cnutrit = mons[starlitmonster].cnutrit;
	starlitl->msound = mons[starlitmonster].msound;
	starlitl->msize = mons[starlitmonster].msize;
	starlitl->mresists = mons[starlitmonster].mresists;
	starlitl->mflags1 = mons[starlitmonster].mflags1;
	starlitl->mflags2 = mons[starlitmonster].mflags2;
	starlitl->mflags3 = mons[starlitmonster].mflags3;

	starlitl->mflags2 &= ~M2_NOPOLY;
	starlitl->mflags2 &= ~M2_MERC;
	starlitl->mflags2 &= ~M2_WERE;
	starlitl->mflags2 &= ~M2_PNAME;
	starlitl->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit1, buf, sizeof(buf) );
	starlitl->mname = u.starlit1;

	starlitm->mmove = mons[starlitmonster].mmove;
	starlitm->ac = mons[starlitmonster].ac;
	starlitm->mr = mons[starlitmonster].mr;
	starlitm->maligntyp = mons[starlitmonster].maligntyp;
	starlitm->mattk[0] = mons[starlitmonster].mattk[0];
	starlitm->mattk[1] = mons[starlitmonster].mattk[1];
	starlitm->mattk[2] = mons[starlitmonster].mattk[2];
	starlitm->mattk[3] = mons[starlitmonster].mattk[3];
	starlitm->mattk[4] = mons[starlitmonster].mattk[4];
	starlitm->mattk[5] = mons[starlitmonster].mattk[5];
	starlitm->cwt = mons[starlitmonster].cwt;
	starlitm->cnutrit = mons[starlitmonster].cnutrit;
	starlitm->msound = mons[starlitmonster].msound;
	starlitm->msize = mons[starlitmonster].msize;
	starlitm->mresists = mons[starlitmonster].mresists;
	starlitm->mflags1 = mons[starlitmonster].mflags1;
	starlitm->mflags2 = mons[starlitmonster].mflags2;
	starlitm->mflags3 = mons[starlitmonster].mflags3;

	starlitm->mflags2 &= ~M2_NOPOLY;
	starlitm->mflags2 &= ~M2_MERC;
	starlitm->mflags2 &= ~M2_WERE;
	starlitm->mflags2 &= ~M2_PNAME;
	starlitm->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit2, buf, sizeof(buf) );
	starlitm->mname = u.starlit2;

	starlitn->mmove = mons[starlitmonster].mmove;
	starlitn->ac = mons[starlitmonster].ac;
	starlitn->mr = mons[starlitmonster].mr;
	starlitn->maligntyp = mons[starlitmonster].maligntyp;
	starlitn->mattk[0] = mons[starlitmonster].mattk[0];
	starlitn->mattk[1] = mons[starlitmonster].mattk[1];
	starlitn->mattk[2] = mons[starlitmonster].mattk[2];
	starlitn->mattk[3] = mons[starlitmonster].mattk[3];
	starlitn->mattk[4] = mons[starlitmonster].mattk[4];
	starlitn->mattk[5] = mons[starlitmonster].mattk[5];
	starlitn->cwt = mons[starlitmonster].cwt;
	starlitn->cnutrit = mons[starlitmonster].cnutrit;
	starlitn->msound = mons[starlitmonster].msound;
	starlitn->msize = mons[starlitmonster].msize;
	starlitn->mresists = mons[starlitmonster].mresists;
	starlitn->mflags1 = mons[starlitmonster].mflags1;
	starlitn->mflags2 = mons[starlitmonster].mflags2;
	starlitn->mflags3 = mons[starlitmonster].mflags3;

	starlitn->mflags2 &= ~M2_NOPOLY;
	starlitn->mflags2 &= ~M2_MERC;
	starlitn->mflags2 &= ~M2_WERE;
	starlitn->mflags2 &= ~M2_PNAME;
	starlitn->mflags2 &= ~M2_PEACEFUL;

	sprintf(buf, "%s", generate_garbage_string() );
	(void) strncpy(u.starlit3, buf, sizeof(buf) );
	starlitn->mname = u.starlit3;

	starlitu->mmove = mons[starlitmonster].mmove;
	starlitu->ac = mons[starlitmonster].ac;
	starlitu->mr = mons[starlitmonster].mr;
	starlitu->maligntyp = mons[starlitmonster].maligntyp;
	starlitu->mattk[0] = mons[starlitmonster].mattk[0];
	starlitu->mattk[1] = mons[starlitmonster].mattk[1];
	starlitu->mattk[2] = mons[starlitmonster].mattk[2];
	starlitu->mattk[3] = mons[starlitmonster].mattk[3];
	starlitu->mattk[4] = mons[starlitmonster].mattk[4];
	starlitu->mattk[5] = mons[starlitmonster].mattk[5];
	starlitu->cwt = mons[starlitmonster].cwt;
	starlitu->cnutrit = mons[starlitmonster].cnutrit;
	starlitu->msound = mons[starlitmonster].msound;
	starlitu->msize = mons[starlitmonster].msize;
	starlitu->mresists = mons[starlitmonster].mresists;
	starlitu->mflags1 = mons[starlitmonster].mflags1;
	starlitu->mflags2 = mons[starlitmonster].mflags2;
	starlitu->mflags3 = mons[starlitmonster].mflags3;

	starlitu->mflags2 &= ~M2_NOPOLY;
	starlitu->mflags2 &= ~M2_MERC;
	starlitu->mflags2 &= ~M2_WERE;
	starlitu->mflags2 &= ~M2_PNAME;
	starlitu->mflags2 &= ~M2_PEACEFUL;

	starlitu->mflags3 |= 0x40000000L;
	starlitu->mflags3 |= 0x80000000L;

	starlitattempts = 0;

	ptr = rndmonst();
polyinitredoX:
	do {
		ptr = rndmonst();
		starlitattempts++;
	} while (!ptr && starlitattempts < 50000);

	if (ptr) {
		starlitmonster = monsndx(ptr);

		if ( (!attacktype(&mons[starlitmonster], AT_WEAP) && rn2(10)) || (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) ) goto polyinitredoX;

		polyinitor->mmove = mons[starlitmonster].mmove;
		polyinitor->ac = mons[starlitmonster].ac;
		polyinitor->mr = mons[starlitmonster].mr;
		polyinitor->maligntyp = mons[starlitmonster].maligntyp;
		polyinitor->mattk[0] = mons[starlitmonster].mattk[0];
		polyinitor->mattk[1] = mons[starlitmonster].mattk[1];
		polyinitor->mattk[2] = mons[starlitmonster].mattk[2];
		polyinitor->mattk[3] = mons[starlitmonster].mattk[3];
		polyinitor->mattk[4] = mons[starlitmonster].mattk[4];
		polyinitor->mattk[5] = mons[starlitmonster].mattk[5];
		polyinitor->cwt = mons[starlitmonster].cwt;
		polyinitor->cnutrit = mons[starlitmonster].cnutrit;
		polyinitor->msound = mons[starlitmonster].msound;
		polyinitor->msize = mons[starlitmonster].msize;
		polyinitor->mresists = mons[starlitmonster].mresists;
		polyinitor->mflags1 = mons[starlitmonster].mflags1;
		polyinitor->mflags2 = mons[starlitmonster].mflags2;
		polyinitor->mflags3 = mons[starlitmonster].mflags3;

		polyinitor->mflags2 &= ~M2_NOPOLY;
		polyinitor->mflags2 &= ~M2_MERC;
		polyinitor->mflags2 &= ~M2_WERE;
		polyinitor->mflags2 &= ~M2_PNAME;
		polyinitor->mflags2 &= ~M2_PEACEFUL;

		polyinitor->mflags3 |= 0x40000000L;
		polyinitor->mflags3 |= 0x80000000L;
	}

	starlitmonster = rn2(NUMMONS);
	do {
		starlitmonster = rn2(NUMMONS);
	} while ( (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) );

	destabilizer->mmove = mons[starlitmonster].mmove;
	destabilizer->ac = mons[starlitmonster].ac;
	destabilizer->mr = mons[starlitmonster].mr;
	destabilizer->maligntyp = mons[starlitmonster].maligntyp;
	destabilizer->mattk[0] = mons[starlitmonster].mattk[0];
	destabilizer->mattk[1] = mons[starlitmonster].mattk[1];
	destabilizer->mattk[2] = mons[starlitmonster].mattk[2];
	destabilizer->mattk[3] = mons[starlitmonster].mattk[3];
	destabilizer->mattk[4] = mons[starlitmonster].mattk[4];
	destabilizer->mattk[5] = mons[starlitmonster].mattk[5];
	destabilizer->cwt = mons[starlitmonster].cwt;
	destabilizer->cnutrit = mons[starlitmonster].cnutrit;
	destabilizer->msound = mons[starlitmonster].msound;
	destabilizer->msize = mons[starlitmonster].msize;
	destabilizer->mresists = mons[starlitmonster].mresists;
	destabilizer->mflags1 = mons[starlitmonster].mflags1;
	destabilizer->mflags2 = mons[starlitmonster].mflags2;
	destabilizer->mflags3 = mons[starlitmonster].mflags3;

	destabilizer->mflags2 &= ~M2_NOPOLY;
	destabilizer->mflags2 &= ~M2_MERC;
	destabilizer->mflags2 &= ~M2_WERE;
	destabilizer->mflags2 &= ~M2_PNAME;
	destabilizer->mflags2 &= ~M2_PEACEFUL;

	destabilizer->mflags3 |= 0x40000000L;
	destabilizer->mflags3 |= 0x80000000L;

	/* idea by BarclayII: on-the-fly generation of a missingno */

	starlitv->mname = "ethereal missingno";

	starlitv->mmove = rn2(256);
	starlitv->ac = rn2(256);
	starlitv->mr = rn2(256);
	starlitv->maligntyp = rn2(256);

	attkptr = &starlitv->mattk[0];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[1];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[2];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[3];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[4];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);
	attkptr = &starlitv->mattk[5];
	attkptr->aatyp = rn2(256);
	attkptr->adtyp = rn2(256);
	attkptr->damn = rn2(256);
	attkptr->damd = rn2(256);

	starlitv->cwt = rn2(32768);
	starlitv->cnutrit = rn2(32768);
	starlitv->msound = rn2(256);
	starlitv->mresists = rn2(1073741824);
	starlitv->mconveys = rn2(32768);
	starlitv->mflags1 = rn2(1073741824);
	starlitv->mflags2 = rn2(1073741824);
	starlitv->mflags3 = rn2(1073741824);

	if (rn2(2)) starlitv->mresists |= 0x80000000L;
	if (rn2(2)) starlitv->mflags1 |= 0x80000000L;
	if (rn2(2)) starlitv->mflags2 |= 0x80000000L;

	starlitv->mflags2 &= ~M2_NOPOLY;
	starlitv->mflags2 &= ~M2_MERC;
	starlitv->mflags2 &= ~M2_WERE;
	starlitv->mflags2 &= ~M2_PNAME;
	starlitv->mflags2 &= ~M2_PEACEFUL;

	starlitv->mflags3 |= 0x20000000L;
	starlitv->mflags3 |= 0x40000000L;
	starlitv->mflags3 |= 0x80000000L;

	randbossa->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossa->ac = 10 - rn2(16);				/* any AC */
	randbossa->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossa->mflags2 |= (1 << rn2(31));
	}
	randbossa->mflags2 &= ~M2_MERC;				/* no guards */
	randbossa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossa->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossb->mmove = 9 + rn2(4);				/* slow to very fast */
	randbossb->ac = 10 - rn2(6);				/* any AC */
	randbossb->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossb->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossb->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossb->mflags2 |= (1 << rn2(31));
	}
	randbossb->mflags2 &= ~M2_MERC;				/* no guards */
	randbossb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossb->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossc->mmove = 12 + rn2(8);				/* slow to very fast */
	randbossc->ac = 10 - rn2(10);				/* any AC */
	randbossc->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossc->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossc->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossc->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossc->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossc->mflags2 |= (1 << rn2(31));
	}
	randbossc->mflags2 &= ~M2_MERC;				/* no guards */
	randbossc->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossc->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossc->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossc->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossd->mmove = 10 + rn2(3);				/* slow to very fast */
	randbossd->ac = 10 - rn2(14);				/* any AC */
	randbossd->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossd->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossd->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossd->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randbosse->mmove = 15 + rn2(10);				/* slow to very fast */
	randbosse->ac = 10 - rn2(11);				/* any AC */
	randbosse->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosse->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbosse->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosse->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosse->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbosse->mflags2 |= (1 << rn2(31));
	}
	randbosse->mflags2 &= ~M2_MERC;				/* no guards */
	randbosse->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbosse->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbosse->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosse->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossf->mmove = 12 + rn2(7);				/* slow to very fast */
	randbossf->ac = 10 - rn2(15);				/* any AC */
	randbossf->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossg->mmove = 12 + rn2(5);				/* slow to very fast */
	randbossg->ac = 10 - rn2(14);				/* any AC */
	randbossg->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossg->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossg->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossg->mflags2 |= (1 << rn2(31));
	}
	randbossg->mflags2 &= ~M2_MERC;				/* no guards */
	randbossg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossg->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossh->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossh->ac = 10 - rn2(16);				/* any AC */
	randbossh->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossh->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossh->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossh->mflags2 |= (1 << rn2(31));
	}
	randbossh->mflags2 &= ~M2_MERC;				/* no guards */
	randbossh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossh->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossh->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossh->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossi->mmove = 14 + rn2(5);				/* slow to very fast */
	randbossi->ac = 10 - rn2(16);				/* any AC */
	randbossi->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossi->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossi->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 3; i++) {
		randbossi->mflags2 |= (1 << rn2(31));
	}
	randbossi->mflags2 &= ~M2_MERC;				/* no guards */
	randbossi->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossi->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossj->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossj->ac = 10 - rn2(13);				/* any AC */
	randbossj->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossj->mflags2 |= (1 << rn2(31));
	}
	randbossj->mflags2 &= ~M2_MERC;				/* no guards */
	randbossj->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossj->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossk->mmove = 12;				/* slow to very fast */
	randbossk->ac = 10 - rn2(17);				/* any AC */
	randbossk->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossk->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossk->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossk->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbossk->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossk->mflags2 |= (1 << rn2(31));
	}
	randbossk->mflags2 &= ~M2_MERC;				/* no guards */
	randbossk->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossk->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossk->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossk->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossl->mmove = 15 + rn2(6);				/* slow to very fast */
	randbossl->ac = 10 - rn2(15);				/* any AC */
	randbossl->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossl->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(19)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossl->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(19)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossl->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbossl->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossm->mmove = 15 + rn2(9);				/* slow to very fast */
	randbossm->ac = 10 - rn2(12);				/* any AC */
	randbossm->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossm->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossm->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossm->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randbossn->mmove = 12 + rn2(2);				/* slow to very fast */
	randbossn->ac = 10 - rn2(21);				/* any AC */
	randbossn->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossn->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(25)+1;				/* either too high or too low */
	}

	for (i = 2; i < 6; i++) {
		attkptr = &randbossn->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(25)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossn->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossn->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossn->mflags2 |= (1 << rn2(31));
	}
	randbossn->mflags2 &= ~M2_MERC;				/* no guards */
	randbossn->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossn->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossn->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossn->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbosso->mmove = 14 + rn2(3);				/* slow to very fast */
	randbosso->ac = 10 - rn2(16);				/* any AC */
	randbosso->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosso->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbosso->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(22)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosso->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 5; i++) {
		randbosso->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbosso->mflags2 |= (1 << rn2(31));
	}
	randbosso->mflags2 &= ~M2_MERC;				/* no guards */
	randbosso->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbosso->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbosso->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosso->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossp->mmove = 15 + rn2(11);				/* slow to very fast */
	randbossp->ac = 10 - rn2(7);				/* any AC */
	randbossp->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossp->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossp->mflags2 |= (1 << rn2(31));
	}
	randbossp->mflags2 &= ~M2_MERC;				/* no guards */
	randbossp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossp->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossq->mmove = 12 + rn2(6);				/* slow to very fast */
	randbossq->ac = 10 - rn2(11);				/* any AC */
	randbossq->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossr->mmove = 12 + rn2(5);				/* slow to very fast */
	randbossr->ac = 10 - rn2(9);				/* any AC */
	randbossr->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossr->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossr->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossr->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbosss->mmove = 15 + rn2(5);				/* slow to very fast */
	randbosss->ac = 10 - rn2(16);				/* any AC */
	randbosss->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosss->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbosss->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbosss->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosss->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbosss->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbosst->mmove = 10 + rn2(4);				/* slow to very fast */
	randbosst->ac = 10 - rn2(16);				/* any AC */
	randbosst->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbosst->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbosst->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbosst->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbosst->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossu->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossu->ac = 10 - rn2(8);				/* any AC */
	randbossu->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossu->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossu->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossu->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossu->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossu->mflags2 |= (1 << rn2(31));
	}
	randbossu->mflags2 &= ~M2_MERC;				/* no guards */
	randbossu->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossu->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossv->mmove = 15 + rn2(7);				/* slow to very fast */
	randbossv->ac = 10 - rn2(6);				/* any AC */
	randbossv->mr = rn2(16);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossv->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossv->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossv->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossv->mflags2 |= (1 << rn2(31));
	}
	randbossv->mflags2 &= ~M2_MERC;				/* no guards */
	randbossv->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossv->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossw->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossw->ac = 10 - rn2(12);				/* any AC */
	randbossw->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossw->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossw->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossw->mflags2 |= (1 << rn2(31));
	}
	randbossw->mflags2 &= ~M2_MERC;				/* no guards */
	randbossw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossw->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossx->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossx->ac = 10 - rn2(13);				/* any AC */
	randbossx->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossx->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossx->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossx->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossx->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossx->mflags2 |= (1 << rn2(31));
	}
	randbossx->mflags2 &= ~M2_MERC;				/* no guards */
	randbossx->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossx->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossy->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossy->ac = 10 - rn2(12);				/* any AC */
	randbossy->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossy->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossy->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossy->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossy->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossz->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossz->ac = 10 - rn2(17);				/* any AC */
	randbossz->mr = rn2(76);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossz->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossz->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossz->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossz->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossz->mflags2 |= (1 << rn2(31));
	}
	randbossz->mflags2 &= ~M2_MERC;				/* no guards */
	randbossz->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossz->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossz->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossz->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaa->mmove = 12 + rn2(4);				/* slow to very fast */
	randbossaa->ac = 10 - rn2(18);				/* any AC */
	randbossaa->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossaa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossaa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossaa->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossaa->mflags2 |= (1 << rn2(31));
	}
	randbossaa->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaa->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaa->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossaa->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossaa->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossab->mmove = 13 + rn2(6);				/* slow to very fast */
	randbossab->ac = 10 - rn2(13);				/* any AC */
	randbossab->mr = rn2(91);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossab->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossab->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randbossab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossab->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossac->mmove = 10 + rn2(3);				/* slow to very fast */
	randbossac->ac = 10 - rn2(11);				/* any AC */
	randbossac->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossac->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossac->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossac->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossac->mflags2 |= (1 << rn2(31));
	}
	randbossac->mflags2 &= ~M2_MERC;				/* no guards */
	randbossac->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossac->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossad->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossad->ac = 10 - rn2(15);				/* any AC */
	randbossad->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossad->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossad->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossad->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossad->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossad->mflags2 |= (1 << rn2(31));
	}
	randbossad->mflags2 &= ~M2_MERC;				/* no guards */
	randbossad->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossad->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossae->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossae->ac = 10 - rn2(9);				/* any AC */
	randbossae->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossae->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossaf->mmove = 13 + rn2(4);				/* slow to very fast */
	randbossaf->ac = 10 - rn2(13);				/* any AC */
	randbossaf->mr = rn2(96);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randbossaf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossaf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossag->mmove = 15 + rn2(4);				/* slow to very fast */
	randbossag->ac = 10 - rn2(10);				/* any AC */
	randbossag->mr = rn2(101);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossag->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossag->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossag->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossag->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossah->mmove = 13 + rn2(3);				/* slow to very fast */
	randbossah->ac = 10 - rn2(17);				/* any AC */
	randbossah->mr = rn2(21);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossah->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossah->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossah->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossah->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossai->mmove = 10 + rn2(2);				/* slow to very fast */
	randbossai->ac = 10 - rn2(21);				/* any AC */
	randbossai->mr = rn2(21);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossai->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(35)+1;				/* either too high or too low */
	}

	for (i = 2; i < 6; i++) {
		attkptr = &randbossai->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(35)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossai->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 7; i++) {
		randbossai->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossai->mflags2 |= (1 << rn2(31));
	}
	randbossai->mflags2 &= ~M2_MERC;				/* no guards */
	randbossai->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossai->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randbossai->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossai->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaj->mmove = 11 + rn2(4);				/* slow to very fast */
	randbossaj->ac = 10 - rn2(11);				/* any AC */
	randbossaj->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossaj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossaj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossak->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossak->ac = 10 - rn2(9);				/* any AC */
	randbossak->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossak->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossak->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossak->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossal->mmove = 13 + rn2(3);				/* slow to very fast */
	randbossal->ac = 10 - rn2(9);				/* any AC */
	randbossal->mr = rn2(16);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossal->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossal->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randbossal->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 6; i++) {
		randbossal->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossal->mflags2 |= (1 << rn2(31));
	}
	randbossal->mflags2 &= ~M2_MERC;				/* no guards */
	randbossal->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossal->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossal->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossal->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossam->mmove = 15 + rn2(5);				/* slow to very fast */
	randbossam->ac = 10 - rn2(15);				/* any AC */
	randbossam->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossam->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randbossam->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(18)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossam->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 4; i++) {
		randbossam->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossam->mflags2 |= (1 << rn2(31));
	}
	randbossam->mflags2 &= ~M2_MERC;				/* no guards */
	randbossam->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossam->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossan->mmove = 18 + rn2(8);				/* slow to very fast */
	randbossan->ac = 10 - rn2(19);				/* any AC */
	randbossan->mr = rn2(41);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossan->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 2; i < 2; i++) {
		attkptr = &randbossan->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossan->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossao->mmove = 8 + rn2(3);				/* slow to very fast */
	randbossao->ac = 10 - rn2(15);				/* any AC */
	randbossao->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossao->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossao->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossao->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 6; i++) {
		randbossao->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossao->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossao->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossap->mmove = 12;				/* slow to very fast */
	randbossap->ac = 10 - rn2(11);				/* any AC */
	randbossap->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossap->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randbossap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 10; i++) {
		randbossap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossap->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossap->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossaq->mmove = 16 + rn2(5);				/* slow to very fast */
	randbossaq->ac = 10 - rn2(3);				/* any AC */
	randbossaq->mr = rn2(11);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossaq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossaq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossaq->mflags2 |= (1 << rn2(31));
	}
	randbossaq->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossar->mmove = 15 + rn2(3);				/* slow to very fast */
	randbossar->ac = 10 - rn2(5);				/* any AC */
	randbossar->mr = 0;				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossar->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossar->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossar->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossas->mmove = 14 + rn2(3);				/* slow to very fast */
	randbossas->ac = 10 - rn2(6);				/* any AC */
	randbossas->mr = rn2(6);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossas->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossas->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randbossas->mflags2 |= (1 << rn2(31));
	}
	randbossas->mflags2 &= ~M2_MERC;				/* no guards */
	randbossas->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossas->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossat->mmove = 11 + rn2(3);				/* slow to very fast */
	randbossat->ac = 10 - rn2(15);				/* any AC */
	randbossat->mr = rn2(61);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossat->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(17)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossat->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(17)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossat->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossat->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 5; i++) {
		randbossat->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossat->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossau->mmove = 12 + rn2(3);				/* slow to very fast */
	randbossau->ac = 10 - rn2(10);				/* any AC */
	randbossau->mr = rn2(51);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossau->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossau->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randbossau->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randbossau->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossau->mflags2 |= (1 << rn2(31));
	}
	randbossau->mflags2 &= ~M2_MERC;				/* no guards */
	randbossau->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossau->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossau->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossau->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randbossav->mmove = 15 + rn2(5);				/* slow to very fast */
	randbossav->ac = 10 - rn2(5);				/* any AC */
	randbossav->mr = rn2(71);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossav->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randbossav->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossav->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossav->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randbossaw->mmove = 15 + rn2(4);				/* slow to very fast */
	randbossaw->ac = 10 - rn2(7);				/* any AC */
	randbossaw->mr = rn2(3);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossaw->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 5; i++) {
		attkptr = &randbossaw->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randbossaw->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randbossaw->mflags2 |= (1 << rn2(31));
	}
	randbossaw->mflags2 &= ~M2_MERC;				/* no guards */
	randbossaw->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossaw->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randbossax->mmove = 12 + rn2(7);				/* slow to very fast */
	randbossax->ac = 10 - rn2(15);				/* any AC */
	randbossax->mr = rn2(81);				/* varying amounts of MR */

	for (i = 0; i < 2; i++) {
		attkptr = &randbossax->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randbossax->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randbossax->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randbossax->mflags2 |= (1 << rn2(31));
	}
	randbossax->mflags2 &= ~M2_MERC;				/* no guards */
	randbossax->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randbossax->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randbossax->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randbossax->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwea->mmove = 12 + rn2(2);				/* slow to very fast */
	randfwea->ac = 10 - rn2(11);				/* any AC */
	randfwea->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwea->geno |= G_SGROUP;
	else if (!rn2(200)) randfwea->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwea->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwea->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwea->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwea->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwea->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweb->mmove = 12 + rn2(8);				/* slow to very fast */
	randfweb->ac = 10 - rn2(17);				/* any AC */
	randfweb->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfweb->geno |= G_SGROUP;
	else if (!rn2(200)) randfweb->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweb->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweb->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randfweb->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweb->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweb->mflags2 |= (1 << rn2(31));
	}
	randfweb->mflags2 &= ~M2_MERC;				/* no guards */
	randfweb->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweb->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweb->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweb->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwec->mmove = 15 + rn2(4);				/* slow to very fast */
	randfwec->ac = 10 - rn2(13);				/* any AC */
	randfwec->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwec->geno |= G_SGROUP;
	else if (!rn2(200)) randfwec->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwec->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwec->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfwec->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	randfwed->mmove = 10 + rn2(3);				/* slow to very fast */
	randfwed->ac = 10 - rn2(16);				/* any AC */
	randfwed->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwed->geno |= G_SGROUP;
	else if (!rn2(200)) randfwed->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwed->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwed->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwed->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfwee->mmove = 12 + rn2(3);				/* slow to very fast */
	randfwee->ac = 10 - rn2(10);				/* any AC */
	randfwee->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfwee->geno |= G_SGROUP;
	else if (!rn2(200)) randfwee->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwee->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwee->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwee->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwee->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwef->mmove = 13 + rn2(3);				/* slow to very fast */
	randfwef->ac = 10 - rn2(11);				/* any AC */
	randfwef->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwef->geno |= G_SGROUP;
	else if (!rn2(200)) randfwef->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwef->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwef->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwef->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwef->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwef->mflags2 |= (1 << rn2(31));
	}
	randfwef->mflags2 &= ~M2_MERC;				/* no guards */
	randfwef->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwef->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwef->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwef->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweg->mmove = 13 + rn2(5);				/* slow to very fast */
	randfweg->ac = 10 - rn2(12);				/* any AC */
	randfweg->mr = rn2(76);				/* varying amounts of MR */

	if (!rn2(20)) randfweg->geno |= G_SGROUP;
	else if (!rn2(200)) randfweg->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweg->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweg->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweg->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfweg->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweg->mflags2 |= (1 << rn2(31));
	}
	randfweg->mflags2 &= ~M2_MERC;				/* no guards */
	randfweg->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweg->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweh->mmove = 12 + rn2(5);				/* slow to very fast */
	randfweh->ac = 10 - rn2(14);				/* any AC */
	randfweh->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweh->geno |= G_SGROUP;
	else if (!rn2(200)) randfweh->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweh->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweh->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweh->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweh->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweh->mflags2 |= (1 << rn2(31));
	}
	randfweh->mflags2 &= ~M2_MERC;				/* no guards */
	randfweh->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweh->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfweh->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweh->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwei->mmove = 15 + rn2(5);				/* slow to very fast */
	randfwei->ac = 10 - rn2(15);				/* any AC */
	randfwei->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfwei->geno |= G_SGROUP;
	else if (!rn2(200)) randfwei->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwei->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwei->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwei->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwei->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwei->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwej->mmove = 15 + rn2(10);				/* slow to very fast */
	randfwej->ac = 10 - rn2(5);				/* any AC */
	randfwej->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfwej->geno |= G_SGROUP;
	else if (!rn2(200)) randfwej->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwej->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwej->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfwej->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwej->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwej->mflags2 |= (1 << rn2(31));
	}
	randfwej->mflags2 &= ~M2_MERC;				/* no guards */
	randfwej->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwej->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfwek->mmove = 13 + rn2(11);				/* slow to very fast */
	randfwek->ac = 10 - rn2(15);				/* any AC */
	randfwek->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfwek->geno |= G_SGROUP;
	else if (!rn2(200)) randfwek->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwek->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwek->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwek->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(16)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfwek->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwek->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwek->mflags2 |= (1 << rn2(31));
	}
	randfwek->mflags2 &= ~M2_MERC;				/* no guards */
	randfwek->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwek->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfwel->mmove = 11 + rn2(3);				/* slow to very fast */
	randfwel->ac = 10 - rn2(15);				/* any AC */
	randfwel->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfwel->geno |= G_SGROUP;
	else if (!rn2(200)) randfwel->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwel->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwel->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(20)+1;				/* either too high or too low */
	}

	for (i = 0; i < 5; i++) {
		randfwel->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfwel->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfwel->mflags2 |= (1 << rn2(31));
	}
	randfwel->mflags2 &= ~M2_MERC;				/* no guards */
	randfwel->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwel->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 4; i++) {
		randfwel->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwel->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwem->mmove = 16 + rn2(10);				/* slow to very fast */
	randfwem->ac = 10 - rn2(6);				/* any AC */
	randfwem->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfwem->geno |= G_SGROUP;
	else if (!rn2(200)) randfwem->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwem->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwem->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfwem->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfwem->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwem->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwen->mmove = 16 + rn2(5);				/* slow to very fast */
	randfwen->ac = 10 - rn2(13);				/* any AC */
	randfwen->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwen->geno |= G_SGROUP;
	else if (!rn2(200)) randfwen->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwen->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwen->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwen->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwen->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwen->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwen->mflags2 |= (1 << rn2(31));
	}
	randfwen->mflags2 &= ~M2_MERC;				/* no guards */
	randfwen->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwen->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfwen->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwen->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweo->mmove = 18 + rn2(8);				/* slow to very fast */
	randfweo->ac = 10 - rn2(7);				/* any AC */
	randfweo->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweo->geno |= G_SGROUP;
	else if (!rn2(200)) randfweo->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweo->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweo->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweo->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweo->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweo->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweo->mflags2 |= (1 << rn2(31));
	}
	randfweo->mflags2 &= ~M2_MERC;				/* no guards */
	randfweo->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweo->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweo->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweo->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwep->mmove = 6 + rn2(7);				/* slow to very fast */
	randfwep->ac = 10 - rn2(21);				/* any AC */
	randfwep->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfwep->geno |= G_SGROUP;
	else if (!rn2(200)) randfwep->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwep->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwep->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwep->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfweq->mmove = 16 + rn2(15);				/* slow to very fast */
	randfweq->ac = 10 - rn2(15);				/* any AC */
	randfweq->mr = rn2(11);				/* varying amounts of MR */

	if (!rn2(20)) randfweq->geno |= G_SGROUP;
	else if (!rn2(200)) randfweq->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweq->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 1; i < 3; i++) {
		attkptr = &randfweq->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 3; i++) {
		randfweq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweq->mflags2 |= (1 << rn2(31));
	}
	randfweq->mflags2 &= ~M2_MERC;				/* no guards */
	randfweq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweq->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwer->mmove = 12 + rn2(5);				/* slow to very fast */
	randfwer->ac = 10 - rn2(11);				/* any AC */
	randfwer->mr = rn2(31);				/* varying amounts of MR */

	if (!rn2(20)) randfwer->geno |= G_SGROUP;
	else if (!rn2(200)) randfwer->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwer->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwer->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwer->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(6)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwer->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwer->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwes->mmove = 10 + rn2(6);				/* slow to very fast */
	randfwes->ac = 10 - rn2(16);				/* any AC */
	randfwes->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwes->geno |= G_SGROUP;
	else if (!rn2(200)) randfwes->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwes->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwes->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwes->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwes->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwes->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwes->mflags2 |= (1 << rn2(31));
	}
	randfwes->mflags2 &= ~M2_MERC;				/* no guards */
	randfwes->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwes->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwes->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwes->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwet->mmove = 10 + rn2(9);				/* slow to very fast */
	randfwet->ac = 10 - rn2(15);				/* any AC */
	randfwet->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfwet->geno |= G_SGROUP;
	else if (!rn2(200)) randfwet->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwet->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwet->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(11)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwet->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwet->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwet->mflags2 |= (1 << rn2(31));
	}
	randfwet->mflags2 &= ~M2_MERC;				/* no guards */
	randfwet->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwet->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweu->mmove = 15 + rn2(5);				/* slow to very fast */
	randfweu->ac = 10 - rn2(5);				/* any AC */
	randfweu->mr = rn2(21);				/* varying amounts of MR */

	if (!rn2(20)) randfweu->geno |= G_SGROUP;
	else if (!rn2(200)) randfweu->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweu->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweu->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweu->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweu->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwev->mmove = 15 + rn2(5);				/* slow to very fast */
	randfwev->ac = 10 - rn2(11);				/* any AC */
	randfwev->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfwev->geno |= G_SGROUP;
	else if (!rn2(200)) randfwev->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwev->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwev->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwev->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwev->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 4; i++) {
		randfwev->mflags2 |= (1 << rn2(31));
	}
	randfwev->mflags2 &= ~M2_MERC;				/* no guards */
	randfwev->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwev->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfwev->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwev->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwew->mmove = 12 + rn2(3);				/* slow to very fast */
	randfwew->ac = 10 - rn2(12);				/* any AC */
	randfwew->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfwew->geno |= G_SGROUP;
	else if (!rn2(200)) randfwew->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwew->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwew->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(13)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwew->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwew->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwex->mmove = 11 + rn2(5);				/* slow to very fast */
	randfwex->ac = 10 - rn2(17);				/* any AC */
	randfwex->mr = rn2(66);				/* varying amounts of MR */

	if (!rn2(20)) randfwex->geno |= G_SGROUP;
	else if (!rn2(200)) randfwex->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwex->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwex->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwex->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwex->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwey->mmove = 12 + rn2(4);				/* slow to very fast */
	randfwey->ac = 10 - rn2(15);				/* any AC */
	randfwey->mr = rn2(31);				/* varying amounts of MR */

	if (!rn2(20)) randfwey->geno |= G_SGROUP;
	else if (!rn2(200)) randfwey->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwey->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwey->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfwey->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwey->mflags2 |= (1 << rn2(31));
	}
	randfwey->mflags2 &= ~M2_MERC;				/* no guards */
	randfwey->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwey->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfwey->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfwey->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfwez->mmove = 15 + rn2(8);				/* slow to very fast */
	randfwez->ac = 10 - rn2(6);				/* any AC */
	randfwez->mr = rn2(11);				/* varying amounts of MR */

	if (!rn2(20)) randfwez->geno |= G_SGROUP;
	else if (!rn2(200)) randfwez->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwez->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwez->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfwez->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwez->mflags2 |= (1 << rn2(31));
	}
	randfwez->mflags2 &= ~M2_MERC;				/* no guards */
	randfwez->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwez->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaa->mmove = 14 + rn2(3);				/* slow to very fast */
	randfweaa->ac = 10 - rn2(14);				/* any AC */
	randfweaa->mr = rn2(66);				/* varying amounts of MR */

	if (!rn2(20)) randfweaa->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaa->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaa->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaa->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweaa->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweaa->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaa->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweaa->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweab->mmove = 12 + rn2(2);				/* slow to very fast */
	randfweab->ac = 10 - rn2(13);				/* any AC */
	randfweab->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweab->geno |= G_SGROUP;
	else if (!rn2(200)) randfweab->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweab->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweab->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(12)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweab->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	randfweac->mmove = 11 + rn2(3);				/* slow to very fast */
	randfweac->ac = 10 - rn2(13);				/* any AC */
	randfweac->mr = rn2(36);				/* varying amounts of MR */

	if (!rn2(20)) randfweac->geno |= G_SGROUP;
	else if (!rn2(200)) randfweac->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweac->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweac->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(21)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweac->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwead->mmove = 14 + rn2(3);				/* slow to very fast */
	randfwead->ac = 10 - rn2(7);				/* any AC */
	randfwead->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfwead->geno |= G_SGROUP;
	else if (!rn2(200)) randfwead->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwead->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfwead->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(3)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfwead->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfwead->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweae->mmove = 15 + rn2(5);				/* slow to very fast */
	randfweae->ac = 10 - rn2(9);				/* any AC */
	randfweae->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweae->geno |= G_SGROUP;
	else if (!rn2(200)) randfweae->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweae->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweae->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 2; i < 3; i++) {
		attkptr = &randfweae->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(5)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweae->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweae->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweaf->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweaf->ac = 10 - rn2(4);				/* any AC */
	randfweaf->mr = rn2(101);				/* varying amounts of MR */

	if (!rn2(20)) randfweaf->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaf->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaf->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweaf->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweaf->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(4)+1;				/* either too high or too low */
	}

	for (i = 0; i < 6; i++) {
		randfweaf->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaf->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweag->mmove = 12 + rn2(4);				/* slow to very fast */
	randfweag->ac = 10 - rn2(9);				/* any AC */
	randfweag->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfweag->geno |= G_SGROUP;
	else if (!rn2(200)) randfweag->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweag->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweag->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(11)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweag->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweag->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweag->mflags2 |= (1 << rn2(31));
	}
	randfweag->mflags2 &= ~M2_MERC;				/* no guards */
	randfweag->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweag->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweah->mmove = 14 + rn2(4);				/* slow to very fast */
	randfweah->ac = 10 - rn2(11);				/* any AC */
	randfweah->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweah->geno |= G_SGROUP;
	else if (!rn2(200)) randfweah->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweah->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweah->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweah->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(9)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweah->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweah->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweah->mflags2 |= (1 << rn2(31));
	}
	randfweah->mflags2 &= ~M2_MERC;				/* no guards */
	randfweah->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweah->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 1; i++) {
		randfweah->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweah->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweai->mmove = 15 + rn2(6);				/* slow to very fast */
	randfweai->ac = 10 - rn2(13);				/* any AC */
	randfweai->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweai->geno |= G_SGROUP;
	else if (!rn2(200)) randfweai->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweai->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweai->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweai->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(14)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweai->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweai->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweai->mflags2 |= (1 << rn2(31));
	}
	randfweai->mflags2 &= ~M2_MERC;				/* no guards */
	randfweai->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweai->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaj->mmove = 13 + rn2(4);				/* slow to very fast */
	randfweaj->ac = 10 - rn2(13);				/* any AC */
	randfweaj->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfweaj->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaj->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaj->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaj->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweaj->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfweaj->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweaj->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweaj->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweaj->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweak->mmove = 14 + rn2(7);				/* slow to very fast */
	randfweak->ac = 10 - rn2(14);				/* any AC */
	randfweak->mr = rn2(81);				/* varying amounts of MR */

	if (!rn2(20)) randfweak->geno |= G_SGROUP;
	else if (!rn2(200)) randfweak->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweak->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweak->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweak->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(15)+1;				/* either too high or too low */
	}

	for (i = 0; i < 2; i++) {
		randfweak->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweak->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweak->mflags2 |= (1 << rn2(31));
	}
	randfweak->mflags2 &= ~M2_MERC;				/* no guards */
	randfweak->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweak->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	for (i = 0; i < 2; i++) {
		randfweak->mflags3 |= (1 << (12 + rn2(17)) );
	}

	randfweak->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweal->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweal->ac = 10 - rn2(7);				/* any AC */
	randfweal->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfweal->geno |= G_SGROUP;
	else if (!rn2(200)) randfweal->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweal->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweal->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweal->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweal->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfweam->mmove = 13 + rn2(9);				/* slow to very fast */
	randfweam->ac = 10 - rn2(7);				/* any AC */
	randfweam->mr = rn2(41);				/* varying amounts of MR */

	if (!rn2(20)) randfweam->geno |= G_SGROUP;
	else if (!rn2(200)) randfweam->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweam->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweam->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 2; i < 4; i++) {
		attkptr = &randfweam->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(10)+1;				/* either too high or too low */
	}

	for (i = 0; i < 1; i++) {
		randfweam->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	randfwean->mmove = 14 + rn2(3);				/* slow to very fast */
	randfwean->ac = 10 - rn2(16);				/* any AC */
	randfwean->mr = rn2(61);				/* varying amounts of MR */

	if (!rn2(20)) randfwean->geno |= G_SGROUP;
	else if (!rn2(200)) randfwean->geno |= G_LGROUP;
	else if (!rn2(5000)) randfwean->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfwean->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfwean->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(7)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfwean->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfwean->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfwean->mflags2 |= (1 << rn2(31));
	}
	randfwean->mflags2 &= ~M2_MERC;				/* no guards */
	randfwean->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfwean->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweao->mmove = 8 + rn2(5);				/* slow to very fast */
	randfweao->ac = 10 - rn2(22);				/* any AC */
	randfweao->mr = rn2(71);				/* varying amounts of MR */

	if (!rn2(20)) randfweao->geno |= G_SGROUP;
	else if (!rn2(200)) randfweao->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweao->geno |= G_VLGROUP;

	for (i = 0; i < 1; i++) {
		attkptr = &randfweao->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 1; i < 2; i++) {
		attkptr = &randfweao->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(8)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweao->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweao->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweao->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 3; i++) {
		randfweao->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweao->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweao->mflags2 &= ~M2_MERC;				/* no guards */
	randfweao->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweao->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweap->mmove = 14 + rn2(7);				/* slow to very fast */
	randfweap->ac = 10 - rn2(7);				/* any AC */
	randfweap->mr = rn2(51);				/* varying amounts of MR */

	if (!rn2(20)) randfweap->geno |= G_SGROUP;
	else if (!rn2(200)) randfweap->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweap->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweap->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(2)+1;				/* either too high or too low */
	}

	for (i = 0; i < 3; i++) {
		randfweap->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 2; i++) {
		randfweap->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweap->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweap->mflags2 &= ~M2_MERC;				/* no guards */
	randfweap->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweap->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	randfweaq->mmove = 11 + rn2(3);				/* slow to very fast */
	randfweaq->ac = 10 - rn2(41);				/* any AC */
	randfweaq->mr = rn2(91);				/* varying amounts of MR */

	if (!rn2(20)) randfweaq->geno |= G_SGROUP;
	else if (!rn2(200)) randfweaq->geno |= G_LGROUP;
	else if (!rn2(5000)) randfweaq->geno |= G_VLGROUP;

	for (i = 0; i < 2; i++) {
		attkptr = &randfweaq->mattk[i];
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rnd(37)+1;				/* either too high or too low */
	}

	for (i = 0; i < 4; i++) {
		randfweaq->mresists |= (1 << rn2(8));		/* physical resistances... */
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags2 |= (1 << rn2(31));
	}

	for (i = 0; i < 1; i++) {
		randfweaq->mflags3 |= (1 << (12 + rn2(17)) );
	}
	randfweaq->mflags3 &= ~M3_NONMOVING;				/* can always move around */

	randfweaq->mflags2 &= ~M2_MERC;				/* no guards */
	randfweaq->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	randfweaq->mflags2 &= ~M2_WERE;				/* no lycanthropes */

	u.cnd_alterrealityamount++;

	if (realityflag == 0) {

		pline(FunnyHallu ? "You invoke the power of Eru Iluvator... err, Sauron. Whatever it's called." : "The power of Eru Iluvator flows through you!");
		pline(FunnyHallu ? "Somehow, that did all of jack diddly." : "The world changes!");
	}

	if (realityflag == 1 && !rn2(10)) {
		pline("Suddenly, the reality is altered!");
	}

	/* in case the player is a race that has randomized stats in monster form... --Amy */
	init_uasmon();

	return;

}

/* Called from allmain.c: re-initialize polyinitor and destabilizer playable races --Amy */
void
polyinitors()
{
	register struct permonst *ptr;
	register int starlitattempts, starlitmonster;

	struct permonst* polyinitor = &mons[PM_POLYINITOR];
	struct permonst* destabilizer = &mons[PM_DESTABILIZER];

	starlitattempts = 0;

	ptr = rndmonst();
polyinitredoY:
	do {
		ptr = rndmonst();
		starlitattempts++;
	} while (!ptr && starlitattempts < 50000);

	if (ptr) {
		starlitmonster = monsndx(ptr);

		if ( (!attacktype(&mons[starlitmonster], AT_WEAP) && rn2(10)) || (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) ) goto polyinitredoY;

		polyinitor->mmove = mons[starlitmonster].mmove;
		polyinitor->ac = mons[starlitmonster].ac;
		polyinitor->mr = mons[starlitmonster].mr;
		polyinitor->maligntyp = mons[starlitmonster].maligntyp;
		polyinitor->mattk[0] = mons[starlitmonster].mattk[0];
		polyinitor->mattk[1] = mons[starlitmonster].mattk[1];
		polyinitor->mattk[2] = mons[starlitmonster].mattk[2];
		polyinitor->mattk[3] = mons[starlitmonster].mattk[3];
		polyinitor->mattk[4] = mons[starlitmonster].mattk[4];
		polyinitor->mattk[5] = mons[starlitmonster].mattk[5];
		polyinitor->cwt = mons[starlitmonster].cwt;
		polyinitor->cnutrit = mons[starlitmonster].cnutrit;
		polyinitor->msound = mons[starlitmonster].msound;
		polyinitor->msize = mons[starlitmonster].msize;
		polyinitor->mresists = mons[starlitmonster].mresists;
		polyinitor->mflags1 = mons[starlitmonster].mflags1;
		polyinitor->mflags2 = mons[starlitmonster].mflags2;
		polyinitor->mflags3 = mons[starlitmonster].mflags3;

		polyinitor->mflags2 &= ~M2_NOPOLY;
		polyinitor->mflags2 &= ~M2_MERC;
		polyinitor->mflags2 &= ~M2_WERE;
		polyinitor->mflags2 &= ~M2_PNAME;
		polyinitor->mflags2 &= ~M2_PEACEFUL;

		polyinitor->mflags3 |= 0x40000000L;
		polyinitor->mflags3 |= 0x80000000L;
	}

	starlitmonster = rn2(NUMMONS);
	do {
		starlitmonster = rn2(NUMMONS);
	} while ( (notake(&mons[starlitmonster]) && rn2(4) ) || ((mons[starlitmonster].mlet == S_BAT) && rn2(2)) || ((mons[starlitmonster].mlet == S_EYE) && rn2(2) ) || ((mons[starlitmonster].mmove == 1) && rn2(4) ) || ((mons[starlitmonster].mmove == 2) && rn2(3) ) || ((mons[starlitmonster].mmove == 3) && rn2(2) ) || ((mons[starlitmonster].mmove == 4) && !rn2(3) ) || ( (mons[starlitmonster].mlevel < 10) && ((mons[starlitmonster].mlevel + 1) < rnd(u.ulevel)) ) || (!haseyes(&mons[starlitmonster]) && rn2(2) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(5) ) || ( is_nonmoving(&mons[starlitmonster]) && rn2(20) ) || (is_jonadabmonster(&mons[starlitmonster]) && rn2(20)) || ( uncommon2(&mons[starlitmonster]) && !rn2(4) ) || ( uncommon3(&mons[starlitmonster]) && !rn2(3) ) || ( uncommon5(&mons[starlitmonster]) && !rn2(2) ) || ( uncommon7(&mons[starlitmonster]) && rn2(3) ) || ( uncommon10(&mons[starlitmonster]) && rn2(5) ) || ( is_eel(&mons[starlitmonster]) && rn2(20) ) );

	destabilizer->mmove = mons[starlitmonster].mmove;
	destabilizer->ac = mons[starlitmonster].ac;
	destabilizer->mr = mons[starlitmonster].mr;
	destabilizer->maligntyp = mons[starlitmonster].maligntyp;
	destabilizer->mattk[0] = mons[starlitmonster].mattk[0];
	destabilizer->mattk[1] = mons[starlitmonster].mattk[1];
	destabilizer->mattk[2] = mons[starlitmonster].mattk[2];
	destabilizer->mattk[3] = mons[starlitmonster].mattk[3];
	destabilizer->mattk[4] = mons[starlitmonster].mattk[4];
	destabilizer->mattk[5] = mons[starlitmonster].mattk[5];
	destabilizer->cwt = mons[starlitmonster].cwt;
	destabilizer->cnutrit = mons[starlitmonster].cnutrit;
	destabilizer->msound = mons[starlitmonster].msound;
	destabilizer->msize = mons[starlitmonster].msize;
	destabilizer->mresists = mons[starlitmonster].mresists;
	destabilizer->mflags1 = mons[starlitmonster].mflags1;
	destabilizer->mflags2 = mons[starlitmonster].mflags2;
	destabilizer->mflags3 = mons[starlitmonster].mflags3;

	destabilizer->mflags2 &= ~M2_NOPOLY;
	destabilizer->mflags2 &= ~M2_MERC;
	destabilizer->mflags2 &= ~M2_WERE;
	destabilizer->mflags2 &= ~M2_PNAME;
	destabilizer->mflags2 &= ~M2_PEACEFUL;

	destabilizer->mflags3 |= 0x40000000L;
	destabilizer->mflags3 |= 0x80000000L;

}

/* Called from allmain.c; re-initializes god names if you save and load --Amy */
void
reinitgods()
{
	int tempvar = u.uhereticgodinit;

	if (isheretic) {
		u.hereticlgod = lawfulgods[u.uhereticgodlawful];
		u.hereticngod = neutralgods[u.uhereticgodneutral];
		u.hereticcgod = chaoticgods[u.uhereticgodchaotic];

		if (tempvar >= 4) {
			u.hereticcgod = hereticgods[u.uhereticgodchaotic];
			tempvar -= 4;
		} else {
			u.hereticcgod = chaoticgods[u.uhereticgodchaotic];
		}

		if (tempvar >= 2) {
			u.hereticngod = hereticgods[u.uhereticgodneutral];
			tempvar -= 2;
		} else {
			u.hereticngod = neutralgods[u.uhereticgodneutral];
		}

		if (tempvar >= 1) {
			u.hereticlgod = hereticgods[u.uhereticgodlawful];
			tempvar -= 1;
		} else {
			u.hereticlgod = lawfulgods[u.uhereticgodlawful];
		}

	}

	if (!isheretic && (Role_if(PM_GUNNER) || Role_if(PM_ANACHRONIST) || Role_if(PM_PRIEST) || Role_if(PM_MYSTIC) || Role_if(PM_SHAPESHIFTER) || Role_if(PM_ERDRICK) || Role_if(PM_WILD_TALENT) )) {

		u.hereticlgod = lawfulgods[u.uhereticgodlawful];
		u.hereticngod = neutralgods[u.uhereticgodneutral];
		u.hereticcgod = chaoticgods[u.uhereticgodchaotic];

	}

	if (Role_if(PM_FAILED_EXISTENCE) || Role_if(PM_TRANSSYLVANIAN) ) {
		u.hereticlgod = hereticgods[u.uhereticgodlawful];
		u.hereticngod = hereticgods[u.uhereticgodneutral];
		u.hereticcgod = hereticgods[u.uhereticgodchaotic];
	}

	/* fail safe - this will be essential for the recursion trap that changes the player's role or race --Amy */
	if (!isheretic && !Role_if(PM_GUNNER) && !Role_if(PM_WILD_TALENT) && !Role_if(PM_ANACHRONIST) && !Role_if(PM_PRIEST) && !Role_if(PM_MYSTIC) && !Role_if(PM_SHAPESHIFTER) && !Role_if(PM_FAILED_EXISTENCE) && !Role_if(PM_TRANSSYLVANIAN) && !Role_if(PM_ERDRICK)) {
		u.hereticlgod = hereticgods[u.uhereticgodlawful];
		u.hereticngod = hereticgods[u.uhereticgodneutral];
		u.hereticcgod = hereticgods[u.uhereticgodchaotic];
	}

}

void
reinitmissingno()
{
	struct permonst* shamblerplayermso = &mons[PM_MISSINGNO];
	struct permonst* shamblerplayermsp = &mons[PM_POLYMORPHED_MISSINGNO];
	int i;
	struct attack* attkptr;

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermso->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermso->ac = rn2(21)-10;				/* any AC */
	shamblerplayermso->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermso->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermso->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermso->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermso->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermso->cnutrit = rnd(2000);					/* see above */
	shamblerplayermso->msound = randmonsound();			/* any but the specials */
	shamblerplayermso->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermso->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermso->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermso->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermso->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermso->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermso->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermso->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermso->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermso->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermso->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermso->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermso->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermso->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */

	/* what a horrible night to have a curse */
	/*shambler->mlevel += rnd(15)-9;*/				/* shuffle level */
	shamblerplayermsp->mmove = rn3(9)+9;				/* slow to very fast */
	shamblerplayermsp->ac = rn2(21)-10;				/* any AC */
	shamblerplayermsp->mr = rn2(5)*25;				/* varying amounts of MR */
	shamblerplayermsp->maligntyp = rn2(21)-10;			/* any alignment */
	/* attacks...?  */
	for (i = 0; i < rno(4); i++) {
		attkptr = &shamblerplayermsp->mattk[i];
		/* restrict it to certain types of attacks */
		attkptr->aatyp = AT_MULTIPLY;
		while (attkptr->aatyp == AT_MULTIPLY) {
			attkptr->aatyp = rn2(AT_MULTIPLY);
		}
		if (attkptr->aatyp == AT_BOOM) {
			attkptr->aatyp = AT_MAGC;
		}
		if (attkptr->aatyp == AT_EXPL) {
			attkptr->aatyp = AT_WEAP;
		}
		attkptr->adtyp = AD_ENDS;
		while (attkptr->adtyp == AD_ENDS || attkptr->adtyp == AD_WERE) {
			attkptr->adtyp = randattack();
		}
		attkptr->damn = 2;				/* we're almost sure to get this wrong first time */
		attkptr->damd = rn3(6)+2;				/* either too high or too low */
	}
	shamblerplayermsp->msize = rn2(MZ_GIGANTIC+1);			/* any size */
	shamblerplayermsp->cwt = rnd(2000);					/* fortunately moot as it's flagged NOCORPSE */
	shamblerplayermsp->cnutrit = rnd(2000);					/* see above */
	shamblerplayermsp->msound = randmonsound();			/* any but the specials */
	shamblerplayermsp->mresists = 0;
	for (i = 0; i < rnd(6); i++) {
		shamblerplayermsp->mresists |= (1 << rn2(8));		/* physical resistances... */
	}
	for (i = 0; i < rnd(5); i++) {
		shamblerplayermsp->mresists |= (0x100 << rn2(7));	/* 'different' resistances, even clumsy */
	}
	shamblerplayermsp->mconveys = 0;					/* flagged NOCORPSE */
	/*
	 * now time for the random flags.  this will likely produce
	 * a number of complete trainwreck monsters at first, but
	 * every so often something will dial up nasty stuff
	 */
	shamblerplayermsp->mflags1 = 0;
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags1 |= (1 << rn2(33));		/* trainwreck this way :D */
	}
	/*shamblerplayermsp->mflags1 &= ~M1_UNSOLID;*/			/* no ghosts */
	/*shamblerplayermsp->mflags1 &= ~M1_WALLWALK;*/			/* no wall-walkers */

	shamblerplayermsp->mflags2 = M2_HOSTILE;		/* see mondata.h */
	for (i = 0; i < rnd(17); i++) {
		shamblerplayermsp->mflags2 |= (1 << rn2(31));
	}
	shamblerplayermsp->mflags2 &= ~M2_MERC;				/* no guards */
	shamblerplayermsp->mflags2 &= ~M2_PEACEFUL;			/* no peacefuls */
	shamblerplayermsp->mflags2 &= ~M2_WERE;				/* no lycanthropes */
	shamblerplayermsp->mflags2 &= ~M2_PNAME;				/* not a proper name */
	shamblerplayermsp->mflags2 &= ~M2_NOPOLY;				/* polymorph ok for monsters */


}

/*u_init.c*/
