/*	SCCS Id: @(#)end.c	3.4	2003/03/10	*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* NetHack may be freely redistributed.  See license for details. */

#define NEED_VARARGS	/* comment line for pre-compiled headers */

#include <sys/types.h>
#include <sys/stat.h>
#include "hack.h"
#include "eshk.h"
#ifndef NO_SIGNAL
#include <signal.h>
#endif
#include "dlb.h"
extern int enter_explore_mode(void);

#ifdef DUMP_LOG
extern char msgs[][BUFSZ];
extern int msgs_count[];
extern int lastmsg;
#endif

	/* these probably ought to be generated by makedefs, like LAST_GEM */
#define FIRST_GEM    DILITHIUM_CRYSTAL
#define FIRST_AMULET AMULET_OF_ESP
#define LAST_AMULET  AMULET_OF_YENDOR
 
struct valuable_data { long count; int typ; };

static struct valuable_data
	gems[LAST_GEM+1 - FIRST_GEM + 1], /* 1 extra for glass */
	amulets[LAST_AMULET+1 - FIRST_AMULET];

static struct val_list { struct valuable_data *list; int size; } valuables[] = {
	{ gems,    sizeof gems / sizeof *gems },
	{ amulets, sizeof amulets / sizeof *amulets },
	{ 0, 0 }
};

#ifndef NO_SIGNAL
STATIC_PTR void done_intr(int);
# if defined(UNIX) || defined(VMS) || defined (__EMX__)
static void done_hangup(int);
# endif
#endif
STATIC_DCL void disclose(int,BOOLEAN_P);
STATIC_DCL void get_valuables(struct obj *);
STATIC_DCL void sort_valuables(struct valuable_data *,int);
STATIC_DCL void artifact_score(struct obj *,BOOLEAN_P,winid);
STATIC_DCL void savelife(int);
STATIC_DCL boolean list_vanquished(CHAR_P, BOOLEAN_P);
#ifdef DUMP_LOG
extern void dump_spells(void);
extern void dump_techniques(void);
extern void dump_overview(void);
extern void dump_discoveries(void);
void do_vanquished(int, BOOLEAN_P, BOOLEAN_P);
STATIC_DCL void list_genocided(int, BOOLEAN_P, BOOLEAN_P);
#else
STATIC_DCL void list_genocided(CHAR_P,BOOLEAN_P);
#endif /* DUMP_LOG */
STATIC_DCL boolean should_query_disclose_option(int,char *);

#if defined(__BEOS__) || defined(MICRO) || defined(WIN32) || defined(OS2)
extern void nethack_exit(int);
#else
#define nethack_exit exit
#endif

#define done_stopprint program_state.stopprint

#ifdef AMIGA
# define NH_abort()	Abort(0)
#else
# ifdef SYSV
# define NH_abort()	(void) abort()
# else
#  ifdef WIN32
# define NH_abort()	win32_abort()
#  else
# define NH_abort()	abort()
#  endif
# endif
#endif

/*
 * The order of these needs to match the macros in hack.h.
 */
static NEARDATA const char *deaths[] = {		/* the array of death */
	"died", "betrayed", "choked", "poisoned", "starvation", "drowning",
	"burning", "dissolving under the heat and pressure",
	"crushed", "turned to stone", "turned into slime",
	"genocided", "panic", "trickery",
	"quit", "escaped", "ascended"
};

static NEARDATA const char *ends[] = {		/* "when you..." */
	"died", "were betrayed", "choked", "were poisoned", "starved", 
	"drowned", "burned", "dissolved in the lava",
	"were crushed", "turned to stone", "turned into slime",
	"were genocided", "panicked", "were tricked",
	"quit", "escaped", "ascended"
};

char *
dump_format_str(char *str)
{
    static char buf[BUFSZ];
    char *f, *p, *end;
    int ispercent = 0;

    buf[0] = '\0';

    if (!str) return NULL;

    f = str;
    p = buf;
    end = buf + sizeof(buf) - 10;

    while (*f) {
      if (ispercent) {
	switch (*f) {
	case 't':
	  snprintf (p, end + 1 - p, "%ld", u.ubirthday);
	  while (*p != '\0')
	    p++;
	  break;
        case 'N':
          *p = plname[0];
	  p++;
	  *p = '\0';
	  break;
	case 'n':
	  snprintf (p, end + 1 - p, "%s", plname);
	  while (*p != '\0')
	    p++;
	  break;
	default:
	  *p = *f;
	  if (p < end)
	    p++;
	}
	ispercent = 0;
      } else {
	if (*f == '%')
	  ispercent = 1;
	else {
	  *p = *f;
	  if (p < end)
	    p++;
	}
      }
      f++;
    }
    *p = '\0';

    return buf;
}

#ifdef DUMP_LOG
FILE *dump_fp = (FILE *)0;  /* file pointer for dumps */
/* functions dump_init, dump_exit and dump are from the dump patch */

static
char*
get_dump_filename()
{
	static char buf[BUFSIZ+1+5];
	char *f, *p, *end;
	int ispercent = 0;

	buf[0] = '\0';

	if (!dump_fn[0]) return NULL;

	f = dump_fn;
	p = buf;
	end = buf + sizeof(buf) - 10;

	while (*f) {
		if (ispercent) {
			switch (*f) {
				case 't': case 'd': /* starttime */
					snprintf (p, end + 1 - p, "%ld", u.ubirthday);
					while (*p != '\0') {
						p++;
					}
					break;
				case 'N': /* first character of player name */
					*p = plname[0];
					p++;
					*p = '\0';
					break;
				case 'n': /* player name */
				case 's': /* for backwards compatibility */
					snprintf(p, end + 1 - p, "%s", plname);
					while (*p != '\0') {
						p++;
					}
					break;
				default:
					*p = *f;
					if (p < end) {
						p++;
					}
			}
			ispercent = 0;
		} else {
			if (*f == '%') {
				ispercent = 1;
			} else {
				*p = *f;
				if (p < end) {
					p++;
				}
			}
		}
		f++;
	}
	*p = '\0'; 

	return buf;
}


void
dump_init ()
{
#ifdef PUBLIC_SERVER
  mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif
  if (dump_fn[0]) {
    char *actual_fn = get_dump_filename();

    dump_fp = fopen (actual_fn, "w");
#ifdef PUBLIC_SERVER
    chmod(actual_fn, dumpmode);
#endif

    if (!dump_fp) {
      pline("Can't open %s for output.", actual_fn);
      pline("Dump file not created.");
    }
  }
}

void
dump_exit ()
{
  if (dump_fp) {
    fclose (dump_fp);
  }
}

void dump (pre, str)
     const char * const pre;
     const char * const str;
{
  if (dump_fp)
    fprintf (dump_fp, "%s%s\n", pre, str);
}
#endif  /* DUMP_LOG */

/*ARGSUSED*/
void
done1(sig_unused)   /* called as signal() handler, so sent at least one arg */
int sig_unused;
{
#if defined(MAC_MPW)
# pragma unused ( sig_unused )
#endif
#ifndef NO_SIGNAL
	(void) signal(SIGINT,SIG_IGN);
#endif
	if(flags.ignintr) {
#ifndef NO_SIGNAL
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif
		clear_nhwindow(WIN_MESSAGE);
		curs_on_u();
		wait_synch();
		if(multi > 0) nomul(0, 0, FALSE);
	} else {
		(void)done2();
	}
}

extern const char * const killed_by_prefix[];	/* from topten.c */

/* "#quit" command or keyboard interrupt */
int
done2()
{
	if (iflags.debug_fuzzer) return 0;

	char buf[BUFSZ];
	int really_quit = FALSE;

	if (flags.paranoidquit) {

	  getlin ("Really quit? WARNING: this will erase your game permanently! [yes/no]?",buf);
	  (void) lcase (buf);
	  if (!(strcmp (buf, "yes"))) really_quit = TRUE;

	} else {

		if(yn("Really quit? WARNING: this will erase your game permanently and you disabled the paranoidquit safety option so if you hit 'y' now, your game will be GONE!") != 'n') really_quit = TRUE;

	}
	
	if (!really_quit) {
#ifndef NO_SIGNAL
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif
		clear_nhwindow(WIN_MESSAGE);
		curs_on_u();
		wait_synch();
		if(multi > 0) nomul(0, 0, FALSE);
		if(multi == 0) {
		    u.uinvulnerable = FALSE;	/* avoid ctrl-C bug -dlc */
		    u.usleep = 0;
		}
		return 0;
	}
#if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE))
	if(wizard) {
	    int c;
# ifdef VMS
	    const char *tmp = "Enter debugger?";
# else
#  ifdef LATTICE
	    const char *tmp = "Create SnapShot?";
#  else
	    const char *tmp = "Dump core?";
#  endif
# endif
	    if ((c = ynq(tmp)) == 'y') {
		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
		exit_nhwindows((char *)0);
		NH_abort();
	    } else if (c == 'q') done_stopprint++;
	}
#endif
#ifndef LINT
	done(QUIT);
#endif
	return 0;
}

#ifndef NO_SIGNAL
/*ARGSUSED*/
STATIC_PTR void
done_intr(sig_unused) /* called as signal() handler, so sent at least one arg */
int sig_unused;
{
#if defined(MAC_MPW)
# pragma unused ( sig_unused )
#endif
	done_stopprint++;
	(void) signal(SIGINT, SIG_IGN);
# if defined(UNIX) || defined(VMS)
	(void) signal(SIGQUIT, SIG_IGN);
# endif
	return;
}

# if defined(UNIX) || defined(VMS) || defined(__EMX__)
static void
done_hangup(sig)	/* signal() handler */
int sig;
{
	program_state.done_hup++;
	(void)signal(SIGHUP, SIG_IGN);
	done_intr(sig);
	return;
}
# endif
#endif /* NO_SIGNAL */

void
done_in_by(mtmp)
register struct monst *mtmp;
{
	u.youaredead = 1;
	char buf[BUFSZ];
	boolean distorted = (boolean)(Hallucination && canspotmon(mtmp));

	You(isangbander ? "have died." : "die...");
	/* for those wand o'death, touch o'death, poisoned spike times... */        

	if(mtmp->data == &mons[PM_SOLDIER_ANT]) pline("Go Team Ant!");

	if (Instant_Death)
	    You("were hosed!");
	mark_synch();	/* flush buffered screen output */
	buf[0] = '\0';
	strcat(buf, "a monster (");

	killer_format = KILLED_BY;
	if (!Blind || Blind_telepat || Blind) {        
	/* "killed by the high priest of Crom" is okay, "killed by the high
	   priest" alone isn't */
	if ((mtmp->data->geno & G_UNIQ) != 0 && !(mtmp->data == &mons[PM_HIGH_PRIEST] && !mtmp->ispriest)) {
	    if (!type_is_pname(mtmp->data))
		strcat(buf, "the ");
	    killer_format = KILLED_BY;
	}
	/* _the_ <invisible> <distorted> ghost of Dudley */
	if (mtmp->data == &mons[PM_GHOST] && mtmp->mnamelth) {
		strcat(buf, "the ");
		killer_format = KILLED_BY;
	}
	if (mtmp->minvis)
		strcat(buf, "invisible ");
	if (distorted)
		strcat(buf, "hallucinogen-distorted ");

	if(mtmp->data == &mons[PM_GHOST]) {
		strcat(buf, "ghost");
		if (mtmp->mnamelth) sprintf(eos(buf), " of %s", NAME(mtmp));
	} else if(mtmp->isshk) {
		sprintf(eos(buf), "%s %s, the shopkeeper",
			(mtmp->female ? "Ms." : "Mr."), shkname(mtmp));
		killer_format = KILLED_BY;
	} else if (mtmp->ispriest || mtmp->isminion) {
		/* m_monnam() suppresses "the" prefix plus "invisible", and
		   it overrides the effect of Hallucination on priestname() */
		killer = m_monnam(mtmp);
		strcat(buf, killer);
	} else {
		strcat(buf, mtmp->data->mname);
		if (mtmp->mnamelth)
		    sprintf(eos(buf), " called %s", NAME(mtmp));
	}
	strcat(buf, ")");

	if (multi) {
	  if (strlen(multi_txt) > 0)
	    sprintf(eos(buf), ", while %s", multi_txt);
	  else
	    strcat(buf, ", while helpless");
	}

	} else {
		killer_format = KILLED_BY;
		strcat(buf,", while blind");
		if (multi) strcat(buf," and helpless");
	}
	if(mtmp->data == &mons[PM_SOLDIER_ANT]) strcat(buf, "    Go Team Ant!");

	killer = buf;
	if (mtmp->data->mlet == S_WRAITH)
		u.ugrave_arise = PM_WRAITH;
	else if (mtmp->data->mlet == S_MUMMY && urace.mummynum != NON_PM)
		u.ugrave_arise = urace.mummynum;
	else if (is_vampire(mtmp->data) && Race_if(PM_HUMAN)
		  	&& mtmp->data != &mons[PM_FIRE_VAMPIRE]
		  	&& mtmp->data != &mons[PM_STAR_VAMPIRE])
		u.ugrave_arise = PM_VAMPIRE;
	else if (mtmp->data == &mons[PM_GHOUL])
		u.ugrave_arise = PM_GHOUL;
	if (u.ugrave_arise >= LOW_PM &&
				(mvitals[u.ugrave_arise].mvflags & G_GENOD))
		u.ugrave_arise = NON_PM;
	if (touch_petrifies(mtmp->data))
		done(STONING);
	else if (mtmp->mtraitor)
		done(BETRAYED);
	else
		done(DIED);

	u.youaredead = 0;
	return;
}

#if defined(WIN32)
#define NOTIFY_NETHACK_BUGS
#endif

/*VARARGS1*/
void
panic VA_DECL(const char *, str)
	VA_START(str);
	VA_INIT(str, char *);

	if (program_state.panicking++)
	    NH_abort();	/* avoid loops - this should never happen*/

	if (iflags.window_inited) {
	    raw_print("\r\nOops...");
	    wait_synch();	/* make sure all pending output gets flushed */
	    exit_nhwindows((char *)0);
	    iflags.window_inited = 0; /* they're gone; force raw_print()ing */
	}

	raw_print(program_state.gameover ?
		  "Postgame wrapup disrupted." :
		  !program_state.something_worth_saving ?
		  "Program initialization has failed." :
		  "Suddenly, the dungeon collapses.");

	    raw_print("\r\nReport this error to Amy (Bluescreenofdeath at Nethackwiki) so it can be fixed.");

	    raw_print("\r\nYou can also contact the admins on the #em.slashem.me IRC channel (Freenode)");

#if defined(WIZARD) && !defined(MICRO)
# if defined(NOTIFY_NETHACK_BUGS)
	if (!wizard)
	    raw_printf("Report the following error to \"%s\".",
			"slashem-discuss@lists.sourceforge.net");
	else if (program_state.something_worth_saving)
	    raw_print("\nError save file being written.\n");
# else
	if (!wizard)
	    raw_printf("Report error to \"%s\"%s.",
#  ifdef WIZARD_NAME	/*(KR1ED)*/
			WIZARD_NAME,
#  else
			WIZARD,
#  endif
			!program_state.something_worth_saving ? "" :
			" and it may be possible to rebuild.");
# endif
	if (program_state.something_worth_saving) {
	    set_error_savefile();
	    (void) dosave0();
	}
#endif
	{
	    char buf[BUFSZ];
	    vsprintf(buf,str,VA_ARGS);
	    raw_print(buf);
	    paniclog("panic", buf);
	}
#ifdef WIN32
	interject(INTERJECT_PANIC);
#endif
#if defined(WIZARD) && (defined(UNIX) || defined(VMS) || defined(LATTICE) || defined(WIN32))
	if (wizard)
	    NH_abort();	/* generate core dump */
#endif
	VA_END();
	done(PANICKED);
}

STATIC_OVL boolean
should_query_disclose_option(category, defquery)
int category;
char *defquery;
{
    int idx;
    char *dop = index(disclosure_options, category);

    if (dop && defquery) {
	idx = dop - disclosure_options;
	if (idx < 0 || idx > (NUM_DISCLOSURE_OPTIONS - 1)) {
	    impossible(
		   "should_query_disclose_option: bad disclosure index %d %c",
		       idx, category);
	    *defquery = DISCLOSE_PROMPT_DEFAULT_YES;
	    return TRUE;
	}
	if (flags.end_disclose[idx] == DISCLOSE_YES_WITHOUT_PROMPT) {
	    *defquery = 'y';
	    return FALSE;
	} else if (flags.end_disclose[idx] == DISCLOSE_NO_WITHOUT_PROMPT) {
	    *defquery = 'n';
	    return FALSE;
	} else if (flags.end_disclose[idx] == DISCLOSE_PROMPT_DEFAULT_YES) {
	    *defquery = 'y';
	    return TRUE;
	} else if (flags.end_disclose[idx] == DISCLOSE_PROMPT_DEFAULT_NO) {
	    *defquery = 'n';
	    return TRUE;
	}
    }
    if (defquery)
	impossible("should_query_disclose_option: bad category %c", category);
    else
	impossible("should_query_disclose_option: null defquery");
    return TRUE;
}

STATIC_OVL void
disclose(how,taken)
int how;
boolean taken;
{
	char	c = 0, defquery;
	char	qbuf[QBUFSZ];
	boolean ask;
	boolean hallu=FALSE;

	if (PlayerHearsSoundEffects) pline(issoviet ? "Igra zakonchena! Ty polnyy otstoy! Vy igrali tak uzhasno plokho, chto ty umer, i teper' vy dolzhny nachat' s nulya!" : "Duedeldue-duedeldue-duedeldue-duedelduedeldueueueueue-wueck!");

	if (invent) {
	    if(taken)
		sprintf(qbuf, Role_if(PM_SPACE_MARINE) ? "Game over, man!  Game over! (DYWYPI?)" : Role_if(PM_SPACEWARS_FIGHTER) ? "Another one bites the dust... DYWYPI?" : Role_if(PM_CAMPERSTRIKER) ? "A problem has been detected and NetHack has been shut down to prevent damage to your sanity. The problem seems to be caused by the following file: SLASHEM.EXE YET_ANOTHER_STUPID_DEATH (DYWYPI?) If this is the first time you've seen this Stop error screen, restart your game. If this screen appears again, follow these steps: Check to make sure any equipments or spells is properly installed. If this is a proper installation, ask your cheat or spoiler manufacturer for any spoilers you might need. If problems continue, remove any newly created save files (if explore) or bone files. Disable bad options such as rest_on_space or autopickup. If you need to use Explore Mode to remove or disable components, restart your game, press X to select Explore Mode Options, and then select Yes. Technical information: *** STOP: 0x0000DEAD (0x44, 0x75, 0x64, 0x6C, 0x65, 0x79) *** SLASHEM.EXE - Address DLVL1 base at MAINDUN, DateStamp 20150401" : issoviet ? "Tvoi tovari hotjat tebja identifitsirovat? DYWYPI? [da]" : "Do you want to see what you had when you %s? DYWYPI?",
			(how == QUIT) ? "quit" : "died");
	    else
		strcpy(qbuf, Role_if(PM_SPACEWARS_FIGHTER) ? "Another one bites the dust... DYWYPI?" : Role_if(PM_CAMPERSTRIKER) ? "A problem has been detected and NetHack has been shut down to prevent damage to your sanity. The problem seems to be caused by the following file: SLASHEM.EXE YET_ANOTHER_STUPID_DEATH (DYWYPI?) If this is the first time you've seen this Stop error screen, restart your game. If this screen appears again, follow these steps: Check to make sure any equipments or spells is properly installed. If this is a proper installation, ask your cheat or spoiler manufacturer for any spoilers you might need. If problems continue, remove any newly created save files (if explore) or bone files. Disable bad options such as rest_on_space or autopickup. If you need to use Explore Mode to remove or disable components, restart your game, press X to select Explore Mode Options, and then select Yes. Technical information: *** STOP: 0x0000DEAD (0x44, 0x75, 0x64, 0x6C, 0x65, 0x79) *** SLASHEM.EXE - Address DLVL1 base at MAINDUN, DateStamp 20150401" : issoviet ? "Tvoi tovari hotjat tebja identifitsirovat? DYWYPI? [da]" : "Do you want your possessions identified? DYWYPI?");

	    ask = should_query_disclose_option('i', &defquery);
	    if (!done_stopprint) {
		c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
		if (c != 'q') {
			struct obj *obj;

			if (Hallucination) {
			    make_hallucinated(0L, FALSE, 0L);
			    hallu = TRUE;
			}
			for (obj = invent; obj; obj = obj->nobj) {
			    makeknown(obj->otyp);
			    obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
			}
#ifdef DUMP_LOG
			(void) dump_inventory((char *)0, TRUE);
			do_containerconts(invent, TRUE, TRUE, TRUE);
#else
			(void) display_inventory((char *)0, TRUE);
			container_contents(invent, TRUE, TRUE);
#endif /* DUMP_LOG */
		}
		if (c == 'q')  done_stopprint++;
	    }
	}
	if (!invent) pline(Role_if(PM_SPACEWARS_FIGHTER) ? "Another one bites the dust... DYWYPI? Oops... it seems your inventory was empty!" : Role_if(PM_CAMPERSTRIKER) ? "A problem has been detected and NetHack has been shut down to prevent damage to your sanity. The problem seems to be caused by the following file: SLASHEM.EXE YET_ANOTHER_STUPID_DEATH (DYWYPI?) If this is the first time you've seen this Stop error screen, restart your game. If this screen appears again, follow these steps: Check to make sure any equipments or spells is properly installed. If this is a proper installation, ask your cheat or spoiler manufacturer for any spoilers you might need. If problems continue, remove any newly created save files (if explore) or bone files. Disable bad options such as rest_on_space or autopickup. If you need to use Explore Mode to remove or disable components, restart your game, press X to select Explore Mode Options, and then select Yes. Technical information: *** STOP: 0x0000DEAD (0x44, 0x75, 0x64, 0x6C, 0x65, 0x79) *** SLASHEM.EXE - Address DLVL1 base at MAINDUN, DateStamp 20150401" : issoviet ? "Tvoi tovari hotjat tebja identifitsirovat? DYWYPI? [da]" : "DYWYPI? Oops... it seems your inventory was empty!");
	if (hallu) make_hallucinated(20L, FALSE, 0L);

	ask = should_query_disclose_option('a', &defquery);
	if (!done_stopprint) {
	    c = ask ? yn_function("Do you want to see your attributes?",
				  ynqchars, defquery) : defquery;
	    if (c != 'q')
		enlightenment(how >= PANICKED ? 1 : 2, 1); /* final */
	    if (c == 'q') done_stopprint++;
	}

	ask = 1; /* if I can figure out how to do it, I'll make it configurable via disclosure and defquery options --Amy */
	if (!done_stopprint) {
	    c = ask ? yn_function("Do you want to see your discoveries?",
				  ynqchars, defquery) : defquery;
	    if (c != 'q')
		dodiscovered();
	    if (c == 'q') done_stopprint++;
	}

#ifdef DUMP_LOG
	if (dump_fp) {
	  dump_enlightenment((int) (how >= PANICKED ? 1 : 2));
	  dump_spells();
	  dump_techniques();
	  dump_discoveries();
	  dump_overview();
	}
#endif

	ask = should_query_disclose_option('v', &defquery);
	if (!done_stopprint)
#ifdef DUMP_LOG
	    do_vanquished(defquery, ask, TRUE);
#else
	    list_vanquished(defquery, ask);
#endif

	ask = should_query_disclose_option('g', &defquery);
	if (!done_stopprint)
#ifdef DUMP_LOG
	    list_genocided(defquery, ask,TRUE);
#else
	    list_genocided(defquery, ask);
#endif

	ask = should_query_disclose_option('c', &defquery);
	if (!done_stopprint) {
	    c = ask ? yn_function("Do you want to see your conduct?",
				  ynqchars, defquery) : defquery;
	    if (c != 'q')
		show_conduct(how >= PANICKED ? 1 : 2);
	    if (c == 'q') done_stopprint++;
	}
#ifdef DUMP_LOG
	if (dump_fp) {
	    dump_conduct(how >= PANICKED ? 1 : 2);
	    dump_weapon_skill();
	}
#endif
}

/* try to get the player back in a viable state after being killed */
STATIC_OVL void
	savelife(how)
int how;
{
	u.uswldtim = 0;
	if (Second_chance) {
		u.uhp = u.uhplast;
	} else {
		u.uhp = u.uhpmax;
	}
	u.uhplast = u.uhp;
	if (u.uhunger < 1000) {
	    u.uhunger = 1000;
	    newuhs(FALSE);
	}
	/* cure impending doom of sickness hero won't have time to fix */
	if ((Sick & TIMEOUT) == 1) {
	    u.usick_type = 0;
	    Sick = 0;
	}
	if (how == CHOKING) init_uhunger();
	nomovemsg = "You survived that attempt on your life.";
	flags.move = 0;
	if(multi > 0) multi = 0; else multi = -1;
	if(u.utrap && u.utraptype == TT_LAVA) u.utrap = 0;
	flags.botl = 1;
	u.ugrave_arise = NON_PM;
	HUnchanging = 0L;
	curs_on_u();
}

/*
 * Get valuables from the given list.  Revised code: the list always remains
 * intact.
 */
STATIC_OVL void
get_valuables(list)
struct obj *list;	/* inventory or container contents */
{
    register struct obj *obj;
    register int i;

    /* find amulets and gems, ignoring all artifacts */
    for (obj = list; obj; obj = obj->nobj)
	if (Has_contents(obj)) {
	    get_valuables(obj->cobj);
	} else if (obj->oartifact) {
	    continue;
	} else if (obj->oclass == AMULET_CLASS) {
	    i = obj->otyp - FIRST_AMULET;
	    if (!amulets[i].count) {
		amulets[i].count = obj->quan;
		amulets[i].typ = obj->otyp;
	    } else amulets[i].count += obj->quan; /* always adds one */
	} else if (obj->oclass == GEM_CLASS && obj->otyp < LUCKSTONE) {
	    i = min(obj->otyp, LAST_GEM + 1) - FIRST_GEM;
	    if (!gems[i].count) {
		gems[i].count = obj->quan;
		gems[i].typ = obj->otyp;
	    } else gems[i].count += obj->quan;
	}
    return;
}

/*
 *  Sort collected valuables, most frequent to least.  We could just
 *  as easily use qsort, but we don't care about efficiency here.
 */
STATIC_OVL void
sort_valuables(list, size)
struct valuable_data list[];
int size;		/* max value is less than 20 */
{
    register int i, j;
    struct valuable_data ltmp;

    /* move greater quantities to the front of the list */
    for (i = 1; i < size; i++) {
	if (list[i].count == 0) continue;	/* empty slot */
	ltmp = list[i]; /* structure copy */
	for (j = i; j > 0; --j)
	    if (list[j-1].count >= ltmp.count) break;
	    else {
		list[j] = list[j-1];
	    }
	list[j] = ltmp;
    }
    return;
}

/* called twice; first to calculate total, then to list relevant items */
STATIC_OVL void
artifact_score(list, counting, endwin)
struct obj *list;
boolean counting;	/* true => add up points; false => display them */
winid endwin;
{
    char pbuf[BUFSZ];
    struct obj *otmp;
    long value, points;
    /*short*/int dummy;	/* object type returned by artifact_name() */

    for (otmp = list; otmp; otmp = otmp->nobj) {
	if (otmp->oartifact ||
			otmp->otyp == BELL_OF_OPENING ||
			otmp->otyp == SPE_BOOK_OF_THE_DEAD ||
			otmp->otyp == CANDELABRUM_OF_INVOCATION) {
	    value = arti_cost(otmp);	/* zorkmid value */
	    points = value * 5 / 2;	/* score value */
	    if (counting) {
		u.urexp += points;
	    } else {
		makeknown(otmp->otyp);
		otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = 1;
		/* assumes artifacts don't have quan > 1 */
		sprintf(pbuf, "%s%s (worth %ld %s and %ld points)",
			the_unique_obj(otmp) ? "The " : "",
			otmp->oartifact ? /*artifact_name(*/xname(otmp)/*, &dummy)*/ :
				OBJ_NAME(objects[otmp->otyp]),
			value, currency(value), points);
		putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
		if (dump_fp)
		  dump("", pbuf);
#endif
	    }
	}
	if (Has_contents(otmp))
	    artifact_score(otmp->cobj, counting, endwin);
    }
}

/* Be careful not to call panic from here! */
void
done(how)
int how;
{
	boolean taken;
	boolean goexplore = FALSE;
	boolean gofreeplay = FALSE;
	char kilbuf[BUFSZ], pbuf[BUFSZ];
#ifdef EPITAPH
	char ebuf[BUFSZ];
#endif
	winid endwin = WIN_ERR;
	boolean bones_ok, have_windows = iflags.window_inited;
	struct obj *corpse = (struct obj *)0;
	long umoney;
	struct obj *otmp, *otmp2;
	int  n;
	char buf[BUFSZ];

	boolean wanttodie = 0;

	if (how == TRICKED) {
	    if (killer) {
		paniclog("trickery", killer);
		killer = 0;
	    }
#ifdef WIZARD
	    if (wizard) {
		You("are a very tricky wizard, it seems.");
		return;
	    }
#endif
	}

	if (iflags.debug_fuzzer) {
		if (!(program_state.panicking || how == PANICKED)) {
			savelife(how);
			killer = '\0';
			killer_format = 0;
			return;
		}
	}

	/* kilbuf: used to copy killer in case it comes from something like
	 *	xname(), which would otherwise get overwritten when we call
	 *	xname() when listing possessions
	 * pbuf: holds sprintf'd output for raw_print and putstr
	 */
	if (how == ASCENDED || (!killer && how == GENOCIDED))
		killer_format = NO_KILLER_PREFIX;
	/* Avoid killed by "a" burning or "a" starvation */
	if (!killer && (how == STARVING || how == BURNING))
		killer_format = KILLED_BY;
	strcpy(kilbuf, (!killer || how >= PANICKED ? deaths[how] : killer));
	killer = kilbuf;

	if (how < PANICKED) u.umortality++;

	if (DywypiProblem || u.uprops[DYWYPI_PROBLEM].extrinsic || have_dywypistone() || (uarmf && uarmf->oartifact == ART_PRADA_S_DEVIL_WEAR)) {
		wanttodie = 1;
		char qbuf[QBUFSZ];
		char possid = 0;
		sprintf(qbuf, "Do you want your possessions identified? DYWYPI?");
		possid = yn_function(qbuf, ynqchars, 'y');
		if (possid != 'n') {
			u.youaredead = 1;
			wanttodie = 1;
		} else wanttodie = 0;
	}

	if (how == STONING && uamul && uamul->otyp == AMULET_VERSUS_STONE) {
		pline("But wait...");
		makeknown(AMULET_VERSUS_STONE);
		Your("medallion %s%s!",
		      !Blind ? "begins to glow" : "feels warm",
		      uamul->cursed ? " and disintegrates" : "");
		/* blessed -> uncursed -> cursed -> gone */
		if (uamul->cursed)
			useup(uamul);
		else if (uamul->blessed)
			unbless(uamul);
		else
			curse(uamul);

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto stoningdone;
		}

		uunstone();
		(void) adjattrib(A_CON, -1, TRUE, TRUE);
		if(u.uhpmax <= 0) u.uhpmax = 1;
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif

		u.youaredead = 0;

		return;
	}
stoningdone:

	if (uarmg && uarmg->oartifact == ART_COME_BACK_TO_LIFE && rn2(2)) {
		pline("But wait...");
		pline("You come back to life!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto cbldone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
cbldone:

	if (u.contingencyturns) {

		int contingencychance = 25;

		if (!(PlayerCannotUseSkills) && P_SKILL(P_OCCULT_SPELL) >= P_BASIC) {

			switch (P_SKILL(P_OCCULT_SPELL)) {
				case P_BASIC: contingencychance = 35; break;
				case P_SKILLED: contingencychance = 50; break;
				case P_EXPERT: contingencychance = 65; break;
				case P_MASTER: contingencychance = 75; break;
				case P_GRAND_MASTER: contingencychance = 85; break;
				case P_SUPREME_MASTER: contingencychance = 90; break;
				default: break;
			}
		}

		if (rnd(100) > contingencychance) goto contingencydone;

		pline("But wait...");
		pline("You lost the effect of contingency.");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto contingencydone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
contingencydone:

	if (uarmh && uarmh->oartifact == ART_LUXIDREAM_S_ASCENSION && !rn2(10)) {
		pline("But wait...");
		pline("You come back to life!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto luxidone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
luxidone:

	if (uwep && uwep->oartifact == ART_ERU_ILUVATAR_S_BIBLE && !rn2(5)) {
		pline("But wait...");
		pline("Eru Iluvatar saves your life!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto erudone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
erudone:

	/* cursed ruffled shirt or victorian underwear may actually be helpful... */
	if (uarmu && how < GENOCIDED && (uarmu->otyp == RUFFLED_SHIRT || uarmu->otyp == VICTORIAN_UNDERWEAR) && uarmu->cursed && !rn2(4) ) {
		pline("But wait...");
		pline("For some reason, you're not dead!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto ruffledone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
ruffledone:

	/* double detect monsters can let you lifesave too */
	if (StrongDetect_monsters && how < GENOCIDED && !rn2(10) ) {
		pline("But wait...");
		pline("For some reason, you're not dead!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto detectmonstersdone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
detectmonstersdone:

	if (uarmf && how < GENOCIDED && uarmf->oartifact == ART_PRINCE_OF_PERSIA && !rn2(2) ) {
		pline("But wait...");
		pline("You respawn because you're the Prince of Persia!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto persiadone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
persiadone:

	/* Troll characters have a chance of reviving. --Amy */
	if (Race_if(PM_TROLLOR) && how < GENOCIDED && u.ulevel > 2 && rn2(4) ) {
		pline("But wait...");
		losexp("failed troll revival", TRUE, FALSE);
		losexp("failed troll revival", TRUE, FALSE);
		pline("You come back to life!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto trolldone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
trolldone:

	/* Felids have 9 lives --Amy */
	if (Race_if(PM_FELID) && how < GENOCIDED && u.ulevel > 2 && (u.felidlives > 1) ) {
		u.felidlives--;
		pline("But wait...");
		losexp("failed felid revival", TRUE, FALSE);
		losexp("failed felid revival", TRUE, FALSE);
		pline("Thanks to being a felid, you only used up one of your lives, and have %d left!", u.felidlives);

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto feliddone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
feliddone:

	if (u.extralives && how <= GENOCIDED) {
		pline("But wait...");
		pline("You have an extra life!");

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			u.extralives--;
			goto oneupdone;
		}

		if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
		savelife(how);
		u.extralives--;
		killer = 0;
		killer_format = 0;

#ifdef LIVELOGFILE
		livelog_avert_death();
#endif
		u.youaredead = 0;

		return;

	}
oneupdone:

	if ((Second_chance || Lifesaved) && how <= GENOCIDED) {
		pline("But wait...");
		makeknown(Lifesaved ? AMULET_OF_LIFE_SAVING : AMULET_OF_SECOND_CHANCE);
		Your("%s %s!", Lifesaved ? "medallion" : "amulet",
		      !Blind ? "begins to glow" : "feels warm");
		if (how == CHOKING) You("vomit ...");
		You_feel("much better!");
		pline_The("medallion crumbles to dust!");
		/* KMH -- Bullet-proofing */
		/*if (uamul)*/
			/*useup(uamul);*/

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			useup(uamul);
			goto lsdone;
		}

		(void) adjattrib(A_CON, -1, TRUE, TRUE);
		if(u.uhpmax <= 0) u.uhpmax = 10;	/* arbitrary */
		savelife(how);
/* useup() had to be moved for savelife() to distingush between Lifesaved */
/* and Second_chance */
		useup(uamul);
		if (how == GENOCIDED)
			pline("Unfortunately you are still genocided...");
		else {

			killer = 0;
			killer_format = 0;
#ifdef LIVELOGFILE
			livelog_avert_death();
#endif
			u.youaredead = 0;

			return;
		}
	}
lsdone:

	if (uimplant && uimplant->oartifact == ART_DECAPITATION_UP && how <= GENOCIDED) {
		pline("But wait...");
		Your("implant %s!", !Blind ? "begins to glow" : "feels warm");
		You_feel("much better!");
		pline_The("implant crumbles to dust!");
		useup(uimplant);

		if (wanttodie) {
			pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
			goto implantdone;
		}

		(void) adjattrib(A_CON, -1, TRUE, TRUE);
		if(u.uhpmax <= 0) u.uhpmax = 10;	/* arbitrary */
		savelife(how);
		if (how == GENOCIDED)
			pline("Unfortunately you are still genocided...");
		else {

			killer = 0;
			killer_format = 0;
#ifdef LIVELOGFILE
			livelog_avert_death();
#endif
			u.youaredead = 0;

			return;
		}

	}

implantdone:

	if (MenuIsBugged && how < GENOCIDED) {
		pline("But wait! You still have the menu bug!");

		if (yn_function("Come back to life?", ynchars, 'y') == 'y' ) {

			if (wanttodie) {
				pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
				goto menunosedone;
			}

			if (u.ulevel > 2) {
			    losexp("menu bug", TRUE, FALSE);
			    losexp("menu bug", TRUE, FALSE);
			    pline("You hit the 'exit' button to escape from the grave! There you are again, back from the dead...");
			    if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
			    savelife(how);
			    killer = 0;
			    killer_format = 0;

				/* lose all items */

			while (invent) {
			    for (otmp = invent; otmp; otmp = otmp2) {
			      otmp2 = otmp->nobj;

				if (evades_destruction(otmp) ) dropx(otmp);
				else {
				delete_contents(otmp);
				useup(otmp);}
			    }
			}

				/* lose all spells */
				for (n = 0; n < MAXSPELL && spellid(n) != NO_SPELL; n++) {
			    spellid(n) = NO_SPELL;
				}

				if (Aggravate_monster) {
					u.aggravation = 1;
					reset_rndmonst(NON_PM);
				}

				(void) makemon(mkclass(S_HUMAN,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_HUMANOID,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_DEMON,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_GNOME,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_OGRE,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_GIANT,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_KOP,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_ORC,0), u.ux, u.uy, NO_MM_FLAGS);

				u.aggravation = 0;

			    (void) safe_teleds(FALSE);

#ifdef LIVELOGFILE
			    livelog_avert_death();
#endif
			    u.youaredead = 0;

			    return;
			}

			else pline("You frantically hit the 'exit' button to escape from the grave... but it doesn't work...");

		}

	}
menunosedone:

	if (Race_if(PM_RODNEYAN) && how < GENOCIDED) {
		pline("But you're Rodney, so your death isn't permanent!");

		if (yn_function("Revive?", ynchars, 'y') == 'y' ) {

			if (wanttodie) {
				pline("Nyehehe-hehe-he, you would have lifesaved but you said you want your possessions identified! GAME OVER!");
				goto rodneydone;
			}

			if (u.ulevel > 2) {
			    losexp("Rodneyan resurrection", TRUE, FALSE);
			    losexp("Rodneyan resurrection", TRUE, FALSE);
			    pline("You reappear in good health!");
			    if(u.uhpmax <= 0) u.uhpmax = 1;	/* arbitrary */
			    savelife(how);
			    killer = 0;
			    killer_format = 0;

				/* lose all items */

			while (invent) {
			    for (otmp = invent; otmp; otmp = otmp2) {
			      otmp2 = otmp->nobj;

				if (evades_destruction(otmp) ) dropx(otmp);
				else {
				delete_contents(otmp);
				useup(otmp);}
			    }
			}

				/* lose all spells */
				for (n = 0; n < MAXSPELL && spellid(n) != NO_SPELL; n++) {
			    spellid(n) = NO_SPELL;
				}

				if (Aggravate_monster) {
					u.aggravation = 1;
					reset_rndmonst(NON_PM);
				}

				(void) makemon(mkclass(S_HUMAN,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_HUMANOID,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_DEMON,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_GNOME,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_OGRE,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_GIANT,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_KOP,0), u.ux, u.uy, NO_MM_FLAGS);
				(void) makemon(mkclass(S_ORC,0), u.ux, u.uy, NO_MM_FLAGS);

				u.aggravation = 0;

			    (void) safe_teleds(FALSE);

#ifdef LIVELOGFILE
			    livelog_avert_death();
#endif
			    u.youaredead = 0;

			    return;
			}

			else pline("Too bad! Your experience level is too low for revival to work...");

		}

	}
rodneydone:

	/* if you triggered a bones trap, bad luck - you can now leave bones even if you disabled them :P --Amy */
	bones_ok = (iflags.bones || (BonesLevelChange || u.uprops[BONES_CHANGE].extrinsic || have_bonestone()) ) && (how < GENOCIDED) && can_make_bones(); /* dthexpl patch */

	if ((
#ifdef WIZARD
			wizard ||
#endif
			discover) && (how <= GENOCIDED || how == TURNED_SLIME)) {
		if(yn("Die?") == 'y') goto die;
		pline("OK, so you don't %s.",
			(how == CHOKING) ? "choke" : "die");
		if(u.uhpmax <= 0) u.uhpmax = u.ulevel * 8;	/* arbitrary */
		savelife(how);
		killer = 0;
		killer_format = 0;
		u.youaredead = 0;
		return;
	}

	else if (iflags.death_expl && how <= GENOCIDED && !bones_ok &&
#ifdef WIZARD
		 !wizard &&
#endif
		 !discover) {
	  u.hangupcheat = 666; /* Not "game over" yet, so let's prevent filthy cheaters from doing their thing --Amy */
	  if(yn("Continue in explore mode?") == 'y') {
	    enter_explore_mode();
	    if (discover) goexplore = TRUE;
	    u.youaredead = 0;
	  }
	}

	if (how == ASCENDED) {
		/* Amy edit: allow the player to keep their character and go on playing if they ascend! */
freeplaycheck:
		if (yn("CONGRATULATIONS!!! You've beaten the game. You can go on playing now if you want. Do you want to keep playing your character?") == 'y') {

			getlin ("You decided to keep playing your character. Please confirm your choice with yes [y/yes/no]",buf);
			(void) lcase (buf);
			if (!(strcmp (buf, "yes")) || !(strcmp (buf, "y"))) { /* yes, do go on playing after ascending */

				gofreeplay = TRUE;

			} else goto freeplaycheck;

		} else {
			getlin ("You decided to end the game here. Please confirm your choice with yes [y/yes/no]",buf);
			(void) lcase (buf);
			if (strcmp (buf, "yes") && strcmp (buf, "y")) goto freeplaycheck;
			/* else the game ends here */
		}

	}

    /*
     *	The game is now over...
     */

die:
	if(u.uhpmax <= 0) u.uhpmax = 1; /* fixing a VERY annoying dump_techniques SIGFPE */
	u.hangupcheat = 0;
	if (!goexplore && !gofreeplay) {
	program_state.gameover = 1;
	/* in case of a subsequent panic(), there's no point trying to save */
	program_state.something_worth_saving = 0;
#ifdef DUMP_LOG
	/* D: Grab screen dump right here */
	if (dump_fn[0]) {
	  dump_init();
	  sprintf(pbuf, "%s, %s %s %s %s", playeraliasname,
		  aligns[1 - u.ualign.type].adj,
		  genders[flags.female].adj,
		  urace.adj,
		  (flags.female && urole.name.f)?
		   urole.name.f : urole.name.m);
	  dump("", pbuf);
	  /* D: Add a line for clearance from the screen dump */
	  dump("", "");
	  dump_screen();
	}

	if (lastmsg >= 0) {
		char tmpbuf[BUFSZ];
		int i,j;
		dump("Latest messages", "");
		for (j = lastmsg + 1; j < DUMPMSGS + lastmsg + 1; j++) {
		  i = j % DUMPMSGS;
		  if (msgs[i] && strcmp(msgs[i], "") ) {
		    if (msgs_count[i] == 1) {
		      dump("  ", msgs[i]);
		    } else {
		      sprintf(tmpbuf, "%s (%dx)", msgs[i], msgs_count[i]);
		      dump("  ", tmpbuf);
		    }
		  }
		}
		dump("","");
	}

	(void)doredraw();

#endif /* DUMP_LOG */

#ifdef WHEREIS_FILE
	delete_whereis();
#endif

	} /* if (!goexplore) */
	/* render vision subsystem inoperative */
	iflags.vision_inited = 0;
	/* might have been killed while using a disposable item, so make sure
	   it's gone prior to inventory disclosure and creation of bones data */
	inven_inuse(TRUE);

#ifdef RECORD_REALTIME
        /* Update the realtime counter to reflect the playtime of the current
         * game. */
        realtime_data.realtime = get_realtime();
#endif /* RECORD_REALTIME */

	/* Sometimes you die on the first move.  Life's not fair.
	 * On those rare occasions you get hosed immediately, go out
	 * smiling... :-)  -3.
	 */
	if (Frozen) pline("Your body shatters and melts into ice cubes."); /* Diablo 2 */

	if (botl_score() == 0 && how < PANICKED)
		pline("You didn't even score a single point. You noob!");

	if (moves <= 1 && how < PANICKED)	/* You die... --More-- */
	    pline("Do not pass go.  Do not collect 200 %s.", currency(200L));
	else if (moves == 2 && how < PANICKED) {
	    if (!issoviet) pline("Do not pass go.  Do not collect 200 %s.", currency(200L));
	    else pline("Nekotoryye pizda nazvali sovetskiy reshil, chto vy ne mozhete poluchit' zabavnoye soobshcheniye pryamo seychas.");
	}
	/* I'll allow you to see this message if you die on your second turn, too. --Amy */

	if (have_windows) wait_synch();	/* flush screen output */
	if (!goexplore && !gofreeplay) {
#ifndef NO_SIGNAL
	(void) signal(SIGINT, (SIG_RET_TYPE) done_intr);
# if defined(UNIX) || defined(VMS) || defined (__EMX__)
	(void) signal(SIGQUIT, (SIG_RET_TYPE) done_intr);
	(void) signal(SIGHUP, (SIG_RET_TYPE) done_hangup);
# endif
#endif /* NO_SIGNAL */

#ifdef ALLEG_FX
        if(iflags.usealleg && (how < PANICKED))
                fade_to_black();
#endif

	/* bones_ok = (how < GENOCIDED) && can_make_bones(); moved up */

	if (how == TURNED_SLIME)
	    u.ugrave_arise = PM_GREEN_SLIME;

	if (bones_ok && u.ugrave_arise < LOW_PM) {
	    /* corpse gets burnt up too */
	    if (how == BURNING)
		u.ugrave_arise = (NON_PM - 2);	/* leave no corpse */
	    else if (how == STONING)
		u.ugrave_arise = (NON_PM - 1);	/* statue instead of corpse */
	    else if (u.ugrave_arise == NON_PM &&
		     !(mvitals[u.umonnum].mvflags & G_NOCORPSE)) {
		int mnum = u.umonnum;

		if (!Upolyd) {
		    /* Base corpse on race when not poly'd since original
		     * u.umonnum is based on role, and all role monsters
		     * are human.
		     */
		    mnum = undead_to_corpse(
			(flags.female && urace.femalenum != NON_PM) ?
			urace.femalenum : urace.malenum);
		}
		corpse = mk_named_object(CORPSE, &mons[mnum], u.ux, u.uy, playeraliasname);
		sprintf(pbuf, "%s, %s%s", playeraliasname,
			killer_format == NO_KILLER_PREFIX ? "" :
			killed_by_prefix[how],
			killer_format == KILLED_BY_AN ? an(killer) : killer);
#ifdef EPITAPH
		/* ask player if he wants a custom epitaph */
		if ('y' == yn("Do you want to write your own epitaph?")) {
			getlin("What do you want your epitaph to be?",ebuf);
			sprintf(pbuf, "Here lies %s. %s", playeraliasname, ebuf);
		}
#endif
		make_grave(u.ux, u.uy, pbuf);
	    }
	}
	} /* if (!goexplore) */
	if (how == TURNED_SLIME) killer_format = NO_KILLER_PREFIX;
	if (how == QUIT) {
		killer_format = NO_KILLER_PREFIX;
		if (u.uhp < 1) {
			how = DIED;
			u.umortality++;	/* skipped above when how==QUIT */
			/* note that killer is pointing at kilbuf */
			strcpy(kilbuf, "quit while already on Charon's boat");
		}
	}
	if (how == ESCAPED || how == PANICKED)
		killer_format = NO_KILLER_PREFIX;

	if (how != PANICKED) {
	    /* these affect score and/or bones, but avoid them during panic */
	    taken = paybill((how == ESCAPED) ? -1 : (how != QUIT));
	    paygd();
	    clearpriests();
	} else	taken = FALSE;	/* lint; assert( !bones_ok ); */

	if (!goexplore && !gofreeplay) {
	clearlocks();

	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);

	if (strcmp(flags.end_disclose, "none") && how != PANICKED)
		disclose(how, taken);
	/* finish_paybill should be called after disclosure but before bones */
	if (bones_ok && taken) finish_paybill();
	}

	/* calculate score, before creating bones [container gold] */
	{
	    long tmp;
	    int deepest = deepest_lev_reached(FALSE);

#ifndef GOLDOBJ
	    umoney = u.ugold;
	    tmp = u.ugold0;
#else
	    umoney = money_cnt(invent);
	    tmp = u.umoney0;
#endif
	    umoney += hidden_gold();	/* accumulate gold from containers */
	    tmp = umoney - tmp;		/* net gain */

	    if (tmp < 0L)
		tmp = 0L;
	    if (how < PANICKED)
		tmp -= tmp / 10L;
	    u.urexp += tmp;
	    u.urexp += 50L * (long)(deepest - 1);
	    if (deepest > 20)
		u.urexp += 1000L * (long)((deepest > 30) ? 10 : deepest - 20);
	    if (how == ASCENDED) {
		u.urexp *= 2L;

		if (gofreeplay) {

			discover = FALSE; /* a kludge to fool the topten function.. */
			topten(how);
			umoney -= hidden_gold();
			if (u.urexp > 1) u.urexp /= 2;
			u.urexp -= tmp;
			u.urexp -= 50L * (long)(deepest - 1);
			vision_reset();
			if (flags.moreforced && !MessagesSuppressed) display_nhwindow(WIN_MESSAGE, TRUE);    /* --More-- */
			(void)doredraw();
			u.freeplaymode = TRUE;
			u.freeplaytransit = TRUE;
			u.freeplayplanes = FALSE;

			if (u.uhave.amulet) { /* no longer need the amulet, now that you've won */
				struct obj *otmpi, *otmpii;
				if (invent) {
					for (otmpi = invent; otmpi; otmpi = otmpii) {
					      otmpii = otmpi->nobj;
						if (otmpi->otyp == AMULET_OF_YENDOR) {							
							if (otmpi->owornmask) {
								setnotworn(otmpi);
							}
							dropx(otmpi);
						}
					}
				}
			}
			goto_level(&medusa_level, TRUE, FALSE, FALSE);

			register int newlevX = 1;
			d_level newlevelX;
			get_level(&newlevelX, newlevX);
			goto_level(&newlevelX, TRUE, FALSE, FALSE);
			u.freeplaytransit = FALSE;
			pline("You find yourself back in the dungeon. Since you've officially won the game, you can freely explore now. If you want to go back to the Elemental Planes, you have to visit Moloch's Sanctum first. You can also retire (commit suicide) when you are ready.");

			return;

		}

	    }
	    if (goexplore) {
	      discover = FALSE; /* a kludge to fool the topten function.. */
	      topten(how);
	      /* undo some things that were done for score calculation */
	      /* this branch is not entered when you ascend, escape or quit */
	      discover = TRUE;
	      umoney -= hidden_gold();
	      u.urexp -= tmp;
	      u.urexp -= 50L * (long)(deepest - 1);
	      /* now do what is done when you refuse to die in explore mode */
	      if (u.uhpmax <= 0) u.uhpmax = u.ulevel * 8;
	      savelife(how);
	      killer = 0;
	      killer_format = 0;
	      vision_reset();
		if (flags.moreforced && !MessagesSuppressed) display_nhwindow(WIN_MESSAGE, TRUE);    /* --More-- */
		(void)doredraw();
	      return;
	    }
	}

	if (bones_ok) {
#ifdef WIZARD
		/* KMH -- We need the "Save bones?" prompt for testing! */
	    if (!wizard || yn("Save bones?") == 'y')
#endif
		{if (Frozen) corpse = (struct obj *)0; /* no corpse if player exploded into ice cubes --Amy */
		savebones(corpse);
		}
	    /* corpse may be invalid pointer now so
		ensure that it isn't used again */
	    corpse = (struct obj *)0;
	}

	/* update gold for the rip output, which can't use hidden_gold()
	   (containers will be gone by then if bones just got saved...) */
#ifndef GOLDOBJ
	u.ugold = umoney;
#else
	done_money = umoney;
#endif

	/* clean up unneeded windows */
	if (have_windows) {
	    wait_synch();
	    display_nhwindow(WIN_MESSAGE, TRUE);
	    destroy_nhwindow(WIN_MAP);
	    destroy_nhwindow(WIN_STATUS);
	    destroy_nhwindow(WIN_MESSAGE);
	    WIN_MESSAGE = WIN_STATUS = WIN_MAP = WIN_ERR;

	    if(!done_stopprint || flags.tombstone)
		endwin = create_nhwindow(NHW_TEXT);

	    if (how < GENOCIDED && flags.tombstone && endwin != WIN_ERR)
		outrip(endwin, how);
	} else
	    done_stopprint = 1; /* just avoid any more output */

/* changing kilbuf really changes killer. we do it this way because
   killer is declared a (const char *)
*/
	if (u.uhave.amulet) strcat(kilbuf, " (with the Amulet)");
	/*else*/ if (how == ESCAPED) {
	    if (Is_astralevel(&u.uz))	/* offered Amulet to wrong deity */
		strcat(kilbuf, " (in celestial disgrace)");
	    /*else*/ if (carrying(FAKE_AMULET_OF_YENDOR))
		strcat(kilbuf, " (with a fake Amulet)");
		/* don't bother counting to see whether it should be plural */
	}
	/* since we're not removing the amulet any longer (this is by design)... had to restore celestial disgrace --Amy */

//	if (!done_stopprint) {
	    sprintf(pbuf, "%s %s the %s...", Goodbye(), playeraliasname,
		   how != ASCENDED ?
		      (const char *) ((flags.female && urole.name.f) ?
		         urole.name.f : urole.name.m) :
		      (const char *) (flags.female ? "Demigoddess" : "Demigod"));
	if (!done_stopprint) {
	    putstr(endwin, 0, pbuf);
	    /*putstr(endwin, 0, "");*/
	}
#ifdef DUMP_LOG
	if (dump_fp) dump("", pbuf);
#endif

	if (how == ESCAPED || how == ASCENDED) {
	    register struct monst *mtmp;
	    register struct obj *otmp;
	    register struct val_list *val;
	    register int i;

	    for (val = valuables; val->list; val++)
		for (i = 0; i < val->size; i++) {
		    val->list[i].count = 0L;
		}
	    get_valuables(invent);

	    /* add points for collected valuables */
	    for (val = valuables; val->list; val++)
		for (i = 0; i < val->size; i++)
		    if (val->list[i].count != 0L)
			u.urexp += val->list[i].count
				  * (long)objects[val->list[i].typ].oc_cost;

	    /* count the points for artifacts */
	    artifact_score(invent, TRUE, endwin);

	    keepdogs(TRUE);
	    viz_array[0][0] |= IN_SIGHT; /* need visibility for naming */
	    mtmp = mydogs;
	    strcpy(pbuf, "You");
	    if (mtmp) {
		while (mtmp) {
			sprintf(eos(pbuf), " and %s", mon_nam(mtmp));
		    if (mtmp->mtame)
			u.urexp += mtmp->mhp;
		    mtmp = mtmp->nmon;
		}
		if (!done_stopprint) putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
		if (dump_fp) dump("", pbuf);
#endif
		pbuf[0] = '\0';
	    } else {
		if (!done_stopprint) strcat(pbuf, " ");
	    }
		sprintf(eos(pbuf), "%s with %ld point%s,",
			how==ASCENDED ? "went to your reward" :
					"escaped from the dungeon",
			u.urexp, plur(u.urexp));
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	    if (!done_stopprint) {
		putstr(endwin, 0, pbuf);
	    }

	    if (!done_stopprint)
		artifact_score(invent, FALSE, endwin);	/* list artifacts */

	    /* list valuables here */
	    for (val = valuables; val->list; val++) {
		sort_valuables(val->list, val->size);
		for (i = 0; i < val->size && !done_stopprint; i++) {
		    int typ = val->list[i].typ;
		    long count = val->list[i].count;

		    if (count == 0L) continue;
		    if (objects[typ].oc_class != GEM_CLASS || typ <= LAST_GEM) {
			otmp = mksobj(typ, FALSE, FALSE);
			if (otmp) {
				makeknown(otmp->otyp);
				otmp->known = 1;	/* for fake amulets */
				otmp->dknown = 1;	/* seen it (blindness fix) */
				otmp->onamelth = 0;
				otmp->quan = count;
				sprintf(pbuf, "%8ld %s (worth %ld %s),",
					count, xname(otmp),
					count * (long)objects[typ].oc_cost, currency(2L));
				obfree(otmp, (struct obj *)0);
			}
		    } else {
			sprintf(pbuf,
				"%8ld worthless piece%s of colored glass,",
				count, plur(count));
		    }
		    putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
		    if (dump_fp) dump("", pbuf);
#endif
		}
	    }

	} else if (!done_stopprint) {
	    /* did not escape or ascend */
	    if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
		/* level teleported out of the dungeon; `how' is DIED,
		   due to falling or to "arriving at heaven prematurely" */
		sprintf(pbuf, "You %s beyond the confines of the dungeon",
			(u.uz.dlevel < 0) ? "passed away" : ends[how]);
	    } else {
		/* more conventional demise */
		const char *where = dungeons[u.uz.dnum].dname;

		if (Is_astralevel(&u.uz)) where = "The Astral Plane";
		sprintf(pbuf, "You %s in %s", ends[how], where);
		if (!In_endgame(&u.uz) && !Is_knox(&u.uz))
		    sprintf(eos(pbuf), " on dungeon level %d",
			    In_quest(&u.uz) ? dunlev(&u.uz) : depth(&u.uz));
	    }

	    sprintf(eos(pbuf), " with %ld point%s,",
		    u.urexp, plur(u.urexp));
	    putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	}

	if (!done_stopprint) {
	    sprintf(pbuf, "and %ld piece%s of gold, after %ld move%s.",
		    umoney, plur(umoney), moves, plur(moves));
	    putstr(endwin, 0, pbuf);
#ifdef DUMP_LOG
	    if (dump_fp) {
	      dump("", pbuf);
	      sprintf(pbuf, "Killer: %s", killer);
	      dump("", pbuf);
	    }
#endif
	}
	if (!done_stopprint) {
	    sprintf(pbuf,
	     "You were level %d with a maximum of %d hit point%s when you %s.",
		    u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
	    putstr(endwin, 0, pbuf);
	    /*putstr(endwin, 0, "");*/
#ifdef DUMP_LOG
	    if (dump_fp) dump("", pbuf);
#endif
	}
	if (!done_stopprint)
	    display_nhwindow(endwin, TRUE);
	if (endwin != WIN_ERR)
	    destroy_nhwindow(endwin);

	/* "So when I die, the first thing I will see in Heaven is a
	 * score list?" */
	if (flags.toptenwin) {
	    topten(how);
	    if (have_windows)
		exit_nhwindows((char *)0);
	} else {
	    if (have_windows)
		exit_nhwindows((char *)0);
	    topten(how);
	}
#ifdef DUMP_LOG
	if (dump_fp) dump_exit();
#endif

	if(done_stopprint) { raw_print(""); raw_print(""); }
	terminate(EXIT_SUCCESS);
}


void
container_contents(list, identified, all_containers)
struct obj *list;
boolean identified, all_containers;
#ifdef DUMP_LOG
{
	do_containerconts(list, identified, all_containers, FALSE);
}

void do_containerconts(list, identified, all_containers, want_dump)
struct obj *list;
boolean identified, all_containers, want_dump;
#endif
/* The original container_contents function */
{
	register struct obj *box, *obj;
	struct obj **oarray;
	int i,j,n;
	char *invlet;
	char buf[BUFSZ];

	for (box = list; box; box = box->nobj) {
	    if (Is_container(box) || box->otyp == STATUE) {
		if (box->otyp == BAG_OF_TRICKS) {
		    continue;	/* wrong type of container */
		} else if (box->cobj) {
		    winid tmpwin = create_nhwindow(NHW_MENU);

                   /* count the number of items */
                   for (n = 0, obj = box->cobj; obj; obj = obj->nobj) n++;
                   /* Make a temporary array to store the objects sorted */
                   oarray = (struct obj **) alloc(n*sizeof(struct obj*));

                   /* Add objects to the array */
                   i = 0;
                   invlet = flags.inv_order;
nextclass:
                   for (obj = box->cobj; obj; obj = obj->nobj) {
                      if (!flags.sortpack || obj->oclass == *invlet) {
                       if (iflags.sortloot == 'f'
                           || iflags.sortloot == 'l') {
                         /* Insert object at correct index */
                         for (j = i; j; j--) {
                           if (strcmpi(cxname2(obj), cxname2(oarray[j-1]))>0
                           || (flags.sortpack &&
                               oarray[j-1]->oclass != obj->oclass))
                             break;
                           oarray[j] = oarray[j-1];
                         }
                         oarray[j] = obj;
                         i++;
                       } else {
                         /* Just add it to the array */
                         oarray[i++] = obj;
                       }
                     }
                   } /* for loop */
                   if (flags.sortpack) {
                     if (*++invlet) goto nextclass;
                   }

		    sprintf(buf, "Contents of %s:", the(xname(box)));
		    putstr(tmpwin, 0, buf);
		    putstr(tmpwin, 0, "");
#ifdef DUMP_LOG
		    if (dump_fp) dump("", buf);
#endif
                   for (i = 0; i < n; i++) {
                       obj = oarray[i];

		    /*for (obj = box->cobj; obj; obj = obj->nobj) {*/ /* pre-sortloot */
			if (identified) {
			    makeknown(obj->otyp);
			    obj->known = obj->bknown =
			    obj->dknown = obj->rknown = 1;
			}
			putstr(tmpwin, 0, doname(obj));
#ifdef DUMP_LOG
			if (want_dump)  dump("  ", doname(obj));
#endif
		    }
#ifdef DUMP_LOG
		    if (want_dump)  dump("","");
#endif
		    display_nhwindow(tmpwin, TRUE);
		    destroy_nhwindow(tmpwin);
		    if (all_containers) {
#ifdef DUMP_LOG
			do_containerconts(box->cobj, identified, TRUE,
					  want_dump);
#else
			container_contents(box->cobj, identified, TRUE);
#endif /* DUMP_LOG */
		    }
		} else {
		    pline("%s empty.", Tobjnam(box, "are"));
		    display_nhwindow(WIN_MESSAGE, FALSE);
#ifdef DUMP_LOG
		    if (want_dump) {
		      dump(The(xname(box)), " is empty.");
		      dump("", "");
		    }
#endif
		}
	    }
	    if (!all_containers)
		break;
	}
}

/* should be called with either EXIT_SUCCESS or EXIT_FAILURE */
void
terminate(status)
int status;
{
#ifdef MAC
	getreturn("to exit");
#endif
	/* don't bother to try to release memory if we're in panic mode, to
	   avoid trouble in case that happens to be due to memory problems */
	if (!program_state.panicking) {
	    freedynamicdata();
	    dlb_cleanup();
	}

	nethack_exit(status);
}

STATIC_OVL boolean
list_vanquished(defquery, ask)
char defquery;
boolean ask;
#ifdef DUMP_LOG
{
  do_vanquished(defquery, ask, FALSE);

	/* potentially unsafe because this function should return something... --Amy */
}

void
do_vanquished(defquery, ask, want_dump)
int defquery;
boolean ask;
boolean want_dump;
#endif
{
    register int i, lev;
    int ntypes = 0, max_lev = 0, nkilled;
    long total_killed = 0L;
    long total_born = 0L;
    long bosses_killed = 0L;
    long bosses_born = 0L;
    char c;
    winid klwin;
    char buf[BUFSZ];

    /* get totals first */
    for (i = LOW_PM; i < NUMMONS; i++) {
	if (mvitals[i].died || program_state.gameover || wizard ) ntypes++;
	total_killed += (long)mvitals[i].died;
	total_born += (long)mvitals[i].born;
	if (mons[i].geno & G_UNIQ) bosses_killed += (long)mvitals[i].died;
	if (mons[i].geno & G_UNIQ) bosses_born += (long)mvitals[i].born;
	if (mons[i].mlevel > max_lev) max_lev = mons[i].mlevel;
    }

    /* vanquished creatures list;
     * includes all dead monsters, not just those killed by the player
     */
    if (ntypes != 0) {
	c = ask ? yn_function("Do you want an account of creatures vanquished?",
			      ynqchars, defquery) : defquery;
	if (c == 'q') done_stopprint++;
	if (c != 'q') {
	    klwin = create_nhwindow(NHW_MENU);
	    putstr(klwin, 0, "Vanquished creatures:");
	    putstr(klwin, 0, "");
#ifdef DUMP_LOG
	    if (want_dump)  dump("", "Vanquished creatures");
#endif

	    /* countdown by monster "toughness" */
	    /*for (lev = max_lev; lev >= 0; lev--)*/
	      for (i = LOW_PM; i < NUMMONS; i++)
		if (/*mons[i].mlevel == lev &&*/ (((nkilled = mvitals[i].died) > 0) || (nkilled != mvitals[i].born && (program_state.gameover || wizard)) ) ) {
		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST) {
			sprintf(buf, "%s%s",
				!type_is_pname(&mons[i]) ? "The " : "",
				mons[i].mname);
			if (nkilled != 1) {
			    switch (nkilled) {
				case 2:  sprintf(eos(buf)," (twice)");  break;
				case 3:  sprintf(eos(buf)," (thrice)");  break;
				default: sprintf(eos(buf)," (%d time%s)",
						 nkilled, plur(nkilled));
					 break;
			    }
			}
		    } else {
			/* trolls or undead might have come back,
			   but we don't keep track of that */
			if (nkilled == 1)
			    strcpy(buf, an(mons[i].mname));
			else
			    sprintf(buf, "%d %s",
				    nkilled, makeplural(mons[i].mname));
			if (nkilled != mvitals[i].born && (program_state.gameover || wizard)) /* only show this after death --Amy */
			    sprintf(buf + strlen(buf), " (%d created)",
				    (int) mvitals[i].born);
		    }
		    putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		    if (want_dump)  dump("  ", buf);
#endif
		}
	    /*
	     * if (Hallucination)
	     *     putstr(klwin, 0, "and a partridge in a pear tree");
	     */
	    if (ntypes > 1) {
		putstr(klwin, 0, "");

		if (program_state.gameover || wizard) {
			sprintf(buf, "%ld creature%s born.", total_born, total_born == 1 ? "" : "s");
			putstr(klwin, 0, buf);
#ifdef DUMP_LOG
			if (want_dump)  dump("  ", buf);
#endif
		}

		sprintf(buf, "%ld creature%s vanquished.", total_killed, total_killed == 1 ? "" : "s");
		putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		if (want_dump)  dump("  ", buf);
#endif


		if (program_state.gameover || wizard) {
			sprintf(buf, "%ld boss%s born.", bosses_born, bosses_born == 1 ? "" : "es");
			putstr(klwin, 0, buf);
#ifdef DUMP_LOG
			if (want_dump)  dump("  ", buf);
#endif
		}

		sprintf(buf, "%ld boss%s vanquished.", bosses_killed, bosses_killed == 1 ? "" : "es");
		putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		if (want_dump)  dump("  ", buf);
#endif

	    }
	    display_nhwindow(klwin, TRUE);
	    destroy_nhwindow(klwin);
#ifdef DUMP_LOG
	    if (want_dump)  dump("", "");
#endif
	}
    }
#ifdef DUMP_LOG
    return;
#else
    return (boolean) (total_killed);
#endif
}

int
dolistvanq()
{
    if (!list_vanquished('y', FALSE))
        pline("Vanquished monsters listing complete."); /* because dumplog changed that function to a void! --Amy */
    return(0);
}
    
/* number of monster species which have been genocided */
int
num_genocides()
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
	if (mvitals[i].mvflags & G_GENOD) ++n;

    return n;
}

#ifdef DUMP_LOG
STATIC_OVL void
list_genocided(defquery, ask, want_dump)
int defquery;
boolean ask;
boolean want_dump;
#else
STATIC_OVL void
list_genocided(defquery, ask)
char defquery;
boolean ask;
#endif
{
    register int i;
    int ngenocided=0;
    int nextincted=0;
    char c;
    winid klwin;
    char buf[BUFSZ];

    /* get totals first */
    for (i = LOW_PM; i < NUMMONS; i++) {
	if (mvitals[i].mvflags & G_GENOD)
	    ngenocided++;
	else if ( (mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ) )
	    nextincted++;
    }

    /*ngenocided = num_genocides();*/

    /* genocided species list */
    if (ngenocided != 0 || nextincted != 0) {
	c = ask ? yn_function("Do you want a list of species genocided?",
			      ynqchars, defquery) : defquery;
	if (c == 'q') done_stopprint++;
	if (c != 'q') {
	    klwin = create_nhwindow(NHW_MENU);
	    sprintf(buf, "Genocided species:");
	    putstr(klwin, 0, buf);
	    putstr(klwin, 0, "");
#ifdef DUMP_LOG
	    if (want_dump)  dump("", buf);
#endif

	    for (i = LOW_PM; i < NUMMONS; i++)
		if (mvitals[i].mvflags & G_GONE && !(mons[i].geno & G_UNIQ) ) {
		/*if (mvitals[i].mvflags & G_GENOD) {*/
		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
			sprintf(buf, "%s%s",
				!type_is_pname(&mons[i]) ? "" : "the ",
				mons[i].mname);
		    else
			strcpy(buf, makeplural(mons[i].mname));
		    if( !(mvitals[i].mvflags & G_GENOD) )
			strcat(buf, " (extinct)");
		    putstr(klwin, 0, buf);
#ifdef DUMP_LOG
		    if (want_dump)  dump("  ", buf);
#endif
		}

	    putstr(klwin, 0, "");
	    sprintf(buf, "%d species genocided.", ngenocided);
	    putstr(klwin, 0, buf);
#ifdef DUMP_LOG
	    if (want_dump)  dump("  ", buf);
#endif

		sprintf(buf, "%d species extinct.", nextincted);
		putstr(klwin, 0, buf);
	    display_nhwindow(klwin, TRUE);
	    destroy_nhwindow(klwin);
	}
    }
}

void
mk_dgl_extrainfo()
{
#ifdef EXTRAINFO_FN
    FILE *extrai = (FILE *)0;
#ifdef UNIX
    mode_t eimode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif
    char new_fn[512];

	/* certain nasty traps obscure the information - so we want to hide it from whereis too! --Amy */
	if (DisplayDoesNotGo || TheInfoIsFucked) {
		return;
	}

    sprintf(new_fn, "%s", dump_format_str(EXTRAINFO_FN));

    extrai = fopen_datafile_area(FILE_AREA_VAR, new_fn, "w", LEVELPREFIX);
    if (!extrai) {
    } else {
        char tmpdng[16];
	  int sortval = 0;
        if (Is_knox(&u.uz)) {
		sortval = 1000;
            sprintf(tmpdng, "%i|%s", sortval, "Knx");
        } else if (In_quest(&u.uz)) { /* this depends on the fact that the quest is never longer than 7 levels --Amy */
		sortval = 1500 + depth(&u.uz);
            sprintf(tmpdng, "%i|%s%i", sortval, "  Q", dunlev(&u.uz));
        } else if (In_endgame(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "End");
		sortval = 10000;
        } else if (In_sokoban_real(&u.uz)) {
            sprintf(tmpdng, "%i|Sok%i", sortval, depth(&u.uz));
		sortval = 200 + depth(&u.uz);
        } else if (In_mines(&u.uz)) {
            sprintf(tmpdng, "%i|Min%i", sortval, depth(&u.uz));
		sortval = 150 + depth(&u.uz);
        } else if (In_sheol(&u.uz)) {
            sprintf(tmpdng, "%i|She%i", sortval, depth(&u.uz));
		sortval = 4000 + depth(&u.uz);
        } else if (In_yendorian(&u.uz)) {
            sprintf(tmpdng, "%i|Yen%i", sortval, depth(&u.uz));
		sortval = 6000 + depth(&u.uz);
        } else if (In_forging(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "For");
		sortval = 7500 + depth(&u.uz);
        } else if (In_ordered(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Ord");
		sortval = 7500 + depth(&u.uz);
        } else if (In_deadground(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Dea");
		sortval = 7500 + depth(&u.uz);
        } else if (In_illusorycastle(&u.uz)) {
            sprintf(tmpdng, "%i|Ill%i", sortval, depth(&u.uz));
		sortval = 3000 + depth(&u.uz);
        } else if (In_voiddungeon(&u.uz)) {
            sprintf(tmpdng, "%i|Voi%i", sortval, depth(&u.uz));
		sortval = 5000 + depth(&u.uz);
        } else if (In_netherrealm(&u.uz)) {
            sprintf(tmpdng, "%i|Net%i", sortval, depth(&u.uz));
		sortval = 5500 + depth(&u.uz);
        } else if (In_deepmines(&u.uz)) {
            sprintf(tmpdng, "%i|Dee%i", sortval, depth(&u.uz));
		sortval = 1200 + depth(&u.uz);
        } else if (In_angmar(&u.uz)) {
            sprintf(tmpdng, "%i|Ang%i", sortval, depth(&u.uz));
		sortval = 3200 + depth(&u.uz);
        } else if (In_swimmingpool(&u.uz)) {
            sprintf(tmpdng, "%i|Swi%i", sortval, depth(&u.uz));
		sortval = 3300 + depth(&u.uz);
        } else if (In_hellbathroom(&u.uz)) {
            sprintf(tmpdng, "%i|Bat%i", sortval, depth(&u.uz));
		sortval = 3100 + depth(&u.uz);
        } else if (In_spacebase(&u.uz)) {
            sprintf(tmpdng, "%i|Spa%i", sortval, depth(&u.uz));
		sortval = 500 + depth(&u.uz);
        } else if (In_sewerplant(&u.uz)) {
            sprintf(tmpdng, "%i|Sew%i", sortval, depth(&u.uz));
		sortval = 700 + depth(&u.uz);
        } else if (In_gammacaves(&u.uz)) {
            sprintf(tmpdng, "%i|Gam%i", sortval, depth(&u.uz));
		sortval = 900 + depth(&u.uz);
        } else if (In_mainframe(&u.uz)) {
            sprintf(tmpdng, "%i|Mai%i", sortval, depth(&u.uz));
		sortval = 1100 + depth(&u.uz);
        } else if (In_subquest(&u.uz)) {
            sprintf(tmpdng, "%i|Sub%i", sortval, depth(&u.uz));
		sortval = 1800 + depth(&u.uz);
        } else if (In_bellcaves(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Bel");
		sortval = 1900 + depth(&u.uz);
        } else if (In_towndungeon(&u.uz)) {
            sprintf(tmpdng, "%i|Tow%i", sortval, depth(&u.uz));
		sortval = 400 + depth(&u.uz);
        } else if (In_spiders(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Spi");
		sortval = 1500 + depth(&u.uz);
        } else if (In_grund(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Gru");
		sortval = 1200 + depth(&u.uz);
        } else if (In_wyrm(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Wyr");
		sortval = 1600 + depth(&u.uz);
        } else if (In_tomb(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Tom");
		sortval = 1000 + depth(&u.uz);
        } else if (In_slsea(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Sun");
		sortval = 1600 + depth(&u.uz);
        } else if (In_gcavern(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Gia");
		sortval = 1600 + depth(&u.uz);
        } else if (In_frnkn(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Frn");
		sortval = 3500 + depth(&u.uz);
        } else if (In_mtemple(&u.uz)) {
            sprintf(tmpdng, "%i|%s", sortval, "Mol");
		sortval = 1000 + depth(&u.uz);
        } else {
		if (depth(&u.uz) < 10) sprintf(tmpdng, "%i|  D%i", sortval, depth(&u.uz));
		else if (depth(&u.uz) < 100) sprintf(tmpdng, "%i| D%i", sortval, depth(&u.uz));
            sprintf(tmpdng, "%i|D%i", sortval, depth(&u.uz));
        }

#ifdef UNIX
        chmod(new_fn, eimode);
#endif
	  fwrite(tmpdng,strlen(tmpdng),1,extrai);
        fclose(extrai);
    }
#endif /* EXTRAINFO_FN */
}


/*end.c*/
